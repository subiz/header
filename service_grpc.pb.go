// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.31.0
// source: service.proto

package header

import (
	context "context"
	account "github.com/subiz/header/account"
	common "github.com/subiz/header/common"
	payment "github.com/subiz/header/payment"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	GooglekonService_SendEventToGoogle_FullMethodName           = "/header.GooglekonService/SendEventToGoogle"
	GooglekonService_ReadGoogleLocationSetting_FullMethodName   = "/header.GooglekonService/ReadGoogleLocationSetting"
	GooglekonService_UpdateGoogleLocationSetting_FullMethodName = "/header.GooglekonService/UpdateGoogleLocationSetting"
	GooglekonService_ListGoogleLocationSettings_FullMethodName  = "/header.GooglekonService/ListGoogleLocationSettings"
)

// GooglekonServiceClient is the client API for GooglekonService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GooglekonServiceClient interface {
	SendEventToGoogle(ctx context.Context, in *Events, opts ...grpc.CallOption) (*Empty, error)
	ReadGoogleLocationSetting(ctx context.Context, in *Id, opts ...grpc.CallOption) (*GoogleLocationSetting, error)
	UpdateGoogleLocationSetting(ctx context.Context, in *GoogleLocationSetting, opts ...grpc.CallOption) (*GoogleLocationSetting, error)
	ListGoogleLocationSettings(ctx context.Context, in *Id, opts ...grpc.CallOption) (*GoogleLocationSettings, error)
}

type googlekonServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGooglekonServiceClient(cc grpc.ClientConnInterface) GooglekonServiceClient {
	return &googlekonServiceClient{cc}
}

func (c *googlekonServiceClient) SendEventToGoogle(ctx context.Context, in *Events, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, GooglekonService_SendEventToGoogle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *googlekonServiceClient) ReadGoogleLocationSetting(ctx context.Context, in *Id, opts ...grpc.CallOption) (*GoogleLocationSetting, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GoogleLocationSetting)
	err := c.cc.Invoke(ctx, GooglekonService_ReadGoogleLocationSetting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *googlekonServiceClient) UpdateGoogleLocationSetting(ctx context.Context, in *GoogleLocationSetting, opts ...grpc.CallOption) (*GoogleLocationSetting, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GoogleLocationSetting)
	err := c.cc.Invoke(ctx, GooglekonService_UpdateGoogleLocationSetting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *googlekonServiceClient) ListGoogleLocationSettings(ctx context.Context, in *Id, opts ...grpc.CallOption) (*GoogleLocationSettings, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GoogleLocationSettings)
	err := c.cc.Invoke(ctx, GooglekonService_ListGoogleLocationSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GooglekonServiceServer is the server API for GooglekonService service.
// All implementations must embed UnimplementedGooglekonServiceServer
// for forward compatibility.
type GooglekonServiceServer interface {
	SendEventToGoogle(context.Context, *Events) (*Empty, error)
	ReadGoogleLocationSetting(context.Context, *Id) (*GoogleLocationSetting, error)
	UpdateGoogleLocationSetting(context.Context, *GoogleLocationSetting) (*GoogleLocationSetting, error)
	ListGoogleLocationSettings(context.Context, *Id) (*GoogleLocationSettings, error)
	mustEmbedUnimplementedGooglekonServiceServer()
}

// UnimplementedGooglekonServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGooglekonServiceServer struct{}

func (UnimplementedGooglekonServiceServer) SendEventToGoogle(context.Context, *Events) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendEventToGoogle not implemented")
}
func (UnimplementedGooglekonServiceServer) ReadGoogleLocationSetting(context.Context, *Id) (*GoogleLocationSetting, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadGoogleLocationSetting not implemented")
}
func (UnimplementedGooglekonServiceServer) UpdateGoogleLocationSetting(context.Context, *GoogleLocationSetting) (*GoogleLocationSetting, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGoogleLocationSetting not implemented")
}
func (UnimplementedGooglekonServiceServer) ListGoogleLocationSettings(context.Context, *Id) (*GoogleLocationSettings, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGoogleLocationSettings not implemented")
}
func (UnimplementedGooglekonServiceServer) mustEmbedUnimplementedGooglekonServiceServer() {}
func (UnimplementedGooglekonServiceServer) testEmbeddedByValue()                          {}

// UnsafeGooglekonServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GooglekonServiceServer will
// result in compilation errors.
type UnsafeGooglekonServiceServer interface {
	mustEmbedUnimplementedGooglekonServiceServer()
}

func RegisterGooglekonServiceServer(s grpc.ServiceRegistrar, srv GooglekonServiceServer) {
	// If the following call pancis, it indicates UnimplementedGooglekonServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GooglekonService_ServiceDesc, srv)
}

func _GooglekonService_SendEventToGoogle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Events)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GooglekonServiceServer).SendEventToGoogle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GooglekonService_SendEventToGoogle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GooglekonServiceServer).SendEventToGoogle(ctx, req.(*Events))
	}
	return interceptor(ctx, in, info, handler)
}

func _GooglekonService_ReadGoogleLocationSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GooglekonServiceServer).ReadGoogleLocationSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GooglekonService_ReadGoogleLocationSetting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GooglekonServiceServer).ReadGoogleLocationSetting(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _GooglekonService_UpdateGoogleLocationSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GoogleLocationSetting)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GooglekonServiceServer).UpdateGoogleLocationSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GooglekonService_UpdateGoogleLocationSetting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GooglekonServiceServer).UpdateGoogleLocationSetting(ctx, req.(*GoogleLocationSetting))
	}
	return interceptor(ctx, in, info, handler)
}

func _GooglekonService_ListGoogleLocationSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GooglekonServiceServer).ListGoogleLocationSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GooglekonService_ListGoogleLocationSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GooglekonServiceServer).ListGoogleLocationSettings(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

// GooglekonService_ServiceDesc is the grpc.ServiceDesc for GooglekonService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GooglekonService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.GooglekonService",
	HandlerType: (*GooglekonServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendEventToGoogle",
			Handler:    _GooglekonService_SendEventToGoogle_Handler,
		},
		{
			MethodName: "ReadGoogleLocationSetting",
			Handler:    _GooglekonService_ReadGoogleLocationSetting_Handler,
		},
		{
			MethodName: "UpdateGoogleLocationSetting",
			Handler:    _GooglekonService_UpdateGoogleLocationSetting_Handler,
		},
		{
			MethodName: "ListGoogleLocationSettings",
			Handler:    _GooglekonService_ListGoogleLocationSettings_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	DocSearch_IndexConvo_FullMethodName          = "/header.DocSearch/IndexConvo"
	DocSearch_SearchConvos_FullMethodName        = "/header.DocSearch/SearchConvos"
	DocSearch_Index_FullMethodName               = "/header.DocSearch/Index"
	DocSearch_Search_FullMethodName              = "/header.DocSearch/Search"
	DocSearch_SearchIds_FullMethodName           = "/header.DocSearch/SearchIds"
	DocSearch_ReportConversation_FullMethodName  = "/header.DocSearch/ReportConversation"
	DocSearch_Report_FullMethodName              = "/header.DocSearch/Report"
	DocSearch_ListIds_FullMethodName             = "/header.DocSearch/ListIds"
	DocSearch_ListConversationIds_FullMethodName = "/header.DocSearch/ListConversationIds"
	DocSearch_ReportCall_FullMethodName          = "/header.DocSearch/ReportCall"
	DocSearch_ListCallIds_FullMethodName         = "/header.DocSearch/ListCallIds"
	DocSearch_ReportAgent_FullMethodName         = "/header.DocSearch/ReportAgent"
	DocSearch_HealthCheckReport_FullMethodName   = "/header.DocSearch/HealthCheckReport"
	DocSearch_HealthCheckIndex_FullMethodName    = "/header.DocSearch/HealthCheckIndex"
)

// DocSearchClient is the client API for DocSearch service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DocSearchClient interface {
	IndexConvo(ctx context.Context, in *DocIndexRequest, opts ...grpc.CallOption) (*Empty, error)
	SearchConvos(ctx context.Context, in *DocSearchRequest, opts ...grpc.CallOption) (*DocSearchResponse, error)
	Index(ctx context.Context, in *DocIndexRequest, opts ...grpc.CallOption) (*Empty, error)
	Search(ctx context.Context, in *DocSearchRequest, opts ...grpc.CallOption) (*DocSearchResponse, error)
	SearchIds(ctx context.Context, in *DocSearchRequest, opts ...grpc.CallOption) (*DocSearchResponse, error)
	ReportConversation(ctx context.Context, in *ConversationMetricsRequest, opts ...grpc.CallOption) (*ConversationMetrics, error)
	Report(ctx context.Context, in *ConvoReportRequest, opts ...grpc.CallOption) (*ConvoReportResponse, error)
	ListIds(ctx context.Context, in *ConvoReportRequest, opts ...grpc.CallOption) (*Conversations, error)
	ListConversationIds(ctx context.Context, in *ConversationMetricsRequest, opts ...grpc.CallOption) (*Conversations, error)
	ReportCall(ctx context.Context, in *CallMetricsRequest, opts ...grpc.CallOption) (*CallMetrics, error)
	ListCallIds(ctx context.Context, in *CallMetricsRequest, opts ...grpc.CallOption) (*Conversations, error)
	ReportAgent(ctx context.Context, in *AgentMetricsRequest, opts ...grpc.CallOption) (*AgentMetrics, error)
	// healthcheck
	HealthCheckReport(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	HealthCheckIndex(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
}

type docSearchClient struct {
	cc grpc.ClientConnInterface
}

func NewDocSearchClient(cc grpc.ClientConnInterface) DocSearchClient {
	return &docSearchClient{cc}
}

func (c *docSearchClient) IndexConvo(ctx context.Context, in *DocIndexRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, DocSearch_IndexConvo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *docSearchClient) SearchConvos(ctx context.Context, in *DocSearchRequest, opts ...grpc.CallOption) (*DocSearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DocSearchResponse)
	err := c.cc.Invoke(ctx, DocSearch_SearchConvos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *docSearchClient) Index(ctx context.Context, in *DocIndexRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, DocSearch_Index_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *docSearchClient) Search(ctx context.Context, in *DocSearchRequest, opts ...grpc.CallOption) (*DocSearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DocSearchResponse)
	err := c.cc.Invoke(ctx, DocSearch_Search_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *docSearchClient) SearchIds(ctx context.Context, in *DocSearchRequest, opts ...grpc.CallOption) (*DocSearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DocSearchResponse)
	err := c.cc.Invoke(ctx, DocSearch_SearchIds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *docSearchClient) ReportConversation(ctx context.Context, in *ConversationMetricsRequest, opts ...grpc.CallOption) (*ConversationMetrics, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConversationMetrics)
	err := c.cc.Invoke(ctx, DocSearch_ReportConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *docSearchClient) Report(ctx context.Context, in *ConvoReportRequest, opts ...grpc.CallOption) (*ConvoReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConvoReportResponse)
	err := c.cc.Invoke(ctx, DocSearch_Report_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *docSearchClient) ListIds(ctx context.Context, in *ConvoReportRequest, opts ...grpc.CallOption) (*Conversations, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Conversations)
	err := c.cc.Invoke(ctx, DocSearch_ListIds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *docSearchClient) ListConversationIds(ctx context.Context, in *ConversationMetricsRequest, opts ...grpc.CallOption) (*Conversations, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Conversations)
	err := c.cc.Invoke(ctx, DocSearch_ListConversationIds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *docSearchClient) ReportCall(ctx context.Context, in *CallMetricsRequest, opts ...grpc.CallOption) (*CallMetrics, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CallMetrics)
	err := c.cc.Invoke(ctx, DocSearch_ReportCall_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *docSearchClient) ListCallIds(ctx context.Context, in *CallMetricsRequest, opts ...grpc.CallOption) (*Conversations, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Conversations)
	err := c.cc.Invoke(ctx, DocSearch_ListCallIds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *docSearchClient) ReportAgent(ctx context.Context, in *AgentMetricsRequest, opts ...grpc.CallOption) (*AgentMetrics, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentMetrics)
	err := c.cc.Invoke(ctx, DocSearch_ReportAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *docSearchClient) HealthCheckReport(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, DocSearch_HealthCheckReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *docSearchClient) HealthCheckIndex(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, DocSearch_HealthCheckIndex_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DocSearchServer is the server API for DocSearch service.
// All implementations must embed UnimplementedDocSearchServer
// for forward compatibility.
type DocSearchServer interface {
	IndexConvo(context.Context, *DocIndexRequest) (*Empty, error)
	SearchConvos(context.Context, *DocSearchRequest) (*DocSearchResponse, error)
	Index(context.Context, *DocIndexRequest) (*Empty, error)
	Search(context.Context, *DocSearchRequest) (*DocSearchResponse, error)
	SearchIds(context.Context, *DocSearchRequest) (*DocSearchResponse, error)
	ReportConversation(context.Context, *ConversationMetricsRequest) (*ConversationMetrics, error)
	Report(context.Context, *ConvoReportRequest) (*ConvoReportResponse, error)
	ListIds(context.Context, *ConvoReportRequest) (*Conversations, error)
	ListConversationIds(context.Context, *ConversationMetricsRequest) (*Conversations, error)
	ReportCall(context.Context, *CallMetricsRequest) (*CallMetrics, error)
	ListCallIds(context.Context, *CallMetricsRequest) (*Conversations, error)
	ReportAgent(context.Context, *AgentMetricsRequest) (*AgentMetrics, error)
	// healthcheck
	HealthCheckReport(context.Context, *Empty) (*Empty, error)
	HealthCheckIndex(context.Context, *Empty) (*Empty, error)
	mustEmbedUnimplementedDocSearchServer()
}

// UnimplementedDocSearchServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDocSearchServer struct{}

func (UnimplementedDocSearchServer) IndexConvo(context.Context, *DocIndexRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IndexConvo not implemented")
}
func (UnimplementedDocSearchServer) SearchConvos(context.Context, *DocSearchRequest) (*DocSearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchConvos not implemented")
}
func (UnimplementedDocSearchServer) Index(context.Context, *DocIndexRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Index not implemented")
}
func (UnimplementedDocSearchServer) Search(context.Context, *DocSearchRequest) (*DocSearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedDocSearchServer) SearchIds(context.Context, *DocSearchRequest) (*DocSearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchIds not implemented")
}
func (UnimplementedDocSearchServer) ReportConversation(context.Context, *ConversationMetricsRequest) (*ConversationMetrics, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportConversation not implemented")
}
func (UnimplementedDocSearchServer) Report(context.Context, *ConvoReportRequest) (*ConvoReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Report not implemented")
}
func (UnimplementedDocSearchServer) ListIds(context.Context, *ConvoReportRequest) (*Conversations, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListIds not implemented")
}
func (UnimplementedDocSearchServer) ListConversationIds(context.Context, *ConversationMetricsRequest) (*Conversations, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListConversationIds not implemented")
}
func (UnimplementedDocSearchServer) ReportCall(context.Context, *CallMetricsRequest) (*CallMetrics, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportCall not implemented")
}
func (UnimplementedDocSearchServer) ListCallIds(context.Context, *CallMetricsRequest) (*Conversations, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCallIds not implemented")
}
func (UnimplementedDocSearchServer) ReportAgent(context.Context, *AgentMetricsRequest) (*AgentMetrics, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportAgent not implemented")
}
func (UnimplementedDocSearchServer) HealthCheckReport(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheckReport not implemented")
}
func (UnimplementedDocSearchServer) HealthCheckIndex(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheckIndex not implemented")
}
func (UnimplementedDocSearchServer) mustEmbedUnimplementedDocSearchServer() {}
func (UnimplementedDocSearchServer) testEmbeddedByValue()                   {}

// UnsafeDocSearchServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DocSearchServer will
// result in compilation errors.
type UnsafeDocSearchServer interface {
	mustEmbedUnimplementedDocSearchServer()
}

func RegisterDocSearchServer(s grpc.ServiceRegistrar, srv DocSearchServer) {
	// If the following call pancis, it indicates UnimplementedDocSearchServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DocSearch_ServiceDesc, srv)
}

func _DocSearch_IndexConvo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocSearchServer).IndexConvo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocSearch_IndexConvo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocSearchServer).IndexConvo(ctx, req.(*DocIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocSearch_SearchConvos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocSearchServer).SearchConvos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocSearch_SearchConvos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocSearchServer).SearchConvos(ctx, req.(*DocSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocSearch_Index_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocSearchServer).Index(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocSearch_Index_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocSearchServer).Index(ctx, req.(*DocIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocSearch_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocSearchServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocSearch_Search_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocSearchServer).Search(ctx, req.(*DocSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocSearch_SearchIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocSearchServer).SearchIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocSearch_SearchIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocSearchServer).SearchIds(ctx, req.(*DocSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocSearch_ReportConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConversationMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocSearchServer).ReportConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocSearch_ReportConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocSearchServer).ReportConversation(ctx, req.(*ConversationMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocSearch_Report_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvoReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocSearchServer).Report(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocSearch_Report_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocSearchServer).Report(ctx, req.(*ConvoReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocSearch_ListIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvoReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocSearchServer).ListIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocSearch_ListIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocSearchServer).ListIds(ctx, req.(*ConvoReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocSearch_ListConversationIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConversationMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocSearchServer).ListConversationIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocSearch_ListConversationIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocSearchServer).ListConversationIds(ctx, req.(*ConversationMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocSearch_ReportCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocSearchServer).ReportCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocSearch_ReportCall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocSearchServer).ReportCall(ctx, req.(*CallMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocSearch_ListCallIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocSearchServer).ListCallIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocSearch_ListCallIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocSearchServer).ListCallIds(ctx, req.(*CallMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocSearch_ReportAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AgentMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocSearchServer).ReportAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocSearch_ReportAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocSearchServer).ReportAgent(ctx, req.(*AgentMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocSearch_HealthCheckReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocSearchServer).HealthCheckReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocSearch_HealthCheckReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocSearchServer).HealthCheckReport(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocSearch_HealthCheckIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocSearchServer).HealthCheckIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocSearch_HealthCheckIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocSearchServer).HealthCheckIndex(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// DocSearch_ServiceDesc is the grpc.ServiceDesc for DocSearch service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DocSearch_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.DocSearch",
	HandlerType: (*DocSearchServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IndexConvo",
			Handler:    _DocSearch_IndexConvo_Handler,
		},
		{
			MethodName: "SearchConvos",
			Handler:    _DocSearch_SearchConvos_Handler,
		},
		{
			MethodName: "Index",
			Handler:    _DocSearch_Index_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _DocSearch_Search_Handler,
		},
		{
			MethodName: "SearchIds",
			Handler:    _DocSearch_SearchIds_Handler,
		},
		{
			MethodName: "ReportConversation",
			Handler:    _DocSearch_ReportConversation_Handler,
		},
		{
			MethodName: "Report",
			Handler:    _DocSearch_Report_Handler,
		},
		{
			MethodName: "ListIds",
			Handler:    _DocSearch_ListIds_Handler,
		},
		{
			MethodName: "ListConversationIds",
			Handler:    _DocSearch_ListConversationIds_Handler,
		},
		{
			MethodName: "ReportCall",
			Handler:    _DocSearch_ReportCall_Handler,
		},
		{
			MethodName: "ListCallIds",
			Handler:    _DocSearch_ListCallIds_Handler,
		},
		{
			MethodName: "ReportAgent",
			Handler:    _DocSearch_ReportAgent_Handler,
		},
		{
			MethodName: "HealthCheckReport",
			Handler:    _DocSearch_HealthCheckReport_Handler,
		},
		{
			MethodName: "HealthCheckIndex",
			Handler:    _DocSearch_HealthCheckIndex_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	NumberRegistry_Compact_FullMethodName        = "/header.NumberRegistry/Compact"
	NumberRegistry_Uncompact_FullMethodName      = "/header.NumberRegistry/Uncompact"
	NumberRegistry_CompactM_FullMethodName       = "/header.NumberRegistry/CompactM"
	NumberRegistry_ShortenPayment_FullMethodName = "/header.NumberRegistry/ShortenPayment"
	NumberRegistry_LookupPayment_FullMethodName  = "/header.NumberRegistry/LookupPayment"
	NumberRegistry_NewID2_FullMethodName         = "/header.NumberRegistry/NewID2"
	NumberRegistry_GetLastID_FullMethodName      = "/header.NumberRegistry/GetLastID"
)

// NumberRegistryClient is the client API for NumberRegistry service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NumberRegistryClient interface {
	Compact(ctx context.Context, in *String, opts ...grpc.CallOption) (*Number, error)
	Uncompact(ctx context.Context, in *Number, opts ...grpc.CallOption) (*String, error)
	CompactM(ctx context.Context, in *StrNumM, opts ...grpc.CallOption) (*StrNumM, error)
	ShortenPayment(ctx context.Context, in *String, opts ...grpc.CallOption) (*String, error)
	LookupPayment(ctx context.Context, in *String, opts ...grpc.CallOption) (*String, error)
	NewID2(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Id, error)
	GetLastID(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Id, error)
}

type numberRegistryClient struct {
	cc grpc.ClientConnInterface
}

func NewNumberRegistryClient(cc grpc.ClientConnInterface) NumberRegistryClient {
	return &numberRegistryClient{cc}
}

func (c *numberRegistryClient) Compact(ctx context.Context, in *String, opts ...grpc.CallOption) (*Number, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Number)
	err := c.cc.Invoke(ctx, NumberRegistry_Compact_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *numberRegistryClient) Uncompact(ctx context.Context, in *Number, opts ...grpc.CallOption) (*String, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(String)
	err := c.cc.Invoke(ctx, NumberRegistry_Uncompact_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *numberRegistryClient) CompactM(ctx context.Context, in *StrNumM, opts ...grpc.CallOption) (*StrNumM, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StrNumM)
	err := c.cc.Invoke(ctx, NumberRegistry_CompactM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *numberRegistryClient) ShortenPayment(ctx context.Context, in *String, opts ...grpc.CallOption) (*String, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(String)
	err := c.cc.Invoke(ctx, NumberRegistry_ShortenPayment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *numberRegistryClient) LookupPayment(ctx context.Context, in *String, opts ...grpc.CallOption) (*String, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(String)
	err := c.cc.Invoke(ctx, NumberRegistry_LookupPayment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *numberRegistryClient) NewID2(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Id)
	err := c.cc.Invoke(ctx, NumberRegistry_NewID2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *numberRegistryClient) GetLastID(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Id)
	err := c.cc.Invoke(ctx, NumberRegistry_GetLastID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NumberRegistryServer is the server API for NumberRegistry service.
// All implementations must embed UnimplementedNumberRegistryServer
// for forward compatibility.
type NumberRegistryServer interface {
	Compact(context.Context, *String) (*Number, error)
	Uncompact(context.Context, *Number) (*String, error)
	CompactM(context.Context, *StrNumM) (*StrNumM, error)
	ShortenPayment(context.Context, *String) (*String, error)
	LookupPayment(context.Context, *String) (*String, error)
	NewID2(context.Context, *Id) (*Id, error)
	GetLastID(context.Context, *Id) (*Id, error)
	mustEmbedUnimplementedNumberRegistryServer()
}

// UnimplementedNumberRegistryServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNumberRegistryServer struct{}

func (UnimplementedNumberRegistryServer) Compact(context.Context, *String) (*Number, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Compact not implemented")
}
func (UnimplementedNumberRegistryServer) Uncompact(context.Context, *Number) (*String, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Uncompact not implemented")
}
func (UnimplementedNumberRegistryServer) CompactM(context.Context, *StrNumM) (*StrNumM, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompactM not implemented")
}
func (UnimplementedNumberRegistryServer) ShortenPayment(context.Context, *String) (*String, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShortenPayment not implemented")
}
func (UnimplementedNumberRegistryServer) LookupPayment(context.Context, *String) (*String, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LookupPayment not implemented")
}
func (UnimplementedNumberRegistryServer) NewID2(context.Context, *Id) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewID2 not implemented")
}
func (UnimplementedNumberRegistryServer) GetLastID(context.Context, *Id) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLastID not implemented")
}
func (UnimplementedNumberRegistryServer) mustEmbedUnimplementedNumberRegistryServer() {}
func (UnimplementedNumberRegistryServer) testEmbeddedByValue()                        {}

// UnsafeNumberRegistryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NumberRegistryServer will
// result in compilation errors.
type UnsafeNumberRegistryServer interface {
	mustEmbedUnimplementedNumberRegistryServer()
}

func RegisterNumberRegistryServer(s grpc.ServiceRegistrar, srv NumberRegistryServer) {
	// If the following call pancis, it indicates UnimplementedNumberRegistryServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NumberRegistry_ServiceDesc, srv)
}

func _NumberRegistry_Compact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(String)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NumberRegistryServer).Compact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NumberRegistry_Compact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NumberRegistryServer).Compact(ctx, req.(*String))
	}
	return interceptor(ctx, in, info, handler)
}

func _NumberRegistry_Uncompact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Number)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NumberRegistryServer).Uncompact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NumberRegistry_Uncompact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NumberRegistryServer).Uncompact(ctx, req.(*Number))
	}
	return interceptor(ctx, in, info, handler)
}

func _NumberRegistry_CompactM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StrNumM)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NumberRegistryServer).CompactM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NumberRegistry_CompactM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NumberRegistryServer).CompactM(ctx, req.(*StrNumM))
	}
	return interceptor(ctx, in, info, handler)
}

func _NumberRegistry_ShortenPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(String)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NumberRegistryServer).ShortenPayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NumberRegistry_ShortenPayment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NumberRegistryServer).ShortenPayment(ctx, req.(*String))
	}
	return interceptor(ctx, in, info, handler)
}

func _NumberRegistry_LookupPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(String)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NumberRegistryServer).LookupPayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NumberRegistry_LookupPayment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NumberRegistryServer).LookupPayment(ctx, req.(*String))
	}
	return interceptor(ctx, in, info, handler)
}

func _NumberRegistry_NewID2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NumberRegistryServer).NewID2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NumberRegistry_NewID2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NumberRegistryServer).NewID2(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _NumberRegistry_GetLastID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NumberRegistryServer).GetLastID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NumberRegistry_GetLastID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NumberRegistryServer).GetLastID(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

// NumberRegistry_ServiceDesc is the grpc.ServiceDesc for NumberRegistry service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NumberRegistry_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.NumberRegistry",
	HandlerType: (*NumberRegistryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Compact",
			Handler:    _NumberRegistry_Compact_Handler,
		},
		{
			MethodName: "Uncompact",
			Handler:    _NumberRegistry_Uncompact_Handler,
		},
		{
			MethodName: "CompactM",
			Handler:    _NumberRegistry_CompactM_Handler,
		},
		{
			MethodName: "ShortenPayment",
			Handler:    _NumberRegistry_ShortenPayment_Handler,
		},
		{
			MethodName: "LookupPayment",
			Handler:    _NumberRegistry_LookupPayment_Handler,
		},
		{
			MethodName: "NewID2",
			Handler:    _NumberRegistry_NewID2_Handler,
		},
		{
			MethodName: "GetLastID",
			Handler:    _NumberRegistry_GetLastID_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	Map_Predict_FullMethodName        = "/header.Map/Predict"
	Map_LookupAddress_FullMethodName  = "/header.Map/LookupAddress"
	Map_PredictAddress_FullMethodName = "/header.Map/PredictAddress"
	Map_ListDistricts_FullMethodName  = "/header.Map/ListDistricts"
	Map_ListProvinces_FullMethodName  = "/header.Map/ListProvinces"
	Map_ListWards_FullMethodName      = "/header.Map/ListWards"
	Map_ListStreets_FullMethodName    = "/header.Map/ListStreets"
	Map_ListAddresses_FullMethodName  = "/header.Map/ListAddresses"
	Map_ReadAddress_FullMethodName    = "/header.Map/ReadAddress"
)

// MapClient is the client API for Map service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MapClient interface {
	Predict(ctx context.Context, in *AddressAutocompleteRequest, opts ...grpc.CallOption) (*AddressAutocompleteResponses, error)
	LookupAddress(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Address, error)
	PredictAddress(ctx context.Context, in *AddressAutocompleteRequest, opts ...grpc.CallOption) (*Addresses, error)
	ListDistricts(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Addresses, error)
	ListProvinces(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Addresses, error)
	ListWards(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Addresses, error)
	ListStreets(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Addresses, error)
	ListAddresses(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Addresses, error)
	ReadAddress(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Address, error)
}

type mapClient struct {
	cc grpc.ClientConnInterface
}

func NewMapClient(cc grpc.ClientConnInterface) MapClient {
	return &mapClient{cc}
}

func (c *mapClient) Predict(ctx context.Context, in *AddressAutocompleteRequest, opts ...grpc.CallOption) (*AddressAutocompleteResponses, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddressAutocompleteResponses)
	err := c.cc.Invoke(ctx, Map_Predict_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapClient) LookupAddress(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Address, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Address)
	err := c.cc.Invoke(ctx, Map_LookupAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapClient) PredictAddress(ctx context.Context, in *AddressAutocompleteRequest, opts ...grpc.CallOption) (*Addresses, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Addresses)
	err := c.cc.Invoke(ctx, Map_PredictAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapClient) ListDistricts(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Addresses, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Addresses)
	err := c.cc.Invoke(ctx, Map_ListDistricts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapClient) ListProvinces(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Addresses, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Addresses)
	err := c.cc.Invoke(ctx, Map_ListProvinces_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapClient) ListWards(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Addresses, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Addresses)
	err := c.cc.Invoke(ctx, Map_ListWards_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapClient) ListStreets(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Addresses, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Addresses)
	err := c.cc.Invoke(ctx, Map_ListStreets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapClient) ListAddresses(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Addresses, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Addresses)
	err := c.cc.Invoke(ctx, Map_ListAddresses_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapClient) ReadAddress(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Address, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Address)
	err := c.cc.Invoke(ctx, Map_ReadAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MapServer is the server API for Map service.
// All implementations must embed UnimplementedMapServer
// for forward compatibility.
type MapServer interface {
	Predict(context.Context, *AddressAutocompleteRequest) (*AddressAutocompleteResponses, error)
	LookupAddress(context.Context, *Id) (*Address, error)
	PredictAddress(context.Context, *AddressAutocompleteRequest) (*Addresses, error)
	ListDistricts(context.Context, *Id) (*Addresses, error)
	ListProvinces(context.Context, *Id) (*Addresses, error)
	ListWards(context.Context, *Id) (*Addresses, error)
	ListStreets(context.Context, *Id) (*Addresses, error)
	ListAddresses(context.Context, *Ids) (*Addresses, error)
	ReadAddress(context.Context, *Id) (*Address, error)
	mustEmbedUnimplementedMapServer()
}

// UnimplementedMapServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMapServer struct{}

func (UnimplementedMapServer) Predict(context.Context, *AddressAutocompleteRequest) (*AddressAutocompleteResponses, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Predict not implemented")
}
func (UnimplementedMapServer) LookupAddress(context.Context, *Id) (*Address, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LookupAddress not implemented")
}
func (UnimplementedMapServer) PredictAddress(context.Context, *AddressAutocompleteRequest) (*Addresses, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PredictAddress not implemented")
}
func (UnimplementedMapServer) ListDistricts(context.Context, *Id) (*Addresses, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDistricts not implemented")
}
func (UnimplementedMapServer) ListProvinces(context.Context, *Id) (*Addresses, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProvinces not implemented")
}
func (UnimplementedMapServer) ListWards(context.Context, *Id) (*Addresses, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWards not implemented")
}
func (UnimplementedMapServer) ListStreets(context.Context, *Id) (*Addresses, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListStreets not implemented")
}
func (UnimplementedMapServer) ListAddresses(context.Context, *Ids) (*Addresses, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAddresses not implemented")
}
func (UnimplementedMapServer) ReadAddress(context.Context, *Id) (*Address, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadAddress not implemented")
}
func (UnimplementedMapServer) mustEmbedUnimplementedMapServer() {}
func (UnimplementedMapServer) testEmbeddedByValue()             {}

// UnsafeMapServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MapServer will
// result in compilation errors.
type UnsafeMapServer interface {
	mustEmbedUnimplementedMapServer()
}

func RegisterMapServer(s grpc.ServiceRegistrar, srv MapServer) {
	// If the following call pancis, it indicates UnimplementedMapServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Map_ServiceDesc, srv)
}

func _Map_Predict_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressAutocompleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).Predict(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Map_Predict_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).Predict(ctx, req.(*AddressAutocompleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Map_LookupAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).LookupAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Map_LookupAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).LookupAddress(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Map_PredictAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressAutocompleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).PredictAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Map_PredictAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).PredictAddress(ctx, req.(*AddressAutocompleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Map_ListDistricts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).ListDistricts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Map_ListDistricts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).ListDistricts(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Map_ListProvinces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).ListProvinces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Map_ListProvinces_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).ListProvinces(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Map_ListWards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).ListWards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Map_ListWards_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).ListWards(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Map_ListStreets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).ListStreets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Map_ListStreets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).ListStreets(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Map_ListAddresses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).ListAddresses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Map_ListAddresses_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).ListAddresses(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _Map_ReadAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).ReadAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Map_ReadAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).ReadAddress(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

// Map_ServiceDesc is the grpc.ServiceDesc for Map service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Map_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.Map",
	HandlerType: (*MapServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Predict",
			Handler:    _Map_Predict_Handler,
		},
		{
			MethodName: "LookupAddress",
			Handler:    _Map_LookupAddress_Handler,
		},
		{
			MethodName: "PredictAddress",
			Handler:    _Map_PredictAddress_Handler,
		},
		{
			MethodName: "ListDistricts",
			Handler:    _Map_ListDistricts_Handler,
		},
		{
			MethodName: "ListProvinces",
			Handler:    _Map_ListProvinces_Handler,
		},
		{
			MethodName: "ListWards",
			Handler:    _Map_ListWards_Handler,
		},
		{
			MethodName: "ListStreets",
			Handler:    _Map_ListStreets_Handler,
		},
		{
			MethodName: "ListAddresses",
			Handler:    _Map_ListAddresses_Handler,
		},
		{
			MethodName: "ReadAddress",
			Handler:    _Map_ReadAddress_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	RefererMgr_ListReferrerPayouts_FullMethodName      = "/header.RefererMgr/ListReferrerPayouts"
	RefererMgr_PayReferrer_FullMethodName              = "/header.RefererMgr/PayReferrer"
	RefererMgr_ListReferredCustomers_FullMethodName    = "/header.RefererMgr/ListReferredCustomers"
	RefererMgr_ListReferredBills_FullMethodName        = "/header.RefererMgr/ListReferredBills"
	RefererMgr_GetReferrerAgent_FullMethodName         = "/header.RefererMgr/GetReferrerAgent"
	RefererMgr_ListPayoutReferrerAgents_FullMethodName = "/header.RefererMgr/ListPayoutReferrerAgents"
	RefererMgr_RefererAccount_FullMethodName           = "/header.RefererMgr/RefererAccount"
	RefererMgr_UpdateReferrerAgent_FullMethodName      = "/header.RefererMgr/UpdateReferrerAgent"
)

// RefererMgrClient is the client API for RefererMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RefererMgrClient interface {
	ListReferrerPayouts(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.ReferrerPayoutBills, error)
	PayReferrer(ctx context.Context, in *account.ReferrerPayoutBill, opts ...grpc.CallOption) (*account.ReferrerPayoutBill, error)
	ListReferredCustomers(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.ReferredCustomers, error)
	ListReferredBills(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.ReferredBills, error)
	GetReferrerAgent(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.ReferrerAgent, error)
	ListPayoutReferrerAgents(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.ReferrerAgents, error)
	RefererAccount(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	UpdateReferrerAgent(ctx context.Context, in *account.ReferrerAgent, opts ...grpc.CallOption) (*account.ReferrerAgent, error)
}

type refererMgrClient struct {
	cc grpc.ClientConnInterface
}

func NewRefererMgrClient(cc grpc.ClientConnInterface) RefererMgrClient {
	return &refererMgrClient{cc}
}

func (c *refererMgrClient) ListReferrerPayouts(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.ReferrerPayoutBills, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.ReferrerPayoutBills)
	err := c.cc.Invoke(ctx, RefererMgr_ListReferrerPayouts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *refererMgrClient) PayReferrer(ctx context.Context, in *account.ReferrerPayoutBill, opts ...grpc.CallOption) (*account.ReferrerPayoutBill, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.ReferrerPayoutBill)
	err := c.cc.Invoke(ctx, RefererMgr_PayReferrer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *refererMgrClient) ListReferredCustomers(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.ReferredCustomers, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.ReferredCustomers)
	err := c.cc.Invoke(ctx, RefererMgr_ListReferredCustomers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *refererMgrClient) ListReferredBills(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.ReferredBills, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.ReferredBills)
	err := c.cc.Invoke(ctx, RefererMgr_ListReferredBills_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *refererMgrClient) GetReferrerAgent(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.ReferrerAgent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.ReferrerAgent)
	err := c.cc.Invoke(ctx, RefererMgr_GetReferrerAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *refererMgrClient) ListPayoutReferrerAgents(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.ReferrerAgents, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.ReferrerAgents)
	err := c.cc.Invoke(ctx, RefererMgr_ListPayoutReferrerAgents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *refererMgrClient) RefererAccount(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, RefererMgr_RefererAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *refererMgrClient) UpdateReferrerAgent(ctx context.Context, in *account.ReferrerAgent, opts ...grpc.CallOption) (*account.ReferrerAgent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.ReferrerAgent)
	err := c.cc.Invoke(ctx, RefererMgr_UpdateReferrerAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RefererMgrServer is the server API for RefererMgr service.
// All implementations must embed UnimplementedRefererMgrServer
// for forward compatibility.
type RefererMgrServer interface {
	ListReferrerPayouts(context.Context, *Id) (*account.ReferrerPayoutBills, error)
	PayReferrer(context.Context, *account.ReferrerPayoutBill) (*account.ReferrerPayoutBill, error)
	ListReferredCustomers(context.Context, *Id) (*account.ReferredCustomers, error)
	ListReferredBills(context.Context, *Id) (*account.ReferredBills, error)
	GetReferrerAgent(context.Context, *Id) (*account.ReferrerAgent, error)
	ListPayoutReferrerAgents(context.Context, *Id) (*account.ReferrerAgents, error)
	RefererAccount(context.Context, *Id) (*Empty, error)
	UpdateReferrerAgent(context.Context, *account.ReferrerAgent) (*account.ReferrerAgent, error)
	mustEmbedUnimplementedRefererMgrServer()
}

// UnimplementedRefererMgrServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRefererMgrServer struct{}

func (UnimplementedRefererMgrServer) ListReferrerPayouts(context.Context, *Id) (*account.ReferrerPayoutBills, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListReferrerPayouts not implemented")
}
func (UnimplementedRefererMgrServer) PayReferrer(context.Context, *account.ReferrerPayoutBill) (*account.ReferrerPayoutBill, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PayReferrer not implemented")
}
func (UnimplementedRefererMgrServer) ListReferredCustomers(context.Context, *Id) (*account.ReferredCustomers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListReferredCustomers not implemented")
}
func (UnimplementedRefererMgrServer) ListReferredBills(context.Context, *Id) (*account.ReferredBills, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListReferredBills not implemented")
}
func (UnimplementedRefererMgrServer) GetReferrerAgent(context.Context, *Id) (*account.ReferrerAgent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReferrerAgent not implemented")
}
func (UnimplementedRefererMgrServer) ListPayoutReferrerAgents(context.Context, *Id) (*account.ReferrerAgents, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPayoutReferrerAgents not implemented")
}
func (UnimplementedRefererMgrServer) RefererAccount(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefererAccount not implemented")
}
func (UnimplementedRefererMgrServer) UpdateReferrerAgent(context.Context, *account.ReferrerAgent) (*account.ReferrerAgent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateReferrerAgent not implemented")
}
func (UnimplementedRefererMgrServer) mustEmbedUnimplementedRefererMgrServer() {}
func (UnimplementedRefererMgrServer) testEmbeddedByValue()                    {}

// UnsafeRefererMgrServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RefererMgrServer will
// result in compilation errors.
type UnsafeRefererMgrServer interface {
	mustEmbedUnimplementedRefererMgrServer()
}

func RegisterRefererMgrServer(s grpc.ServiceRegistrar, srv RefererMgrServer) {
	// If the following call pancis, it indicates UnimplementedRefererMgrServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RefererMgr_ServiceDesc, srv)
}

func _RefererMgr_ListReferrerPayouts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RefererMgrServer).ListReferrerPayouts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RefererMgr_ListReferrerPayouts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RefererMgrServer).ListReferrerPayouts(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _RefererMgr_PayReferrer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.ReferrerPayoutBill)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RefererMgrServer).PayReferrer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RefererMgr_PayReferrer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RefererMgrServer).PayReferrer(ctx, req.(*account.ReferrerPayoutBill))
	}
	return interceptor(ctx, in, info, handler)
}

func _RefererMgr_ListReferredCustomers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RefererMgrServer).ListReferredCustomers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RefererMgr_ListReferredCustomers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RefererMgrServer).ListReferredCustomers(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _RefererMgr_ListReferredBills_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RefererMgrServer).ListReferredBills(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RefererMgr_ListReferredBills_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RefererMgrServer).ListReferredBills(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _RefererMgr_GetReferrerAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RefererMgrServer).GetReferrerAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RefererMgr_GetReferrerAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RefererMgrServer).GetReferrerAgent(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _RefererMgr_ListPayoutReferrerAgents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RefererMgrServer).ListPayoutReferrerAgents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RefererMgr_ListPayoutReferrerAgents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RefererMgrServer).ListPayoutReferrerAgents(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _RefererMgr_RefererAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RefererMgrServer).RefererAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RefererMgr_RefererAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RefererMgrServer).RefererAccount(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _RefererMgr_UpdateReferrerAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.ReferrerAgent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RefererMgrServer).UpdateReferrerAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RefererMgr_UpdateReferrerAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RefererMgrServer).UpdateReferrerAgent(ctx, req.(*account.ReferrerAgent))
	}
	return interceptor(ctx, in, info, handler)
}

// RefererMgr_ServiceDesc is the grpc.ServiceDesc for RefererMgr service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RefererMgr_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.RefererMgr",
	HandlerType: (*RefererMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListReferrerPayouts",
			Handler:    _RefererMgr_ListReferrerPayouts_Handler,
		},
		{
			MethodName: "PayReferrer",
			Handler:    _RefererMgr_PayReferrer_Handler,
		},
		{
			MethodName: "ListReferredCustomers",
			Handler:    _RefererMgr_ListReferredCustomers_Handler,
		},
		{
			MethodName: "ListReferredBills",
			Handler:    _RefererMgr_ListReferredBills_Handler,
		},
		{
			MethodName: "GetReferrerAgent",
			Handler:    _RefererMgr_GetReferrerAgent_Handler,
		},
		{
			MethodName: "ListPayoutReferrerAgents",
			Handler:    _RefererMgr_ListPayoutReferrerAgents_Handler,
		},
		{
			MethodName: "RefererAccount",
			Handler:    _RefererMgr_RefererAccount_Handler,
		},
		{
			MethodName: "UpdateReferrerAgent",
			Handler:    _RefererMgr_UpdateReferrerAgent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	AccountMgr_InviteEmails_FullMethodName                    = "/header.AccountMgr/InviteEmails"
	AccountMgr_GetInviteLink_FullMethodName                   = "/header.AccountMgr/GetInviteLink"
	AccountMgr_RegenerateInviteLink_FullMethodName            = "/header.AccountMgr/RegenerateInviteLink"
	AccountMgr_CheckInviteLink_FullMethodName                 = "/header.AccountMgr/CheckInviteLink"
	AccountMgr_JoinAccount_FullMethodName                     = "/header.AccountMgr/JoinAccount"
	AccountMgr_RequestOTP_FullMethodName                      = "/header.AccountMgr/RequestOTP"
	AccountMgr_LoginUsingOTP_FullMethodName                   = "/header.AccountMgr/LoginUsingOTP"
	AccountMgr_CheckEmailUsed_FullMethodName                  = "/header.AccountMgr/CheckEmailUsed"
	AccountMgr_UpdateAgentProfile_FullMethodName              = "/header.AccountMgr/UpdateAgentProfile"
	AccountMgr_GetAgentProfile_FullMethodName                 = "/header.AccountMgr/GetAgentProfile"
	AccountMgr_ListAgentProfileAccounts_FullMethodName        = "/header.AccountMgr/ListAgentProfileAccounts"
	AccountMgr_Login_FullMethodName                           = "/header.AccountMgr/Login"
	AccountMgr_OldLogin_FullMethodName                        = "/header.AccountMgr/OldLogin"
	AccountMgr_CreateGroup_FullMethodName                     = "/header.AccountMgr/CreateGroup"
	AccountMgr_UpdateGroup_FullMethodName                     = "/header.AccountMgr/UpdateGroup"
	AccountMgr_GetGroup_FullMethodName                        = "/header.AccountMgr/GetGroup"
	AccountMgr_UpdatePassword_FullMethodName                  = "/header.AccountMgr/UpdatePassword"
	AccountMgr_UpdateAgent_FullMethodName                     = "/header.AccountMgr/UpdateAgent"
	AccountMgr_DeleteAgent_FullMethodName                     = "/header.AccountMgr/DeleteAgent"
	AccountMgr_DeleteAccount_FullMethodName                   = "/header.AccountMgr/DeleteAccount"
	AccountMgr_SubizUpdateAccount_FullMethodName              = "/header.AccountMgr/SubizUpdateAccount"
	AccountMgr_CreateAgent_FullMethodName                     = "/header.AccountMgr/CreateAgent"
	AccountMgr_GetAgent_FullMethodName                        = "/header.AccountMgr/GetAgent"
	AccountMgr_LookupAgentById_FullMethodName                 = "/header.AccountMgr/LookupAgentById"
	AccountMgr_GetAccount_FullMethodName                      = "/header.AccountMgr/GetAccount"
	AccountMgr_UpdateAccount_FullMethodName                   = "/header.AccountMgr/UpdateAccount"
	AccountMgr_CreateAccount_FullMethodName                   = "/header.AccountMgr/CreateAccount"
	AccountMgr_ListAgents_FullMethodName                      = "/header.AccountMgr/ListAgents"
	AccountMgr_MatchAgent_FullMethodName                      = "/header.AccountMgr/MatchAgent"
	AccountMgr_DeleteGroup_FullMethodName                     = "/header.AccountMgr/DeleteGroup"
	AccountMgr_ListGroups_FullMethodName                      = "/header.AccountMgr/ListGroups"
	AccountMgr_ListGroups2_FullMethodName                     = "/header.AccountMgr/ListGroups2"
	AccountMgr_MatchGroup_FullMethodName                      = "/header.AccountMgr/MatchGroup"
	AccountMgr_SbzChangeEmail_FullMethodName                  = "/header.AccountMgr/SbzChangeEmail"
	AccountMgr_SyncPublicHolidays_FullMethodName              = "/header.AccountMgr/SyncPublicHolidays"
	AccountMgr_TransferOwner_FullMethodName                   = "/header.AccountMgr/TransferOwner"
	AccountMgr_CheckLoginSession_FullMethodName               = "/header.AccountMgr/CheckLoginSession"
	AccountMgr_CreateLoginSession_FullMethodName              = "/header.AccountMgr/CreateLoginSession"
	AccountMgr_ListLoginSessions_FullMethodName               = "/header.AccountMgr/ListLoginSessions"
	AccountMgr_ListApiKeys_FullMethodName                     = "/header.AccountMgr/ListApiKeys"
	AccountMgr_LogoutSession_FullMethodName                   = "/header.AccountMgr/LogoutSession"
	AccountMgr_CreateApiKey_FullMethodName                    = "/header.AccountMgr/CreateApiKey"
	AccountMgr_GetLanguage_FullMethodName                     = "/header.AccountMgr/GetLanguage"
	AccountMgr_UpdateLanguage_FullMethodName                  = "/header.AccountMgr/UpdateLanguage"
	AccountMgr_GetShopSetting_FullMethodName                  = "/header.AccountMgr/GetShopSetting"
	AccountMgr_UpdateShopSetting_FullMethodName               = "/header.AccountMgr/UpdateShopSetting"
	AccountMgr_RefetchShopAddress_FullMethodName              = "/header.AccountMgr/RefetchShopAddress"
	AccountMgr_ReadCurrency_FullMethodName                    = "/header.AccountMgr/ReadCurrency"
	AccountMgr_AutoSyncCurrency_FullMethodName                = "/header.AccountMgr/AutoSyncCurrency"
	AccountMgr_ListShopAddresses_FullMethodName               = "/header.AccountMgr/ListShopAddresses"
	AccountMgr_CreateShopAddress_FullMethodName               = "/header.AccountMgr/CreateShopAddress"
	AccountMgr_UpdateShopAddress_FullMethodName               = "/header.AccountMgr/UpdateShopAddress"
	AccountMgr_DeleteShopAddress_FullMethodName               = "/header.AccountMgr/DeleteShopAddress"
	AccountMgr_ListTaxes_FullMethodName                       = "/header.AccountMgr/ListTaxes"
	AccountMgr_CreateTax_FullMethodName                       = "/header.AccountMgr/CreateTax"
	AccountMgr_UpdateTax_FullMethodName                       = "/header.AccountMgr/UpdateTax"
	AccountMgr_DeleteTax_FullMethodName                       = "/header.AccountMgr/DeleteTax"
	AccountMgr_CheckShippingPolicy_FullMethodName             = "/header.AccountMgr/CheckShippingPolicy"
	AccountMgr_ListShippingPolicies_FullMethodName            = "/header.AccountMgr/ListShippingPolicies"
	AccountMgr_CreateShippingPolicy_FullMethodName            = "/header.AccountMgr/CreateShippingPolicy"
	AccountMgr_UpdateShippingPolicy_FullMethodName            = "/header.AccountMgr/UpdateShippingPolicy"
	AccountMgr_DeleteShippingPolicy_FullMethodName            = "/header.AccountMgr/DeleteShippingPolicy"
	AccountMgr_CreateCancellationCode_FullMethodName          = "/header.AccountMgr/CreateCancellationCode"
	AccountMgr_ListCancellationCodes_FullMethodName           = "/header.AccountMgr/ListCancellationCodes"
	AccountMgr_UpdateCancellationCode_FullMethodName          = "/header.AccountMgr/UpdateCancellationCode"
	AccountMgr_MakeDefaultTax_FullMethodName                  = "/header.AccountMgr/MakeDefaultTax"
	AccountMgr_ListPaymentMethods_FullMethodName              = "/header.AccountMgr/ListPaymentMethods"
	AccountMgr_CreatePaymentMethod_FullMethodName             = "/header.AccountMgr/CreatePaymentMethod"
	AccountMgr_UpdatePaymentMethod_FullMethodName             = "/header.AccountMgr/UpdatePaymentMethod"
	AccountMgr_DeletePaymentMethod_FullMethodName             = "/header.AccountMgr/DeletePaymentMethod"
	AccountMgr_MakeDefaultPaymentMethod_FullMethodName        = "/header.AccountMgr/MakeDefaultPaymentMethod"
	AccountMgr_ListSubizPaymentMethods_FullMethodName         = "/header.AccountMgr/ListSubizPaymentMethods"
	AccountMgr_UpdateSubizPaymentMethod_FullMethodName        = "/header.AccountMgr/UpdateSubizPaymentMethod"
	AccountMgr_DeleteSubizPaymentMethod_FullMethodName        = "/header.AccountMgr/DeleteSubizPaymentMethod"
	AccountMgr_MakeDefaultSubizPaymentMethod_FullMethodName   = "/header.AccountMgr/MakeDefaultSubizPaymentMethod"
	AccountMgr_ListIntegratedShippingProviders_FullMethodName = "/header.AccountMgr/ListIntegratedShippingProviders"
	AccountMgr_DeintegrateShippingProvider_FullMethodName     = "/header.AccountMgr/DeintegrateShippingProvider"
	AccountMgr_IntegrateShippingProvider_FullMethodName       = "/header.AccountMgr/IntegrateShippingProvider"
	AccountMgr_SendGHNAffiliateOTP_FullMethodName             = "/header.AccountMgr/SendGHNAffiliateOTP"
	AccountMgr_EnterGHNAffiliateOTP_FullMethodName            = "/header.AccountMgr/EnterGHNAffiliateOTP"
	AccountMgr_UpdateAgentPresence_FullMethodName             = "/header.AccountMgr/UpdateAgentPresence"
	AccountMgr_ListAgentPresences_FullMethodName              = "/header.AccountMgr/ListAgentPresences"
	AccountMgr_ListAgentOnlines_FullMethodName                = "/header.AccountMgr/ListAgentOnlines"
	AccountMgr_ReportAvailibilities_FullMethodName            = "/header.AccountMgr/ReportAvailibilities"
	AccountMgr_NewID_FullMethodName                           = "/header.AccountMgr/NewID"
	AccountMgr_LockLogin_FullMethodName                       = "/header.AccountMgr/LockLogin"
	AccountMgr_UnlockLogin_FullMethodName                     = "/header.AccountMgr/UnlockLogin"
	AccountMgr_ListBills_FullMethodName                       = "/header.AccountMgr/ListBills"
	AccountMgr_ListPromotionPrograms_FullMethodName           = "/header.AccountMgr/ListPromotionPrograms"
	AccountMgr_ListPromotionCodesOfProgram_FullMethodName     = "/header.AccountMgr/ListPromotionCodesOfProgram"
	AccountMgr_ListPromotionCodesOfAgent_FullMethodName       = "/header.AccountMgr/ListPromotionCodesOfAgent"
	AccountMgr_UpsertPromotionCode_FullMethodName             = "/header.AccountMgr/UpsertPromotionCode"
	AccountMgr_CheckPromotionCode_FullMethodName              = "/header.AccountMgr/CheckPromotionCode"
	AccountMgr_GetPromotionCode_FullMethodName                = "/header.AccountMgr/GetPromotionCode"
	AccountMgr_DeletePromotionCode_FullMethodName             = "/header.AccountMgr/DeletePromotionCode"
	AccountMgr_RedeemPromotionCode_FullMethodName             = "/header.AccountMgr/RedeemPromotionCode"
	AccountMgr_ListPromotionProgramInvoices_FullMethodName    = "/header.AccountMgr/ListPromotionProgramInvoices"
	AccountMgr_CreateStripeCheckoutSession_FullMethodName     = "/header.AccountMgr/CreateStripeCheckoutSession"
	AccountMgr_OnStripeEvent_FullMethodName                   = "/header.AccountMgr/OnStripeEvent"
	AccountMgr_LookupStripePaymentMethod_FullMethodName       = "/header.AccountMgr/LookupStripePaymentMethod"
	AccountMgr_DiffSubscription_FullMethodName                = "/header.AccountMgr/DiffSubscription"
	AccountMgr_AddBankAccount_FullMethodName                  = "/header.AccountMgr/AddBankAccount"
	AccountMgr_UpdateBankAccount_FullMethodName               = "/header.AccountMgr/UpdateBankAccount"
	AccountMgr_DeleteBankAccount_FullMethodName               = "/header.AccountMgr/DeleteBankAccount"
	AccountMgr_ListBankAccounts_FullMethodName                = "/header.AccountMgr/ListBankAccounts"
	AccountMgr_VerifyBankAccount_FullMethodName               = "/header.AccountMgr/VerifyBankAccount"
	AccountMgr_GenerateBankTransferRequest_FullMethodName     = "/header.AccountMgr/GenerateBankTransferRequest"
	AccountMgr_GenerateQrCodeRequest_FullMethodName           = "/header.AccountMgr/GenerateQrCodeRequest"
	AccountMgr_GetSetupFeatureStatus_FullMethodName           = "/header.AccountMgr/GetSetupFeatureStatus"
	AccountMgr_UpdateSetupFeatureStatus_FullMethodName        = "/header.AccountMgr/UpdateSetupFeatureStatus"
	AccountMgr_ListActiveAccountIds_FullMethodName            = "/header.AccountMgr/ListActiveAccountIds"
)

// AccountMgrClient is the client API for AccountMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AccountMgrClient interface {
	InviteEmails(ctx context.Context, in *InviteRequest, opts ...grpc.CallOption) (*Empty, error)
	GetInviteLink(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Id, error)
	RegenerateInviteLink(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Id, error)
	CheckInviteLink(ctx context.Context, in *Id, opts ...grpc.CallOption) (*InvitationLink, error)
	JoinAccount(ctx context.Context, in *JoinAccountRequest, opts ...grpc.CallOption) (*Response, error)
	RequestOTP(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	LoginUsingOTP(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*Response, error)
	CheckEmailUsed(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	UpdateAgentProfile(ctx context.Context, in *AgentProfile, opts ...grpc.CallOption) (*Response, error)
	GetAgentProfile(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	ListAgentProfileAccounts(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*Response, error)
	OldLogin(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*Response, error)
	CreateGroup(ctx context.Context, in *AgentGroup, opts ...grpc.CallOption) (*AgentGroup, error)
	UpdateGroup(ctx context.Context, in *AgentGroup, opts ...grpc.CallOption) (*AgentGroup, error)
	GetGroup(ctx context.Context, in *Id, opts ...grpc.CallOption) (*AgentGroup, error)
	UpdatePassword(ctx context.Context, in *NewPassword, opts ...grpc.CallOption) (*account.Agent, error)
	UpdateAgent(ctx context.Context, in *account.Agent, opts ...grpc.CallOption) (*account.Agent, error)
	DeleteAgent(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.Agent, error)
	DeleteAccount(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.Account, error)
	SubizUpdateAccount(ctx context.Context, in *account.Account, opts ...grpc.CallOption) (*account.Account, error)
	CreateAgent(ctx context.Context, in *CreateAgentRequest, opts ...grpc.CallOption) (*account.Agent, error)
	GetAgent(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.Agent, error)
	LookupAgentById(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.Agent, error)
	GetAccount(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.Account, error)
	UpdateAccount(ctx context.Context, in *account.Account, opts ...grpc.CallOption) (*account.Account, error)
	CreateAccount(ctx context.Context, in *CreateAccountRequest, opts ...grpc.CallOption) (*account.Account, error)
	ListAgents(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	MatchAgent(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
	DeleteGroup(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ListGroups(ctx context.Context, in *Id, opts ...grpc.CallOption) (*AgentGroups, error)
	ListGroups2(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	MatchGroup(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
	SbzChangeEmail(ctx context.Context, in *AgentProfile, opts ...grpc.CallOption) (*AgentProfile, error)
	SyncPublicHolidays(ctx context.Context, in *account.SyncPublicHolidaysRequest, opts ...grpc.CallOption) (*account.BusinessHours, error)
	TransferOwner(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.Agent, error)
	CheckLoginSession(ctx context.Context, in *LoginSession, opts ...grpc.CallOption) (*LoginSession, error)
	CreateLoginSession(ctx context.Context, in *Id, opts ...grpc.CallOption) (*LoginSession, error)
	ListLoginSessions(ctx context.Context, in *Id, opts ...grpc.CallOption) (*LoginSessions, error)
	ListApiKeys(ctx context.Context, in *Id, opts ...grpc.CallOption) (*LoginSessions, error)
	LogoutSession(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	CreateApiKey(ctx context.Context, in *LoginSession, opts ...grpc.CallOption) (*LoginSession, error)
	GetLanguage(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Lang, error)
	UpdateLanguage(ctx context.Context, in *LangMessage, opts ...grpc.CallOption) (*LangMessage, error)
	GetShopSetting(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ShopSetting, error)
	UpdateShopSetting(ctx context.Context, in *ShopSetting, opts ...grpc.CallOption) (*ShopSetting, error)
	RefetchShopAddress(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	ReadCurrency(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Currency, error)
	// internal
	AutoSyncCurrency(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ListShopAddresses(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Addresses, error)
	CreateShopAddress(ctx context.Context, in *Address, opts ...grpc.CallOption) (*Address, error)
	UpdateShopAddress(ctx context.Context, in *Address, opts ...grpc.CallOption) (*Address, error)
	DeleteShopAddress(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ListTaxes(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	CreateTax(ctx context.Context, in *Tax, opts ...grpc.CallOption) (*Tax, error)
	UpdateTax(ctx context.Context, in *Tax, opts ...grpc.CallOption) (*Tax, error)
	DeleteTax(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	CheckShippingPolicy(ctx context.Context, in *Order, opts ...grpc.CallOption) (*ShippingPolicies, error)
	ListShippingPolicies(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ShippingPolicies, error)
	CreateShippingPolicy(ctx context.Context, in *ShippingPolicy, opts ...grpc.CallOption) (*ShippingPolicy, error)
	UpdateShippingPolicy(ctx context.Context, in *ShippingPolicy, opts ...grpc.CallOption) (*ShippingPolicy, error)
	DeleteShippingPolicy(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	CreateCancellationCode(ctx context.Context, in *CancellationCode, opts ...grpc.CallOption) (*CancellationCode, error)
	ListCancellationCodes(ctx context.Context, in *Id, opts ...grpc.CallOption) (*CancellationCodes, error)
	UpdateCancellationCode(ctx context.Context, in *CancellationCode, opts ...grpc.CallOption) (*CancellationCode, error)
	MakeDefaultTax(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ListPaymentMethods(ctx context.Context, in *Id, opts ...grpc.CallOption) (*PaymentMethods, error)
	CreatePaymentMethod(ctx context.Context, in *PaymentMethod, opts ...grpc.CallOption) (*PaymentMethod, error)
	UpdatePaymentMethod(ctx context.Context, in *PaymentMethod, opts ...grpc.CallOption) (*PaymentMethod, error)
	DeletePaymentMethod(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	MakeDefaultPaymentMethod(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ListSubizPaymentMethods(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	UpdateSubizPaymentMethod(ctx context.Context, in *SubizPaymentMethod, opts ...grpc.CallOption) (*Response, error)
	DeleteSubizPaymentMethod(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	MakeDefaultSubizPaymentMethod(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ListIntegratedShippingProviders(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*IntegratedShippings, error)
	DeintegrateShippingProvider(ctx context.Context, in *IntegratedShipping, opts ...grpc.CallOption) (*Empty, error)
	IntegrateShippingProvider(ctx context.Context, in *IntegratedShipping, opts ...grpc.CallOption) (*IntegratedShipping, error)
	SendGHNAffiliateOTP(ctx context.Context, in *IntegratedShipping, opts ...grpc.CallOption) (*IntegratedShipping, error)
	EnterGHNAffiliateOTP(ctx context.Context, in *IntegratedShipping, opts ...grpc.CallOption) (*IntegratedShipping, error)
	UpdateAgentPresence(ctx context.Context, in *account.Presence, opts ...grpc.CallOption) (*account.Presence, error)
	ListAgentPresences(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.Presences, error)
	ListAgentOnlines(ctx context.Context, in *ListAgentOnlineRequest, opts ...grpc.CallOption) (*account.Presences, error)
	ReportAvailibilities(ctx context.Context, in *AvailibilityReportRequest, opts ...grpc.CallOption) (*ReportResponse, error)
	NewID(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Id, error)
	LockLogin(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Id, error)
	UnlockLogin(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Id, error)
	ListBills(ctx context.Context, in *Id, opts ...grpc.CallOption) (*payment.Bills, error)
	// promotion code
	ListPromotionPrograms(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	ListPromotionCodesOfProgram(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	ListPromotionCodesOfAgent(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	UpsertPromotionCode(ctx context.Context, in *PromotionCode, opts ...grpc.CallOption) (*Response, error)
	CheckPromotionCode(ctx context.Context, in *payment.Invoice, opts ...grpc.CallOption) (*Response, error)
	GetPromotionCode(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	DeletePromotionCode(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	RedeemPromotionCode(ctx context.Context, in *RedeemRequest, opts ...grpc.CallOption) (*Response, error)
	ListPromotionProgramInvoices(ctx context.Context, in *Id, opts ...grpc.CallOption) (*PromotionCodeUsage, error)
	CreateStripeCheckoutSession(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Id, error)
	OnStripeEvent(ctx context.Context, in *StripeWebhookEvent, opts ...grpc.CallOption) (*Empty, error)
	LookupStripePaymentMethod(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	DiffSubscription(ctx context.Context, in *payment.DiffSubRequest, opts ...grpc.CallOption) (*payment.Invoice, error)
	AddBankAccount(ctx context.Context, in *BankAccount, opts ...grpc.CallOption) (*Response, error)
	UpdateBankAccount(ctx context.Context, in *BankAccount, opts ...grpc.CallOption) (*Response, error)
	DeleteBankAccount(ctx context.Context, in *BankAccount, opts ...grpc.CallOption) (*Response, error)
	ListBankAccounts(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	VerifyBankAccount(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	GenerateBankTransferRequest(ctx context.Context, in *BankTransferRequest, opts ...grpc.CallOption) (*Response, error)
	GenerateQrCodeRequest(ctx context.Context, in *GenQrCodeRequest, opts ...grpc.CallOption) (*QrCode, error)
	GetSetupFeatureStatus(ctx context.Context, in *Id, opts ...grpc.CallOption) (*SetupFeatureStatus, error)
	UpdateSetupFeatureStatus(ctx context.Context, in *SetupFeatureStatus, opts ...grpc.CallOption) (*SetupFeatureStatus, error)
	ListActiveAccountIds(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
}

type accountMgrClient struct {
	cc grpc.ClientConnInterface
}

func NewAccountMgrClient(cc grpc.ClientConnInterface) AccountMgrClient {
	return &accountMgrClient{cc}
}

func (c *accountMgrClient) InviteEmails(ctx context.Context, in *InviteRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, AccountMgr_InviteEmails_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) GetInviteLink(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Id)
	err := c.cc.Invoke(ctx, AccountMgr_GetInviteLink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) RegenerateInviteLink(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Id)
	err := c.cc.Invoke(ctx, AccountMgr_RegenerateInviteLink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) CheckInviteLink(ctx context.Context, in *Id, opts ...grpc.CallOption) (*InvitationLink, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InvitationLink)
	err := c.cc.Invoke(ctx, AccountMgr_CheckInviteLink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) JoinAccount(ctx context.Context, in *JoinAccountRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_JoinAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) RequestOTP(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, AccountMgr_RequestOTP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) LoginUsingOTP(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_LoginUsingOTP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) CheckEmailUsed(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_CheckEmailUsed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) UpdateAgentProfile(ctx context.Context, in *AgentProfile, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_UpdateAgentProfile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) GetAgentProfile(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_GetAgentProfile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListAgentProfileAccounts(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_ListAgentProfileAccounts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) OldLogin(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_OldLogin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) CreateGroup(ctx context.Context, in *AgentGroup, opts ...grpc.CallOption) (*AgentGroup, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentGroup)
	err := c.cc.Invoke(ctx, AccountMgr_CreateGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) UpdateGroup(ctx context.Context, in *AgentGroup, opts ...grpc.CallOption) (*AgentGroup, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentGroup)
	err := c.cc.Invoke(ctx, AccountMgr_UpdateGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) GetGroup(ctx context.Context, in *Id, opts ...grpc.CallOption) (*AgentGroup, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentGroup)
	err := c.cc.Invoke(ctx, AccountMgr_GetGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) UpdatePassword(ctx context.Context, in *NewPassword, opts ...grpc.CallOption) (*account.Agent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.Agent)
	err := c.cc.Invoke(ctx, AccountMgr_UpdatePassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) UpdateAgent(ctx context.Context, in *account.Agent, opts ...grpc.CallOption) (*account.Agent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.Agent)
	err := c.cc.Invoke(ctx, AccountMgr_UpdateAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) DeleteAgent(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.Agent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.Agent)
	err := c.cc.Invoke(ctx, AccountMgr_DeleteAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) DeleteAccount(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.Account, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.Account)
	err := c.cc.Invoke(ctx, AccountMgr_DeleteAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) SubizUpdateAccount(ctx context.Context, in *account.Account, opts ...grpc.CallOption) (*account.Account, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.Account)
	err := c.cc.Invoke(ctx, AccountMgr_SubizUpdateAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) CreateAgent(ctx context.Context, in *CreateAgentRequest, opts ...grpc.CallOption) (*account.Agent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.Agent)
	err := c.cc.Invoke(ctx, AccountMgr_CreateAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) GetAgent(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.Agent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.Agent)
	err := c.cc.Invoke(ctx, AccountMgr_GetAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) LookupAgentById(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.Agent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.Agent)
	err := c.cc.Invoke(ctx, AccountMgr_LookupAgentById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) GetAccount(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.Account, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.Account)
	err := c.cc.Invoke(ctx, AccountMgr_GetAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) UpdateAccount(ctx context.Context, in *account.Account, opts ...grpc.CallOption) (*account.Account, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.Account)
	err := c.cc.Invoke(ctx, AccountMgr_UpdateAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) CreateAccount(ctx context.Context, in *CreateAccountRequest, opts ...grpc.CallOption) (*account.Account, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.Account)
	err := c.cc.Invoke(ctx, AccountMgr_CreateAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListAgents(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_ListAgents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) MatchAgent(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_MatchAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) DeleteGroup(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, AccountMgr_DeleteGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListGroups(ctx context.Context, in *Id, opts ...grpc.CallOption) (*AgentGroups, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentGroups)
	err := c.cc.Invoke(ctx, AccountMgr_ListGroups_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListGroups2(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_ListGroups2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) MatchGroup(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_MatchGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) SbzChangeEmail(ctx context.Context, in *AgentProfile, opts ...grpc.CallOption) (*AgentProfile, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentProfile)
	err := c.cc.Invoke(ctx, AccountMgr_SbzChangeEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) SyncPublicHolidays(ctx context.Context, in *account.SyncPublicHolidaysRequest, opts ...grpc.CallOption) (*account.BusinessHours, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.BusinessHours)
	err := c.cc.Invoke(ctx, AccountMgr_SyncPublicHolidays_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) TransferOwner(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.Agent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.Agent)
	err := c.cc.Invoke(ctx, AccountMgr_TransferOwner_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) CheckLoginSession(ctx context.Context, in *LoginSession, opts ...grpc.CallOption) (*LoginSession, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginSession)
	err := c.cc.Invoke(ctx, AccountMgr_CheckLoginSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) CreateLoginSession(ctx context.Context, in *Id, opts ...grpc.CallOption) (*LoginSession, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginSession)
	err := c.cc.Invoke(ctx, AccountMgr_CreateLoginSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListLoginSessions(ctx context.Context, in *Id, opts ...grpc.CallOption) (*LoginSessions, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginSessions)
	err := c.cc.Invoke(ctx, AccountMgr_ListLoginSessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListApiKeys(ctx context.Context, in *Id, opts ...grpc.CallOption) (*LoginSessions, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginSessions)
	err := c.cc.Invoke(ctx, AccountMgr_ListApiKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) LogoutSession(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, AccountMgr_LogoutSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) CreateApiKey(ctx context.Context, in *LoginSession, opts ...grpc.CallOption) (*LoginSession, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginSession)
	err := c.cc.Invoke(ctx, AccountMgr_CreateApiKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) GetLanguage(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Lang, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Lang)
	err := c.cc.Invoke(ctx, AccountMgr_GetLanguage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) UpdateLanguage(ctx context.Context, in *LangMessage, opts ...grpc.CallOption) (*LangMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LangMessage)
	err := c.cc.Invoke(ctx, AccountMgr_UpdateLanguage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) GetShopSetting(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ShopSetting, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShopSetting)
	err := c.cc.Invoke(ctx, AccountMgr_GetShopSetting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) UpdateShopSetting(ctx context.Context, in *ShopSetting, opts ...grpc.CallOption) (*ShopSetting, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShopSetting)
	err := c.cc.Invoke(ctx, AccountMgr_UpdateShopSetting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) RefetchShopAddress(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_RefetchShopAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ReadCurrency(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Currency, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Currency)
	err := c.cc.Invoke(ctx, AccountMgr_ReadCurrency_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) AutoSyncCurrency(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, AccountMgr_AutoSyncCurrency_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListShopAddresses(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Addresses, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Addresses)
	err := c.cc.Invoke(ctx, AccountMgr_ListShopAddresses_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) CreateShopAddress(ctx context.Context, in *Address, opts ...grpc.CallOption) (*Address, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Address)
	err := c.cc.Invoke(ctx, AccountMgr_CreateShopAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) UpdateShopAddress(ctx context.Context, in *Address, opts ...grpc.CallOption) (*Address, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Address)
	err := c.cc.Invoke(ctx, AccountMgr_UpdateShopAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) DeleteShopAddress(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, AccountMgr_DeleteShopAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListTaxes(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_ListTaxes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) CreateTax(ctx context.Context, in *Tax, opts ...grpc.CallOption) (*Tax, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Tax)
	err := c.cc.Invoke(ctx, AccountMgr_CreateTax_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) UpdateTax(ctx context.Context, in *Tax, opts ...grpc.CallOption) (*Tax, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Tax)
	err := c.cc.Invoke(ctx, AccountMgr_UpdateTax_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) DeleteTax(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, AccountMgr_DeleteTax_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) CheckShippingPolicy(ctx context.Context, in *Order, opts ...grpc.CallOption) (*ShippingPolicies, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShippingPolicies)
	err := c.cc.Invoke(ctx, AccountMgr_CheckShippingPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListShippingPolicies(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ShippingPolicies, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShippingPolicies)
	err := c.cc.Invoke(ctx, AccountMgr_ListShippingPolicies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) CreateShippingPolicy(ctx context.Context, in *ShippingPolicy, opts ...grpc.CallOption) (*ShippingPolicy, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShippingPolicy)
	err := c.cc.Invoke(ctx, AccountMgr_CreateShippingPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) UpdateShippingPolicy(ctx context.Context, in *ShippingPolicy, opts ...grpc.CallOption) (*ShippingPolicy, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShippingPolicy)
	err := c.cc.Invoke(ctx, AccountMgr_UpdateShippingPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) DeleteShippingPolicy(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, AccountMgr_DeleteShippingPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) CreateCancellationCode(ctx context.Context, in *CancellationCode, opts ...grpc.CallOption) (*CancellationCode, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancellationCode)
	err := c.cc.Invoke(ctx, AccountMgr_CreateCancellationCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListCancellationCodes(ctx context.Context, in *Id, opts ...grpc.CallOption) (*CancellationCodes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancellationCodes)
	err := c.cc.Invoke(ctx, AccountMgr_ListCancellationCodes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) UpdateCancellationCode(ctx context.Context, in *CancellationCode, opts ...grpc.CallOption) (*CancellationCode, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancellationCode)
	err := c.cc.Invoke(ctx, AccountMgr_UpdateCancellationCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) MakeDefaultTax(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, AccountMgr_MakeDefaultTax_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListPaymentMethods(ctx context.Context, in *Id, opts ...grpc.CallOption) (*PaymentMethods, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PaymentMethods)
	err := c.cc.Invoke(ctx, AccountMgr_ListPaymentMethods_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) CreatePaymentMethod(ctx context.Context, in *PaymentMethod, opts ...grpc.CallOption) (*PaymentMethod, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PaymentMethod)
	err := c.cc.Invoke(ctx, AccountMgr_CreatePaymentMethod_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) UpdatePaymentMethod(ctx context.Context, in *PaymentMethod, opts ...grpc.CallOption) (*PaymentMethod, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PaymentMethod)
	err := c.cc.Invoke(ctx, AccountMgr_UpdatePaymentMethod_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) DeletePaymentMethod(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, AccountMgr_DeletePaymentMethod_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) MakeDefaultPaymentMethod(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, AccountMgr_MakeDefaultPaymentMethod_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListSubizPaymentMethods(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_ListSubizPaymentMethods_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) UpdateSubizPaymentMethod(ctx context.Context, in *SubizPaymentMethod, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_UpdateSubizPaymentMethod_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) DeleteSubizPaymentMethod(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, AccountMgr_DeleteSubizPaymentMethod_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) MakeDefaultSubizPaymentMethod(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, AccountMgr_MakeDefaultSubizPaymentMethod_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListIntegratedShippingProviders(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*IntegratedShippings, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntegratedShippings)
	err := c.cc.Invoke(ctx, AccountMgr_ListIntegratedShippingProviders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) DeintegrateShippingProvider(ctx context.Context, in *IntegratedShipping, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, AccountMgr_DeintegrateShippingProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) IntegrateShippingProvider(ctx context.Context, in *IntegratedShipping, opts ...grpc.CallOption) (*IntegratedShipping, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntegratedShipping)
	err := c.cc.Invoke(ctx, AccountMgr_IntegrateShippingProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) SendGHNAffiliateOTP(ctx context.Context, in *IntegratedShipping, opts ...grpc.CallOption) (*IntegratedShipping, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntegratedShipping)
	err := c.cc.Invoke(ctx, AccountMgr_SendGHNAffiliateOTP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) EnterGHNAffiliateOTP(ctx context.Context, in *IntegratedShipping, opts ...grpc.CallOption) (*IntegratedShipping, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntegratedShipping)
	err := c.cc.Invoke(ctx, AccountMgr_EnterGHNAffiliateOTP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) UpdateAgentPresence(ctx context.Context, in *account.Presence, opts ...grpc.CallOption) (*account.Presence, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.Presence)
	err := c.cc.Invoke(ctx, AccountMgr_UpdateAgentPresence_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListAgentPresences(ctx context.Context, in *Id, opts ...grpc.CallOption) (*account.Presences, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.Presences)
	err := c.cc.Invoke(ctx, AccountMgr_ListAgentPresences_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListAgentOnlines(ctx context.Context, in *ListAgentOnlineRequest, opts ...grpc.CallOption) (*account.Presences, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(account.Presences)
	err := c.cc.Invoke(ctx, AccountMgr_ListAgentOnlines_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ReportAvailibilities(ctx context.Context, in *AvailibilityReportRequest, opts ...grpc.CallOption) (*ReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportResponse)
	err := c.cc.Invoke(ctx, AccountMgr_ReportAvailibilities_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) NewID(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Id)
	err := c.cc.Invoke(ctx, AccountMgr_NewID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) LockLogin(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Id)
	err := c.cc.Invoke(ctx, AccountMgr_LockLogin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) UnlockLogin(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Id)
	err := c.cc.Invoke(ctx, AccountMgr_UnlockLogin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListBills(ctx context.Context, in *Id, opts ...grpc.CallOption) (*payment.Bills, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(payment.Bills)
	err := c.cc.Invoke(ctx, AccountMgr_ListBills_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListPromotionPrograms(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_ListPromotionPrograms_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListPromotionCodesOfProgram(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_ListPromotionCodesOfProgram_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListPromotionCodesOfAgent(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_ListPromotionCodesOfAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) UpsertPromotionCode(ctx context.Context, in *PromotionCode, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_UpsertPromotionCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) CheckPromotionCode(ctx context.Context, in *payment.Invoice, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_CheckPromotionCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) GetPromotionCode(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_GetPromotionCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) DeletePromotionCode(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_DeletePromotionCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) RedeemPromotionCode(ctx context.Context, in *RedeemRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_RedeemPromotionCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListPromotionProgramInvoices(ctx context.Context, in *Id, opts ...grpc.CallOption) (*PromotionCodeUsage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PromotionCodeUsage)
	err := c.cc.Invoke(ctx, AccountMgr_ListPromotionProgramInvoices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) CreateStripeCheckoutSession(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Id)
	err := c.cc.Invoke(ctx, AccountMgr_CreateStripeCheckoutSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) OnStripeEvent(ctx context.Context, in *StripeWebhookEvent, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, AccountMgr_OnStripeEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) LookupStripePaymentMethod(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_LookupStripePaymentMethod_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) DiffSubscription(ctx context.Context, in *payment.DiffSubRequest, opts ...grpc.CallOption) (*payment.Invoice, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(payment.Invoice)
	err := c.cc.Invoke(ctx, AccountMgr_DiffSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) AddBankAccount(ctx context.Context, in *BankAccount, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_AddBankAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) UpdateBankAccount(ctx context.Context, in *BankAccount, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_UpdateBankAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) DeleteBankAccount(ctx context.Context, in *BankAccount, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_DeleteBankAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListBankAccounts(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_ListBankAccounts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) VerifyBankAccount(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_VerifyBankAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) GenerateBankTransferRequest(ctx context.Context, in *BankTransferRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_GenerateBankTransferRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) GenerateQrCodeRequest(ctx context.Context, in *GenQrCodeRequest, opts ...grpc.CallOption) (*QrCode, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QrCode)
	err := c.cc.Invoke(ctx, AccountMgr_GenerateQrCodeRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) GetSetupFeatureStatus(ctx context.Context, in *Id, opts ...grpc.CallOption) (*SetupFeatureStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetupFeatureStatus)
	err := c.cc.Invoke(ctx, AccountMgr_GetSetupFeatureStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) UpdateSetupFeatureStatus(ctx context.Context, in *SetupFeatureStatus, opts ...grpc.CallOption) (*SetupFeatureStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetupFeatureStatus)
	err := c.cc.Invoke(ctx, AccountMgr_UpdateSetupFeatureStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListActiveAccountIds(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AccountMgr_ListActiveAccountIds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccountMgrServer is the server API for AccountMgr service.
// All implementations must embed UnimplementedAccountMgrServer
// for forward compatibility.
type AccountMgrServer interface {
	InviteEmails(context.Context, *InviteRequest) (*Empty, error)
	GetInviteLink(context.Context, *Id) (*Id, error)
	RegenerateInviteLink(context.Context, *Id) (*Id, error)
	CheckInviteLink(context.Context, *Id) (*InvitationLink, error)
	JoinAccount(context.Context, *JoinAccountRequest) (*Response, error)
	RequestOTP(context.Context, *Id) (*Empty, error)
	LoginUsingOTP(context.Context, *LoginRequest) (*Response, error)
	CheckEmailUsed(context.Context, *Id) (*Response, error)
	UpdateAgentProfile(context.Context, *AgentProfile) (*Response, error)
	GetAgentProfile(context.Context, *Id) (*Response, error)
	ListAgentProfileAccounts(context.Context, *Id) (*Response, error)
	Login(context.Context, *LoginRequest) (*Response, error)
	OldLogin(context.Context, *LoginRequest) (*Response, error)
	CreateGroup(context.Context, *AgentGroup) (*AgentGroup, error)
	UpdateGroup(context.Context, *AgentGroup) (*AgentGroup, error)
	GetGroup(context.Context, *Id) (*AgentGroup, error)
	UpdatePassword(context.Context, *NewPassword) (*account.Agent, error)
	UpdateAgent(context.Context, *account.Agent) (*account.Agent, error)
	DeleteAgent(context.Context, *Id) (*account.Agent, error)
	DeleteAccount(context.Context, *Id) (*account.Account, error)
	SubizUpdateAccount(context.Context, *account.Account) (*account.Account, error)
	CreateAgent(context.Context, *CreateAgentRequest) (*account.Agent, error)
	GetAgent(context.Context, *Id) (*account.Agent, error)
	LookupAgentById(context.Context, *Id) (*account.Agent, error)
	GetAccount(context.Context, *Id) (*account.Account, error)
	UpdateAccount(context.Context, *account.Account) (*account.Account, error)
	CreateAccount(context.Context, *CreateAccountRequest) (*account.Account, error)
	ListAgents(context.Context, *Id) (*Response, error)
	MatchAgent(context.Context, *Ids) (*Response, error)
	DeleteGroup(context.Context, *Id) (*Empty, error)
	ListGroups(context.Context, *Id) (*AgentGroups, error)
	ListGroups2(context.Context, *Id) (*Response, error)
	MatchGroup(context.Context, *Ids) (*Response, error)
	SbzChangeEmail(context.Context, *AgentProfile) (*AgentProfile, error)
	SyncPublicHolidays(context.Context, *account.SyncPublicHolidaysRequest) (*account.BusinessHours, error)
	TransferOwner(context.Context, *Id) (*account.Agent, error)
	CheckLoginSession(context.Context, *LoginSession) (*LoginSession, error)
	CreateLoginSession(context.Context, *Id) (*LoginSession, error)
	ListLoginSessions(context.Context, *Id) (*LoginSessions, error)
	ListApiKeys(context.Context, *Id) (*LoginSessions, error)
	LogoutSession(context.Context, *Id) (*Empty, error)
	CreateApiKey(context.Context, *LoginSession) (*LoginSession, error)
	GetLanguage(context.Context, *Id) (*Lang, error)
	UpdateLanguage(context.Context, *LangMessage) (*LangMessage, error)
	GetShopSetting(context.Context, *Id) (*ShopSetting, error)
	UpdateShopSetting(context.Context, *ShopSetting) (*ShopSetting, error)
	RefetchShopAddress(context.Context, *Id) (*Response, error)
	ReadCurrency(context.Context, *Id) (*Currency, error)
	// internal
	AutoSyncCurrency(context.Context, *Id) (*Empty, error)
	ListShopAddresses(context.Context, *Id) (*Addresses, error)
	CreateShopAddress(context.Context, *Address) (*Address, error)
	UpdateShopAddress(context.Context, *Address) (*Address, error)
	DeleteShopAddress(context.Context, *Id) (*Empty, error)
	ListTaxes(context.Context, *Id) (*Response, error)
	CreateTax(context.Context, *Tax) (*Tax, error)
	UpdateTax(context.Context, *Tax) (*Tax, error)
	DeleteTax(context.Context, *Id) (*Empty, error)
	CheckShippingPolicy(context.Context, *Order) (*ShippingPolicies, error)
	ListShippingPolicies(context.Context, *Id) (*ShippingPolicies, error)
	CreateShippingPolicy(context.Context, *ShippingPolicy) (*ShippingPolicy, error)
	UpdateShippingPolicy(context.Context, *ShippingPolicy) (*ShippingPolicy, error)
	DeleteShippingPolicy(context.Context, *Id) (*Empty, error)
	CreateCancellationCode(context.Context, *CancellationCode) (*CancellationCode, error)
	ListCancellationCodes(context.Context, *Id) (*CancellationCodes, error)
	UpdateCancellationCode(context.Context, *CancellationCode) (*CancellationCode, error)
	MakeDefaultTax(context.Context, *Id) (*Empty, error)
	ListPaymentMethods(context.Context, *Id) (*PaymentMethods, error)
	CreatePaymentMethod(context.Context, *PaymentMethod) (*PaymentMethod, error)
	UpdatePaymentMethod(context.Context, *PaymentMethod) (*PaymentMethod, error)
	DeletePaymentMethod(context.Context, *Id) (*Empty, error)
	MakeDefaultPaymentMethod(context.Context, *Id) (*Empty, error)
	ListSubizPaymentMethods(context.Context, *Id) (*Response, error)
	UpdateSubizPaymentMethod(context.Context, *SubizPaymentMethod) (*Response, error)
	DeleteSubizPaymentMethod(context.Context, *Id) (*Empty, error)
	MakeDefaultSubizPaymentMethod(context.Context, *Id) (*Empty, error)
	ListIntegratedShippingProviders(context.Context, *Ids) (*IntegratedShippings, error)
	DeintegrateShippingProvider(context.Context, *IntegratedShipping) (*Empty, error)
	IntegrateShippingProvider(context.Context, *IntegratedShipping) (*IntegratedShipping, error)
	SendGHNAffiliateOTP(context.Context, *IntegratedShipping) (*IntegratedShipping, error)
	EnterGHNAffiliateOTP(context.Context, *IntegratedShipping) (*IntegratedShipping, error)
	UpdateAgentPresence(context.Context, *account.Presence) (*account.Presence, error)
	ListAgentPresences(context.Context, *Id) (*account.Presences, error)
	ListAgentOnlines(context.Context, *ListAgentOnlineRequest) (*account.Presences, error)
	ReportAvailibilities(context.Context, *AvailibilityReportRequest) (*ReportResponse, error)
	NewID(context.Context, *Id) (*Id, error)
	LockLogin(context.Context, *Id) (*Id, error)
	UnlockLogin(context.Context, *Id) (*Id, error)
	ListBills(context.Context, *Id) (*payment.Bills, error)
	// promotion code
	ListPromotionPrograms(context.Context, *Id) (*Response, error)
	ListPromotionCodesOfProgram(context.Context, *Id) (*Response, error)
	ListPromotionCodesOfAgent(context.Context, *Id) (*Response, error)
	UpsertPromotionCode(context.Context, *PromotionCode) (*Response, error)
	CheckPromotionCode(context.Context, *payment.Invoice) (*Response, error)
	GetPromotionCode(context.Context, *Id) (*Response, error)
	DeletePromotionCode(context.Context, *Id) (*Response, error)
	RedeemPromotionCode(context.Context, *RedeemRequest) (*Response, error)
	ListPromotionProgramInvoices(context.Context, *Id) (*PromotionCodeUsage, error)
	CreateStripeCheckoutSession(context.Context, *Id) (*Id, error)
	OnStripeEvent(context.Context, *StripeWebhookEvent) (*Empty, error)
	LookupStripePaymentMethod(context.Context, *Id) (*Response, error)
	DiffSubscription(context.Context, *payment.DiffSubRequest) (*payment.Invoice, error)
	AddBankAccount(context.Context, *BankAccount) (*Response, error)
	UpdateBankAccount(context.Context, *BankAccount) (*Response, error)
	DeleteBankAccount(context.Context, *BankAccount) (*Response, error)
	ListBankAccounts(context.Context, *Id) (*Response, error)
	VerifyBankAccount(context.Context, *Id) (*Response, error)
	GenerateBankTransferRequest(context.Context, *BankTransferRequest) (*Response, error)
	GenerateQrCodeRequest(context.Context, *GenQrCodeRequest) (*QrCode, error)
	GetSetupFeatureStatus(context.Context, *Id) (*SetupFeatureStatus, error)
	UpdateSetupFeatureStatus(context.Context, *SetupFeatureStatus) (*SetupFeatureStatus, error)
	ListActiveAccountIds(context.Context, *Id) (*Response, error)
	mustEmbedUnimplementedAccountMgrServer()
}

// UnimplementedAccountMgrServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAccountMgrServer struct{}

func (UnimplementedAccountMgrServer) InviteEmails(context.Context, *InviteRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InviteEmails not implemented")
}
func (UnimplementedAccountMgrServer) GetInviteLink(context.Context, *Id) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInviteLink not implemented")
}
func (UnimplementedAccountMgrServer) RegenerateInviteLink(context.Context, *Id) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegenerateInviteLink not implemented")
}
func (UnimplementedAccountMgrServer) CheckInviteLink(context.Context, *Id) (*InvitationLink, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckInviteLink not implemented")
}
func (UnimplementedAccountMgrServer) JoinAccount(context.Context, *JoinAccountRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinAccount not implemented")
}
func (UnimplementedAccountMgrServer) RequestOTP(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestOTP not implemented")
}
func (UnimplementedAccountMgrServer) LoginUsingOTP(context.Context, *LoginRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginUsingOTP not implemented")
}
func (UnimplementedAccountMgrServer) CheckEmailUsed(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckEmailUsed not implemented")
}
func (UnimplementedAccountMgrServer) UpdateAgentProfile(context.Context, *AgentProfile) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAgentProfile not implemented")
}
func (UnimplementedAccountMgrServer) GetAgentProfile(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAgentProfile not implemented")
}
func (UnimplementedAccountMgrServer) ListAgentProfileAccounts(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAgentProfileAccounts not implemented")
}
func (UnimplementedAccountMgrServer) Login(context.Context, *LoginRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedAccountMgrServer) OldLogin(context.Context, *LoginRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OldLogin not implemented")
}
func (UnimplementedAccountMgrServer) CreateGroup(context.Context, *AgentGroup) (*AgentGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateGroup not implemented")
}
func (UnimplementedAccountMgrServer) UpdateGroup(context.Context, *AgentGroup) (*AgentGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGroup not implemented")
}
func (UnimplementedAccountMgrServer) GetGroup(context.Context, *Id) (*AgentGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGroup not implemented")
}
func (UnimplementedAccountMgrServer) UpdatePassword(context.Context, *NewPassword) (*account.Agent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePassword not implemented")
}
func (UnimplementedAccountMgrServer) UpdateAgent(context.Context, *account.Agent) (*account.Agent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAgent not implemented")
}
func (UnimplementedAccountMgrServer) DeleteAgent(context.Context, *Id) (*account.Agent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAgent not implemented")
}
func (UnimplementedAccountMgrServer) DeleteAccount(context.Context, *Id) (*account.Account, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAccount not implemented")
}
func (UnimplementedAccountMgrServer) SubizUpdateAccount(context.Context, *account.Account) (*account.Account, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubizUpdateAccount not implemented")
}
func (UnimplementedAccountMgrServer) CreateAgent(context.Context, *CreateAgentRequest) (*account.Agent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAgent not implemented")
}
func (UnimplementedAccountMgrServer) GetAgent(context.Context, *Id) (*account.Agent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAgent not implemented")
}
func (UnimplementedAccountMgrServer) LookupAgentById(context.Context, *Id) (*account.Agent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LookupAgentById not implemented")
}
func (UnimplementedAccountMgrServer) GetAccount(context.Context, *Id) (*account.Account, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccount not implemented")
}
func (UnimplementedAccountMgrServer) UpdateAccount(context.Context, *account.Account) (*account.Account, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAccount not implemented")
}
func (UnimplementedAccountMgrServer) CreateAccount(context.Context, *CreateAccountRequest) (*account.Account, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAccount not implemented")
}
func (UnimplementedAccountMgrServer) ListAgents(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAgents not implemented")
}
func (UnimplementedAccountMgrServer) MatchAgent(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchAgent not implemented")
}
func (UnimplementedAccountMgrServer) DeleteGroup(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGroup not implemented")
}
func (UnimplementedAccountMgrServer) ListGroups(context.Context, *Id) (*AgentGroups, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGroups not implemented")
}
func (UnimplementedAccountMgrServer) ListGroups2(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGroups2 not implemented")
}
func (UnimplementedAccountMgrServer) MatchGroup(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchGroup not implemented")
}
func (UnimplementedAccountMgrServer) SbzChangeEmail(context.Context, *AgentProfile) (*AgentProfile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SbzChangeEmail not implemented")
}
func (UnimplementedAccountMgrServer) SyncPublicHolidays(context.Context, *account.SyncPublicHolidaysRequest) (*account.BusinessHours, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncPublicHolidays not implemented")
}
func (UnimplementedAccountMgrServer) TransferOwner(context.Context, *Id) (*account.Agent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferOwner not implemented")
}
func (UnimplementedAccountMgrServer) CheckLoginSession(context.Context, *LoginSession) (*LoginSession, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckLoginSession not implemented")
}
func (UnimplementedAccountMgrServer) CreateLoginSession(context.Context, *Id) (*LoginSession, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLoginSession not implemented")
}
func (UnimplementedAccountMgrServer) ListLoginSessions(context.Context, *Id) (*LoginSessions, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLoginSessions not implemented")
}
func (UnimplementedAccountMgrServer) ListApiKeys(context.Context, *Id) (*LoginSessions, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListApiKeys not implemented")
}
func (UnimplementedAccountMgrServer) LogoutSession(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogoutSession not implemented")
}
func (UnimplementedAccountMgrServer) CreateApiKey(context.Context, *LoginSession) (*LoginSession, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateApiKey not implemented")
}
func (UnimplementedAccountMgrServer) GetLanguage(context.Context, *Id) (*Lang, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLanguage not implemented")
}
func (UnimplementedAccountMgrServer) UpdateLanguage(context.Context, *LangMessage) (*LangMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLanguage not implemented")
}
func (UnimplementedAccountMgrServer) GetShopSetting(context.Context, *Id) (*ShopSetting, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetShopSetting not implemented")
}
func (UnimplementedAccountMgrServer) UpdateShopSetting(context.Context, *ShopSetting) (*ShopSetting, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateShopSetting not implemented")
}
func (UnimplementedAccountMgrServer) RefetchShopAddress(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefetchShopAddress not implemented")
}
func (UnimplementedAccountMgrServer) ReadCurrency(context.Context, *Id) (*Currency, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadCurrency not implemented")
}
func (UnimplementedAccountMgrServer) AutoSyncCurrency(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AutoSyncCurrency not implemented")
}
func (UnimplementedAccountMgrServer) ListShopAddresses(context.Context, *Id) (*Addresses, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListShopAddresses not implemented")
}
func (UnimplementedAccountMgrServer) CreateShopAddress(context.Context, *Address) (*Address, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateShopAddress not implemented")
}
func (UnimplementedAccountMgrServer) UpdateShopAddress(context.Context, *Address) (*Address, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateShopAddress not implemented")
}
func (UnimplementedAccountMgrServer) DeleteShopAddress(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteShopAddress not implemented")
}
func (UnimplementedAccountMgrServer) ListTaxes(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTaxes not implemented")
}
func (UnimplementedAccountMgrServer) CreateTax(context.Context, *Tax) (*Tax, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTax not implemented")
}
func (UnimplementedAccountMgrServer) UpdateTax(context.Context, *Tax) (*Tax, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTax not implemented")
}
func (UnimplementedAccountMgrServer) DeleteTax(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTax not implemented")
}
func (UnimplementedAccountMgrServer) CheckShippingPolicy(context.Context, *Order) (*ShippingPolicies, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckShippingPolicy not implemented")
}
func (UnimplementedAccountMgrServer) ListShippingPolicies(context.Context, *Id) (*ShippingPolicies, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListShippingPolicies not implemented")
}
func (UnimplementedAccountMgrServer) CreateShippingPolicy(context.Context, *ShippingPolicy) (*ShippingPolicy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateShippingPolicy not implemented")
}
func (UnimplementedAccountMgrServer) UpdateShippingPolicy(context.Context, *ShippingPolicy) (*ShippingPolicy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateShippingPolicy not implemented")
}
func (UnimplementedAccountMgrServer) DeleteShippingPolicy(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteShippingPolicy not implemented")
}
func (UnimplementedAccountMgrServer) CreateCancellationCode(context.Context, *CancellationCode) (*CancellationCode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCancellationCode not implemented")
}
func (UnimplementedAccountMgrServer) ListCancellationCodes(context.Context, *Id) (*CancellationCodes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCancellationCodes not implemented")
}
func (UnimplementedAccountMgrServer) UpdateCancellationCode(context.Context, *CancellationCode) (*CancellationCode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCancellationCode not implemented")
}
func (UnimplementedAccountMgrServer) MakeDefaultTax(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MakeDefaultTax not implemented")
}
func (UnimplementedAccountMgrServer) ListPaymentMethods(context.Context, *Id) (*PaymentMethods, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPaymentMethods not implemented")
}
func (UnimplementedAccountMgrServer) CreatePaymentMethod(context.Context, *PaymentMethod) (*PaymentMethod, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePaymentMethod not implemented")
}
func (UnimplementedAccountMgrServer) UpdatePaymentMethod(context.Context, *PaymentMethod) (*PaymentMethod, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePaymentMethod not implemented")
}
func (UnimplementedAccountMgrServer) DeletePaymentMethod(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePaymentMethod not implemented")
}
func (UnimplementedAccountMgrServer) MakeDefaultPaymentMethod(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MakeDefaultPaymentMethod not implemented")
}
func (UnimplementedAccountMgrServer) ListSubizPaymentMethods(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSubizPaymentMethods not implemented")
}
func (UnimplementedAccountMgrServer) UpdateSubizPaymentMethod(context.Context, *SubizPaymentMethod) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSubizPaymentMethod not implemented")
}
func (UnimplementedAccountMgrServer) DeleteSubizPaymentMethod(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSubizPaymentMethod not implemented")
}
func (UnimplementedAccountMgrServer) MakeDefaultSubizPaymentMethod(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MakeDefaultSubizPaymentMethod not implemented")
}
func (UnimplementedAccountMgrServer) ListIntegratedShippingProviders(context.Context, *Ids) (*IntegratedShippings, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListIntegratedShippingProviders not implemented")
}
func (UnimplementedAccountMgrServer) DeintegrateShippingProvider(context.Context, *IntegratedShipping) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeintegrateShippingProvider not implemented")
}
func (UnimplementedAccountMgrServer) IntegrateShippingProvider(context.Context, *IntegratedShipping) (*IntegratedShipping, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IntegrateShippingProvider not implemented")
}
func (UnimplementedAccountMgrServer) SendGHNAffiliateOTP(context.Context, *IntegratedShipping) (*IntegratedShipping, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendGHNAffiliateOTP not implemented")
}
func (UnimplementedAccountMgrServer) EnterGHNAffiliateOTP(context.Context, *IntegratedShipping) (*IntegratedShipping, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnterGHNAffiliateOTP not implemented")
}
func (UnimplementedAccountMgrServer) UpdateAgentPresence(context.Context, *account.Presence) (*account.Presence, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAgentPresence not implemented")
}
func (UnimplementedAccountMgrServer) ListAgentPresences(context.Context, *Id) (*account.Presences, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAgentPresences not implemented")
}
func (UnimplementedAccountMgrServer) ListAgentOnlines(context.Context, *ListAgentOnlineRequest) (*account.Presences, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAgentOnlines not implemented")
}
func (UnimplementedAccountMgrServer) ReportAvailibilities(context.Context, *AvailibilityReportRequest) (*ReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportAvailibilities not implemented")
}
func (UnimplementedAccountMgrServer) NewID(context.Context, *Id) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewID not implemented")
}
func (UnimplementedAccountMgrServer) LockLogin(context.Context, *Id) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LockLogin not implemented")
}
func (UnimplementedAccountMgrServer) UnlockLogin(context.Context, *Id) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlockLogin not implemented")
}
func (UnimplementedAccountMgrServer) ListBills(context.Context, *Id) (*payment.Bills, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBills not implemented")
}
func (UnimplementedAccountMgrServer) ListPromotionPrograms(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPromotionPrograms not implemented")
}
func (UnimplementedAccountMgrServer) ListPromotionCodesOfProgram(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPromotionCodesOfProgram not implemented")
}
func (UnimplementedAccountMgrServer) ListPromotionCodesOfAgent(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPromotionCodesOfAgent not implemented")
}
func (UnimplementedAccountMgrServer) UpsertPromotionCode(context.Context, *PromotionCode) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertPromotionCode not implemented")
}
func (UnimplementedAccountMgrServer) CheckPromotionCode(context.Context, *payment.Invoice) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckPromotionCode not implemented")
}
func (UnimplementedAccountMgrServer) GetPromotionCode(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPromotionCode not implemented")
}
func (UnimplementedAccountMgrServer) DeletePromotionCode(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePromotionCode not implemented")
}
func (UnimplementedAccountMgrServer) RedeemPromotionCode(context.Context, *RedeemRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RedeemPromotionCode not implemented")
}
func (UnimplementedAccountMgrServer) ListPromotionProgramInvoices(context.Context, *Id) (*PromotionCodeUsage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPromotionProgramInvoices not implemented")
}
func (UnimplementedAccountMgrServer) CreateStripeCheckoutSession(context.Context, *Id) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateStripeCheckoutSession not implemented")
}
func (UnimplementedAccountMgrServer) OnStripeEvent(context.Context, *StripeWebhookEvent) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnStripeEvent not implemented")
}
func (UnimplementedAccountMgrServer) LookupStripePaymentMethod(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LookupStripePaymentMethod not implemented")
}
func (UnimplementedAccountMgrServer) DiffSubscription(context.Context, *payment.DiffSubRequest) (*payment.Invoice, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DiffSubscription not implemented")
}
func (UnimplementedAccountMgrServer) AddBankAccount(context.Context, *BankAccount) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddBankAccount not implemented")
}
func (UnimplementedAccountMgrServer) UpdateBankAccount(context.Context, *BankAccount) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBankAccount not implemented")
}
func (UnimplementedAccountMgrServer) DeleteBankAccount(context.Context, *BankAccount) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBankAccount not implemented")
}
func (UnimplementedAccountMgrServer) ListBankAccounts(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBankAccounts not implemented")
}
func (UnimplementedAccountMgrServer) VerifyBankAccount(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyBankAccount not implemented")
}
func (UnimplementedAccountMgrServer) GenerateBankTransferRequest(context.Context, *BankTransferRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateBankTransferRequest not implemented")
}
func (UnimplementedAccountMgrServer) GenerateQrCodeRequest(context.Context, *GenQrCodeRequest) (*QrCode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateQrCodeRequest not implemented")
}
func (UnimplementedAccountMgrServer) GetSetupFeatureStatus(context.Context, *Id) (*SetupFeatureStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSetupFeatureStatus not implemented")
}
func (UnimplementedAccountMgrServer) UpdateSetupFeatureStatus(context.Context, *SetupFeatureStatus) (*SetupFeatureStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSetupFeatureStatus not implemented")
}
func (UnimplementedAccountMgrServer) ListActiveAccountIds(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListActiveAccountIds not implemented")
}
func (UnimplementedAccountMgrServer) mustEmbedUnimplementedAccountMgrServer() {}
func (UnimplementedAccountMgrServer) testEmbeddedByValue()                    {}

// UnsafeAccountMgrServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AccountMgrServer will
// result in compilation errors.
type UnsafeAccountMgrServer interface {
	mustEmbedUnimplementedAccountMgrServer()
}

func RegisterAccountMgrServer(s grpc.ServiceRegistrar, srv AccountMgrServer) {
	// If the following call pancis, it indicates UnimplementedAccountMgrServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AccountMgr_ServiceDesc, srv)
}

func _AccountMgr_InviteEmails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InviteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).InviteEmails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_InviteEmails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).InviteEmails(ctx, req.(*InviteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_GetInviteLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).GetInviteLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_GetInviteLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).GetInviteLink(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_RegenerateInviteLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).RegenerateInviteLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_RegenerateInviteLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).RegenerateInviteLink(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_CheckInviteLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).CheckInviteLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_CheckInviteLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).CheckInviteLink(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_JoinAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).JoinAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_JoinAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).JoinAccount(ctx, req.(*JoinAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_RequestOTP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).RequestOTP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_RequestOTP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).RequestOTP(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_LoginUsingOTP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).LoginUsingOTP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_LoginUsingOTP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).LoginUsingOTP(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_CheckEmailUsed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).CheckEmailUsed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_CheckEmailUsed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).CheckEmailUsed(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_UpdateAgentProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AgentProfile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).UpdateAgentProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_UpdateAgentProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).UpdateAgentProfile(ctx, req.(*AgentProfile))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_GetAgentProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).GetAgentProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_GetAgentProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).GetAgentProfile(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListAgentProfileAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListAgentProfileAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ListAgentProfileAccounts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListAgentProfileAccounts(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_OldLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).OldLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_OldLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).OldLogin(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_CreateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AgentGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).CreateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_CreateGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).CreateGroup(ctx, req.(*AgentGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_UpdateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AgentGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).UpdateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_UpdateGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).UpdateGroup(ctx, req.(*AgentGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_GetGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).GetGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_GetGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).GetGroup(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_UpdatePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewPassword)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).UpdatePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_UpdatePassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).UpdatePassword(ctx, req.(*NewPassword))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_UpdateAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.Agent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).UpdateAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_UpdateAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).UpdateAgent(ctx, req.(*account.Agent))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_DeleteAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).DeleteAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_DeleteAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).DeleteAgent(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_DeleteAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).DeleteAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_DeleteAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).DeleteAccount(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_SubizUpdateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.Account)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).SubizUpdateAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_SubizUpdateAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).SubizUpdateAccount(ctx, req.(*account.Account))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_CreateAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).CreateAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_CreateAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).CreateAgent(ctx, req.(*CreateAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_GetAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).GetAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_GetAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).GetAgent(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_LookupAgentById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).LookupAgentById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_LookupAgentById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).LookupAgentById(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_GetAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).GetAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_GetAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).GetAccount(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_UpdateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.Account)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).UpdateAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_UpdateAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).UpdateAccount(ctx, req.(*account.Account))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_CreateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).CreateAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_CreateAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).CreateAccount(ctx, req.(*CreateAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListAgents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListAgents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ListAgents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListAgents(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_MatchAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).MatchAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_MatchAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).MatchAgent(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_DeleteGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).DeleteGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_DeleteGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).DeleteGroup(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ListGroups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListGroups(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListGroups2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListGroups2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ListGroups2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListGroups2(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_MatchGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).MatchGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_MatchGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).MatchGroup(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_SbzChangeEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AgentProfile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).SbzChangeEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_SbzChangeEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).SbzChangeEmail(ctx, req.(*AgentProfile))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_SyncPublicHolidays_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.SyncPublicHolidaysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).SyncPublicHolidays(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_SyncPublicHolidays_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).SyncPublicHolidays(ctx, req.(*account.SyncPublicHolidaysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_TransferOwner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).TransferOwner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_TransferOwner_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).TransferOwner(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_CheckLoginSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginSession)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).CheckLoginSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_CheckLoginSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).CheckLoginSession(ctx, req.(*LoginSession))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_CreateLoginSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).CreateLoginSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_CreateLoginSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).CreateLoginSession(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListLoginSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListLoginSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ListLoginSessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListLoginSessions(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListApiKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListApiKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ListApiKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListApiKeys(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_LogoutSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).LogoutSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_LogoutSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).LogoutSession(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_CreateApiKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginSession)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).CreateApiKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_CreateApiKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).CreateApiKey(ctx, req.(*LoginSession))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_GetLanguage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).GetLanguage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_GetLanguage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).GetLanguage(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_UpdateLanguage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LangMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).UpdateLanguage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_UpdateLanguage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).UpdateLanguage(ctx, req.(*LangMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_GetShopSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).GetShopSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_GetShopSetting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).GetShopSetting(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_UpdateShopSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShopSetting)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).UpdateShopSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_UpdateShopSetting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).UpdateShopSetting(ctx, req.(*ShopSetting))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_RefetchShopAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).RefetchShopAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_RefetchShopAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).RefetchShopAddress(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ReadCurrency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ReadCurrency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ReadCurrency_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ReadCurrency(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_AutoSyncCurrency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).AutoSyncCurrency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_AutoSyncCurrency_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).AutoSyncCurrency(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListShopAddresses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListShopAddresses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ListShopAddresses_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListShopAddresses(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_CreateShopAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Address)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).CreateShopAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_CreateShopAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).CreateShopAddress(ctx, req.(*Address))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_UpdateShopAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Address)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).UpdateShopAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_UpdateShopAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).UpdateShopAddress(ctx, req.(*Address))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_DeleteShopAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).DeleteShopAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_DeleteShopAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).DeleteShopAddress(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListTaxes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListTaxes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ListTaxes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListTaxes(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_CreateTax_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Tax)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).CreateTax(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_CreateTax_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).CreateTax(ctx, req.(*Tax))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_UpdateTax_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Tax)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).UpdateTax(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_UpdateTax_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).UpdateTax(ctx, req.(*Tax))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_DeleteTax_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).DeleteTax(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_DeleteTax_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).DeleteTax(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_CheckShippingPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Order)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).CheckShippingPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_CheckShippingPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).CheckShippingPolicy(ctx, req.(*Order))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListShippingPolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListShippingPolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ListShippingPolicies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListShippingPolicies(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_CreateShippingPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShippingPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).CreateShippingPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_CreateShippingPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).CreateShippingPolicy(ctx, req.(*ShippingPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_UpdateShippingPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShippingPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).UpdateShippingPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_UpdateShippingPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).UpdateShippingPolicy(ctx, req.(*ShippingPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_DeleteShippingPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).DeleteShippingPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_DeleteShippingPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).DeleteShippingPolicy(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_CreateCancellationCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancellationCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).CreateCancellationCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_CreateCancellationCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).CreateCancellationCode(ctx, req.(*CancellationCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListCancellationCodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListCancellationCodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ListCancellationCodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListCancellationCodes(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_UpdateCancellationCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancellationCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).UpdateCancellationCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_UpdateCancellationCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).UpdateCancellationCode(ctx, req.(*CancellationCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_MakeDefaultTax_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).MakeDefaultTax(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_MakeDefaultTax_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).MakeDefaultTax(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListPaymentMethods_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListPaymentMethods(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ListPaymentMethods_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListPaymentMethods(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_CreatePaymentMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PaymentMethod)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).CreatePaymentMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_CreatePaymentMethod_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).CreatePaymentMethod(ctx, req.(*PaymentMethod))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_UpdatePaymentMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PaymentMethod)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).UpdatePaymentMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_UpdatePaymentMethod_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).UpdatePaymentMethod(ctx, req.(*PaymentMethod))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_DeletePaymentMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).DeletePaymentMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_DeletePaymentMethod_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).DeletePaymentMethod(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_MakeDefaultPaymentMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).MakeDefaultPaymentMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_MakeDefaultPaymentMethod_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).MakeDefaultPaymentMethod(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListSubizPaymentMethods_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListSubizPaymentMethods(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ListSubizPaymentMethods_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListSubizPaymentMethods(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_UpdateSubizPaymentMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubizPaymentMethod)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).UpdateSubizPaymentMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_UpdateSubizPaymentMethod_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).UpdateSubizPaymentMethod(ctx, req.(*SubizPaymentMethod))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_DeleteSubizPaymentMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).DeleteSubizPaymentMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_DeleteSubizPaymentMethod_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).DeleteSubizPaymentMethod(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_MakeDefaultSubizPaymentMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).MakeDefaultSubizPaymentMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_MakeDefaultSubizPaymentMethod_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).MakeDefaultSubizPaymentMethod(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListIntegratedShippingProviders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListIntegratedShippingProviders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ListIntegratedShippingProviders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListIntegratedShippingProviders(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_DeintegrateShippingProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntegratedShipping)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).DeintegrateShippingProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_DeintegrateShippingProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).DeintegrateShippingProvider(ctx, req.(*IntegratedShipping))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_IntegrateShippingProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntegratedShipping)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).IntegrateShippingProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_IntegrateShippingProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).IntegrateShippingProvider(ctx, req.(*IntegratedShipping))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_SendGHNAffiliateOTP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntegratedShipping)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).SendGHNAffiliateOTP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_SendGHNAffiliateOTP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).SendGHNAffiliateOTP(ctx, req.(*IntegratedShipping))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_EnterGHNAffiliateOTP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntegratedShipping)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).EnterGHNAffiliateOTP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_EnterGHNAffiliateOTP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).EnterGHNAffiliateOTP(ctx, req.(*IntegratedShipping))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_UpdateAgentPresence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.Presence)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).UpdateAgentPresence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_UpdateAgentPresence_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).UpdateAgentPresence(ctx, req.(*account.Presence))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListAgentPresences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListAgentPresences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ListAgentPresences_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListAgentPresences(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListAgentOnlines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAgentOnlineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListAgentOnlines(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ListAgentOnlines_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListAgentOnlines(ctx, req.(*ListAgentOnlineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ReportAvailibilities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AvailibilityReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ReportAvailibilities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ReportAvailibilities_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ReportAvailibilities(ctx, req.(*AvailibilityReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_NewID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).NewID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_NewID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).NewID(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_LockLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).LockLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_LockLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).LockLogin(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_UnlockLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).UnlockLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_UnlockLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).UnlockLogin(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListBills_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListBills(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ListBills_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListBills(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListPromotionPrograms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListPromotionPrograms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ListPromotionPrograms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListPromotionPrograms(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListPromotionCodesOfProgram_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListPromotionCodesOfProgram(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ListPromotionCodesOfProgram_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListPromotionCodesOfProgram(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListPromotionCodesOfAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListPromotionCodesOfAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ListPromotionCodesOfAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListPromotionCodesOfAgent(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_UpsertPromotionCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PromotionCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).UpsertPromotionCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_UpsertPromotionCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).UpsertPromotionCode(ctx, req.(*PromotionCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_CheckPromotionCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.Invoice)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).CheckPromotionCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_CheckPromotionCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).CheckPromotionCode(ctx, req.(*payment.Invoice))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_GetPromotionCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).GetPromotionCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_GetPromotionCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).GetPromotionCode(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_DeletePromotionCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).DeletePromotionCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_DeletePromotionCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).DeletePromotionCode(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_RedeemPromotionCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RedeemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).RedeemPromotionCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_RedeemPromotionCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).RedeemPromotionCode(ctx, req.(*RedeemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListPromotionProgramInvoices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListPromotionProgramInvoices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ListPromotionProgramInvoices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListPromotionProgramInvoices(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_CreateStripeCheckoutSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).CreateStripeCheckoutSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_CreateStripeCheckoutSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).CreateStripeCheckoutSession(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_OnStripeEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StripeWebhookEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).OnStripeEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_OnStripeEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).OnStripeEvent(ctx, req.(*StripeWebhookEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_LookupStripePaymentMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).LookupStripePaymentMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_LookupStripePaymentMethod_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).LookupStripePaymentMethod(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_DiffSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.DiffSubRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).DiffSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_DiffSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).DiffSubscription(ctx, req.(*payment.DiffSubRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_AddBankAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BankAccount)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).AddBankAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_AddBankAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).AddBankAccount(ctx, req.(*BankAccount))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_UpdateBankAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BankAccount)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).UpdateBankAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_UpdateBankAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).UpdateBankAccount(ctx, req.(*BankAccount))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_DeleteBankAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BankAccount)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).DeleteBankAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_DeleteBankAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).DeleteBankAccount(ctx, req.(*BankAccount))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListBankAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListBankAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ListBankAccounts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListBankAccounts(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_VerifyBankAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).VerifyBankAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_VerifyBankAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).VerifyBankAccount(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_GenerateBankTransferRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BankTransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).GenerateBankTransferRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_GenerateBankTransferRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).GenerateBankTransferRequest(ctx, req.(*BankTransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_GenerateQrCodeRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenQrCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).GenerateQrCodeRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_GenerateQrCodeRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).GenerateQrCodeRequest(ctx, req.(*GenQrCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_GetSetupFeatureStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).GetSetupFeatureStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_GetSetupFeatureStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).GetSetupFeatureStatus(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_UpdateSetupFeatureStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetupFeatureStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).UpdateSetupFeatureStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_UpdateSetupFeatureStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).UpdateSetupFeatureStatus(ctx, req.(*SetupFeatureStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListActiveAccountIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListActiveAccountIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountMgr_ListActiveAccountIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListActiveAccountIds(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

// AccountMgr_ServiceDesc is the grpc.ServiceDesc for AccountMgr service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AccountMgr_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.AccountMgr",
	HandlerType: (*AccountMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InviteEmails",
			Handler:    _AccountMgr_InviteEmails_Handler,
		},
		{
			MethodName: "GetInviteLink",
			Handler:    _AccountMgr_GetInviteLink_Handler,
		},
		{
			MethodName: "RegenerateInviteLink",
			Handler:    _AccountMgr_RegenerateInviteLink_Handler,
		},
		{
			MethodName: "CheckInviteLink",
			Handler:    _AccountMgr_CheckInviteLink_Handler,
		},
		{
			MethodName: "JoinAccount",
			Handler:    _AccountMgr_JoinAccount_Handler,
		},
		{
			MethodName: "RequestOTP",
			Handler:    _AccountMgr_RequestOTP_Handler,
		},
		{
			MethodName: "LoginUsingOTP",
			Handler:    _AccountMgr_LoginUsingOTP_Handler,
		},
		{
			MethodName: "CheckEmailUsed",
			Handler:    _AccountMgr_CheckEmailUsed_Handler,
		},
		{
			MethodName: "UpdateAgentProfile",
			Handler:    _AccountMgr_UpdateAgentProfile_Handler,
		},
		{
			MethodName: "GetAgentProfile",
			Handler:    _AccountMgr_GetAgentProfile_Handler,
		},
		{
			MethodName: "ListAgentProfileAccounts",
			Handler:    _AccountMgr_ListAgentProfileAccounts_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _AccountMgr_Login_Handler,
		},
		{
			MethodName: "OldLogin",
			Handler:    _AccountMgr_OldLogin_Handler,
		},
		{
			MethodName: "CreateGroup",
			Handler:    _AccountMgr_CreateGroup_Handler,
		},
		{
			MethodName: "UpdateGroup",
			Handler:    _AccountMgr_UpdateGroup_Handler,
		},
		{
			MethodName: "GetGroup",
			Handler:    _AccountMgr_GetGroup_Handler,
		},
		{
			MethodName: "UpdatePassword",
			Handler:    _AccountMgr_UpdatePassword_Handler,
		},
		{
			MethodName: "UpdateAgent",
			Handler:    _AccountMgr_UpdateAgent_Handler,
		},
		{
			MethodName: "DeleteAgent",
			Handler:    _AccountMgr_DeleteAgent_Handler,
		},
		{
			MethodName: "DeleteAccount",
			Handler:    _AccountMgr_DeleteAccount_Handler,
		},
		{
			MethodName: "SubizUpdateAccount",
			Handler:    _AccountMgr_SubizUpdateAccount_Handler,
		},
		{
			MethodName: "CreateAgent",
			Handler:    _AccountMgr_CreateAgent_Handler,
		},
		{
			MethodName: "GetAgent",
			Handler:    _AccountMgr_GetAgent_Handler,
		},
		{
			MethodName: "LookupAgentById",
			Handler:    _AccountMgr_LookupAgentById_Handler,
		},
		{
			MethodName: "GetAccount",
			Handler:    _AccountMgr_GetAccount_Handler,
		},
		{
			MethodName: "UpdateAccount",
			Handler:    _AccountMgr_UpdateAccount_Handler,
		},
		{
			MethodName: "CreateAccount",
			Handler:    _AccountMgr_CreateAccount_Handler,
		},
		{
			MethodName: "ListAgents",
			Handler:    _AccountMgr_ListAgents_Handler,
		},
		{
			MethodName: "MatchAgent",
			Handler:    _AccountMgr_MatchAgent_Handler,
		},
		{
			MethodName: "DeleteGroup",
			Handler:    _AccountMgr_DeleteGroup_Handler,
		},
		{
			MethodName: "ListGroups",
			Handler:    _AccountMgr_ListGroups_Handler,
		},
		{
			MethodName: "ListGroups2",
			Handler:    _AccountMgr_ListGroups2_Handler,
		},
		{
			MethodName: "MatchGroup",
			Handler:    _AccountMgr_MatchGroup_Handler,
		},
		{
			MethodName: "SbzChangeEmail",
			Handler:    _AccountMgr_SbzChangeEmail_Handler,
		},
		{
			MethodName: "SyncPublicHolidays",
			Handler:    _AccountMgr_SyncPublicHolidays_Handler,
		},
		{
			MethodName: "TransferOwner",
			Handler:    _AccountMgr_TransferOwner_Handler,
		},
		{
			MethodName: "CheckLoginSession",
			Handler:    _AccountMgr_CheckLoginSession_Handler,
		},
		{
			MethodName: "CreateLoginSession",
			Handler:    _AccountMgr_CreateLoginSession_Handler,
		},
		{
			MethodName: "ListLoginSessions",
			Handler:    _AccountMgr_ListLoginSessions_Handler,
		},
		{
			MethodName: "ListApiKeys",
			Handler:    _AccountMgr_ListApiKeys_Handler,
		},
		{
			MethodName: "LogoutSession",
			Handler:    _AccountMgr_LogoutSession_Handler,
		},
		{
			MethodName: "CreateApiKey",
			Handler:    _AccountMgr_CreateApiKey_Handler,
		},
		{
			MethodName: "GetLanguage",
			Handler:    _AccountMgr_GetLanguage_Handler,
		},
		{
			MethodName: "UpdateLanguage",
			Handler:    _AccountMgr_UpdateLanguage_Handler,
		},
		{
			MethodName: "GetShopSetting",
			Handler:    _AccountMgr_GetShopSetting_Handler,
		},
		{
			MethodName: "UpdateShopSetting",
			Handler:    _AccountMgr_UpdateShopSetting_Handler,
		},
		{
			MethodName: "RefetchShopAddress",
			Handler:    _AccountMgr_RefetchShopAddress_Handler,
		},
		{
			MethodName: "ReadCurrency",
			Handler:    _AccountMgr_ReadCurrency_Handler,
		},
		{
			MethodName: "AutoSyncCurrency",
			Handler:    _AccountMgr_AutoSyncCurrency_Handler,
		},
		{
			MethodName: "ListShopAddresses",
			Handler:    _AccountMgr_ListShopAddresses_Handler,
		},
		{
			MethodName: "CreateShopAddress",
			Handler:    _AccountMgr_CreateShopAddress_Handler,
		},
		{
			MethodName: "UpdateShopAddress",
			Handler:    _AccountMgr_UpdateShopAddress_Handler,
		},
		{
			MethodName: "DeleteShopAddress",
			Handler:    _AccountMgr_DeleteShopAddress_Handler,
		},
		{
			MethodName: "ListTaxes",
			Handler:    _AccountMgr_ListTaxes_Handler,
		},
		{
			MethodName: "CreateTax",
			Handler:    _AccountMgr_CreateTax_Handler,
		},
		{
			MethodName: "UpdateTax",
			Handler:    _AccountMgr_UpdateTax_Handler,
		},
		{
			MethodName: "DeleteTax",
			Handler:    _AccountMgr_DeleteTax_Handler,
		},
		{
			MethodName: "CheckShippingPolicy",
			Handler:    _AccountMgr_CheckShippingPolicy_Handler,
		},
		{
			MethodName: "ListShippingPolicies",
			Handler:    _AccountMgr_ListShippingPolicies_Handler,
		},
		{
			MethodName: "CreateShippingPolicy",
			Handler:    _AccountMgr_CreateShippingPolicy_Handler,
		},
		{
			MethodName: "UpdateShippingPolicy",
			Handler:    _AccountMgr_UpdateShippingPolicy_Handler,
		},
		{
			MethodName: "DeleteShippingPolicy",
			Handler:    _AccountMgr_DeleteShippingPolicy_Handler,
		},
		{
			MethodName: "CreateCancellationCode",
			Handler:    _AccountMgr_CreateCancellationCode_Handler,
		},
		{
			MethodName: "ListCancellationCodes",
			Handler:    _AccountMgr_ListCancellationCodes_Handler,
		},
		{
			MethodName: "UpdateCancellationCode",
			Handler:    _AccountMgr_UpdateCancellationCode_Handler,
		},
		{
			MethodName: "MakeDefaultTax",
			Handler:    _AccountMgr_MakeDefaultTax_Handler,
		},
		{
			MethodName: "ListPaymentMethods",
			Handler:    _AccountMgr_ListPaymentMethods_Handler,
		},
		{
			MethodName: "CreatePaymentMethod",
			Handler:    _AccountMgr_CreatePaymentMethod_Handler,
		},
		{
			MethodName: "UpdatePaymentMethod",
			Handler:    _AccountMgr_UpdatePaymentMethod_Handler,
		},
		{
			MethodName: "DeletePaymentMethod",
			Handler:    _AccountMgr_DeletePaymentMethod_Handler,
		},
		{
			MethodName: "MakeDefaultPaymentMethod",
			Handler:    _AccountMgr_MakeDefaultPaymentMethod_Handler,
		},
		{
			MethodName: "ListSubizPaymentMethods",
			Handler:    _AccountMgr_ListSubizPaymentMethods_Handler,
		},
		{
			MethodName: "UpdateSubizPaymentMethod",
			Handler:    _AccountMgr_UpdateSubizPaymentMethod_Handler,
		},
		{
			MethodName: "DeleteSubizPaymentMethod",
			Handler:    _AccountMgr_DeleteSubizPaymentMethod_Handler,
		},
		{
			MethodName: "MakeDefaultSubizPaymentMethod",
			Handler:    _AccountMgr_MakeDefaultSubizPaymentMethod_Handler,
		},
		{
			MethodName: "ListIntegratedShippingProviders",
			Handler:    _AccountMgr_ListIntegratedShippingProviders_Handler,
		},
		{
			MethodName: "DeintegrateShippingProvider",
			Handler:    _AccountMgr_DeintegrateShippingProvider_Handler,
		},
		{
			MethodName: "IntegrateShippingProvider",
			Handler:    _AccountMgr_IntegrateShippingProvider_Handler,
		},
		{
			MethodName: "SendGHNAffiliateOTP",
			Handler:    _AccountMgr_SendGHNAffiliateOTP_Handler,
		},
		{
			MethodName: "EnterGHNAffiliateOTP",
			Handler:    _AccountMgr_EnterGHNAffiliateOTP_Handler,
		},
		{
			MethodName: "UpdateAgentPresence",
			Handler:    _AccountMgr_UpdateAgentPresence_Handler,
		},
		{
			MethodName: "ListAgentPresences",
			Handler:    _AccountMgr_ListAgentPresences_Handler,
		},
		{
			MethodName: "ListAgentOnlines",
			Handler:    _AccountMgr_ListAgentOnlines_Handler,
		},
		{
			MethodName: "ReportAvailibilities",
			Handler:    _AccountMgr_ReportAvailibilities_Handler,
		},
		{
			MethodName: "NewID",
			Handler:    _AccountMgr_NewID_Handler,
		},
		{
			MethodName: "LockLogin",
			Handler:    _AccountMgr_LockLogin_Handler,
		},
		{
			MethodName: "UnlockLogin",
			Handler:    _AccountMgr_UnlockLogin_Handler,
		},
		{
			MethodName: "ListBills",
			Handler:    _AccountMgr_ListBills_Handler,
		},
		{
			MethodName: "ListPromotionPrograms",
			Handler:    _AccountMgr_ListPromotionPrograms_Handler,
		},
		{
			MethodName: "ListPromotionCodesOfProgram",
			Handler:    _AccountMgr_ListPromotionCodesOfProgram_Handler,
		},
		{
			MethodName: "ListPromotionCodesOfAgent",
			Handler:    _AccountMgr_ListPromotionCodesOfAgent_Handler,
		},
		{
			MethodName: "UpsertPromotionCode",
			Handler:    _AccountMgr_UpsertPromotionCode_Handler,
		},
		{
			MethodName: "CheckPromotionCode",
			Handler:    _AccountMgr_CheckPromotionCode_Handler,
		},
		{
			MethodName: "GetPromotionCode",
			Handler:    _AccountMgr_GetPromotionCode_Handler,
		},
		{
			MethodName: "DeletePromotionCode",
			Handler:    _AccountMgr_DeletePromotionCode_Handler,
		},
		{
			MethodName: "RedeemPromotionCode",
			Handler:    _AccountMgr_RedeemPromotionCode_Handler,
		},
		{
			MethodName: "ListPromotionProgramInvoices",
			Handler:    _AccountMgr_ListPromotionProgramInvoices_Handler,
		},
		{
			MethodName: "CreateStripeCheckoutSession",
			Handler:    _AccountMgr_CreateStripeCheckoutSession_Handler,
		},
		{
			MethodName: "OnStripeEvent",
			Handler:    _AccountMgr_OnStripeEvent_Handler,
		},
		{
			MethodName: "LookupStripePaymentMethod",
			Handler:    _AccountMgr_LookupStripePaymentMethod_Handler,
		},
		{
			MethodName: "DiffSubscription",
			Handler:    _AccountMgr_DiffSubscription_Handler,
		},
		{
			MethodName: "AddBankAccount",
			Handler:    _AccountMgr_AddBankAccount_Handler,
		},
		{
			MethodName: "UpdateBankAccount",
			Handler:    _AccountMgr_UpdateBankAccount_Handler,
		},
		{
			MethodName: "DeleteBankAccount",
			Handler:    _AccountMgr_DeleteBankAccount_Handler,
		},
		{
			MethodName: "ListBankAccounts",
			Handler:    _AccountMgr_ListBankAccounts_Handler,
		},
		{
			MethodName: "VerifyBankAccount",
			Handler:    _AccountMgr_VerifyBankAccount_Handler,
		},
		{
			MethodName: "GenerateBankTransferRequest",
			Handler:    _AccountMgr_GenerateBankTransferRequest_Handler,
		},
		{
			MethodName: "GenerateQrCodeRequest",
			Handler:    _AccountMgr_GenerateQrCodeRequest_Handler,
		},
		{
			MethodName: "GetSetupFeatureStatus",
			Handler:    _AccountMgr_GetSetupFeatureStatus_Handler,
		},
		{
			MethodName: "UpdateSetupFeatureStatus",
			Handler:    _AccountMgr_UpdateSetupFeatureStatus_Handler,
		},
		{
			MethodName: "ListActiveAccountIds",
			Handler:    _AccountMgr_ListActiveAccountIds_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	UserCache_SuggestLeadField_FullMethodName       = "/header.UserCache/SuggestLeadField"
	UserCache_ListLeads_FullMethodName              = "/header.UserCache/ListLeads"
	UserCache_CountLeads_FullMethodName             = "/header.UserCache/CountLeads"
	UserCache_UpdateUser_FullMethodName             = "/header.UserCache/UpdateUser"
	UserCache_AddUsersToSegment_FullMethodName      = "/header.UserCache/AddUsersToSegment"
	UserCache_RemoveUsersFromSegment_FullMethodName = "/header.UserCache/RemoveUsersFromSegment"
)

// UserCacheClient is the client API for UserCache service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserCacheClient interface {
	// rpc ListLeadIds(header.UserView) returns (Response);
	SuggestLeadField(ctx context.Context, in *SuggestLeadFieldRequest, opts ...grpc.CallOption) (*SuggestLeadFieldResponse, error)
	ListLeads(ctx context.Context, in *UserView, opts ...grpc.CallOption) (*Response, error)
	CountLeads(ctx context.Context, in *UserView, opts ...grpc.CallOption) (*Response, error)
	UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*Response, error)
	AddUsersToSegment(ctx context.Context, in *SegmentUsersRequest, opts ...grpc.CallOption) (*Response, error)
	RemoveUsersFromSegment(ctx context.Context, in *SegmentUsersRequest, opts ...grpc.CallOption) (*Response, error)
}

type userCacheClient struct {
	cc grpc.ClientConnInterface
}

func NewUserCacheClient(cc grpc.ClientConnInterface) UserCacheClient {
	return &userCacheClient{cc}
}

func (c *userCacheClient) SuggestLeadField(ctx context.Context, in *SuggestLeadFieldRequest, opts ...grpc.CallOption) (*SuggestLeadFieldResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SuggestLeadFieldResponse)
	err := c.cc.Invoke(ctx, UserCache_SuggestLeadField_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userCacheClient) ListLeads(ctx context.Context, in *UserView, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, UserCache_ListLeads_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userCacheClient) CountLeads(ctx context.Context, in *UserView, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, UserCache_CountLeads_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userCacheClient) UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, UserCache_UpdateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userCacheClient) AddUsersToSegment(ctx context.Context, in *SegmentUsersRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, UserCache_AddUsersToSegment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userCacheClient) RemoveUsersFromSegment(ctx context.Context, in *SegmentUsersRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, UserCache_RemoveUsersFromSegment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserCacheServer is the server API for UserCache service.
// All implementations must embed UnimplementedUserCacheServer
// for forward compatibility.
type UserCacheServer interface {
	// rpc ListLeadIds(header.UserView) returns (Response);
	SuggestLeadField(context.Context, *SuggestLeadFieldRequest) (*SuggestLeadFieldResponse, error)
	ListLeads(context.Context, *UserView) (*Response, error)
	CountLeads(context.Context, *UserView) (*Response, error)
	UpdateUser(context.Context, *User) (*Response, error)
	AddUsersToSegment(context.Context, *SegmentUsersRequest) (*Response, error)
	RemoveUsersFromSegment(context.Context, *SegmentUsersRequest) (*Response, error)
	mustEmbedUnimplementedUserCacheServer()
}

// UnimplementedUserCacheServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserCacheServer struct{}

func (UnimplementedUserCacheServer) SuggestLeadField(context.Context, *SuggestLeadFieldRequest) (*SuggestLeadFieldResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SuggestLeadField not implemented")
}
func (UnimplementedUserCacheServer) ListLeads(context.Context, *UserView) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLeads not implemented")
}
func (UnimplementedUserCacheServer) CountLeads(context.Context, *UserView) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountLeads not implemented")
}
func (UnimplementedUserCacheServer) UpdateUser(context.Context, *User) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedUserCacheServer) AddUsersToSegment(context.Context, *SegmentUsersRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUsersToSegment not implemented")
}
func (UnimplementedUserCacheServer) RemoveUsersFromSegment(context.Context, *SegmentUsersRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveUsersFromSegment not implemented")
}
func (UnimplementedUserCacheServer) mustEmbedUnimplementedUserCacheServer() {}
func (UnimplementedUserCacheServer) testEmbeddedByValue()                   {}

// UnsafeUserCacheServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserCacheServer will
// result in compilation errors.
type UnsafeUserCacheServer interface {
	mustEmbedUnimplementedUserCacheServer()
}

func RegisterUserCacheServer(s grpc.ServiceRegistrar, srv UserCacheServer) {
	// If the following call pancis, it indicates UnimplementedUserCacheServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserCache_ServiceDesc, srv)
}

func _UserCache_SuggestLeadField_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuggestLeadFieldRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserCacheServer).SuggestLeadField(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserCache_SuggestLeadField_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserCacheServer).SuggestLeadField(ctx, req.(*SuggestLeadFieldRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserCache_ListLeads_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserView)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserCacheServer).ListLeads(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserCache_ListLeads_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserCacheServer).ListLeads(ctx, req.(*UserView))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserCache_CountLeads_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserView)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserCacheServer).CountLeads(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserCache_CountLeads_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserCacheServer).CountLeads(ctx, req.(*UserView))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserCache_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserCacheServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserCache_UpdateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserCacheServer).UpdateUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserCache_AddUsersToSegment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SegmentUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserCacheServer).AddUsersToSegment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserCache_AddUsersToSegment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserCacheServer).AddUsersToSegment(ctx, req.(*SegmentUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserCache_RemoveUsersFromSegment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SegmentUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserCacheServer).RemoveUsersFromSegment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserCache_RemoveUsersFromSegment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserCacheServer).RemoveUsersFromSegment(ctx, req.(*SegmentUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserCache_ServiceDesc is the grpc.ServiceDesc for UserCache service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserCache_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.UserCache",
	HandlerType: (*UserCacheServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SuggestLeadField",
			Handler:    _UserCache_SuggestLeadField_Handler,
		},
		{
			MethodName: "ListLeads",
			Handler:    _UserCache_ListLeads_Handler,
		},
		{
			MethodName: "CountLeads",
			Handler:    _UserCache_CountLeads_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _UserCache_UpdateUser_Handler,
		},
		{
			MethodName: "AddUsersToSegment",
			Handler:    _UserCache_AddUsersToSegment_Handler,
		},
		{
			MethodName: "RemoveUsersFromSegment",
			Handler:    _UserCache_RemoveUsersFromSegment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	Crash_Crash_FullMethodName = "/header.Crash/Crash"
)

// CrashClient is the client API for Crash service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CrashClient interface {
	Crash(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Response, error)
}

type crashClient struct {
	cc grpc.ClientConnInterface
}

func NewCrashClient(cc grpc.ClientConnInterface) CrashClient {
	return &crashClient{cc}
}

func (c *crashClient) Crash(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Crash_Crash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CrashServer is the server API for Crash service.
// All implementations must embed UnimplementedCrashServer
// for forward compatibility.
type CrashServer interface {
	Crash(context.Context, *Empty) (*Response, error)
	mustEmbedUnimplementedCrashServer()
}

// UnimplementedCrashServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCrashServer struct{}

func (UnimplementedCrashServer) Crash(context.Context, *Empty) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Crash not implemented")
}
func (UnimplementedCrashServer) mustEmbedUnimplementedCrashServer() {}
func (UnimplementedCrashServer) testEmbeddedByValue()               {}

// UnsafeCrashServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CrashServer will
// result in compilation errors.
type UnsafeCrashServer interface {
	mustEmbedUnimplementedCrashServer()
}

func RegisterCrashServer(s grpc.ServiceRegistrar, srv CrashServer) {
	// If the following call pancis, it indicates UnimplementedCrashServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Crash_ServiceDesc, srv)
}

func _Crash_Crash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CrashServer).Crash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Crash_Crash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CrashServer).Crash(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Crash_ServiceDesc is the grpc.ServiceDesc for Crash service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Crash_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.Crash",
	HandlerType: (*CrashServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Crash",
			Handler:    _Crash_Crash_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	UserMgr_MergeUser_FullMethodName                        = "/header.UserMgr/MergeUser"
	UserMgr_DetachUser_FullMethodName                       = "/header.UserMgr/DetachUser"
	UserMgr_CreateUser2_FullMethodName                      = "/header.UserMgr/CreateUser2"
	UserMgr_UpdateUser_FullMethodName                       = "/header.UserMgr/UpdateUser"
	UserMgr_TryUpdateUser_FullMethodName                    = "/header.UserMgr/TryUpdateUser"
	UserMgr_RemoveUser_FullMethodName                       = "/header.UserMgr/RemoveUser"
	UserMgr_RestoreUser_FullMethodName                      = "/header.UserMgr/RestoreUser"
	UserMgr_ReadUser_FullMethodName                         = "/header.UserMgr/ReadUser"
	UserMgr_ReadOrCreateUserByContactProfile_FullMethodName = "/header.UserMgr/ReadOrCreateUserByContactProfile"
	UserMgr_MatchUsers_FullMethodName                       = "/header.UserMgr/MatchUsers"
	UserMgr_BanUser_FullMethodName                          = "/header.UserMgr/BanUser"
	UserMgr_UnbanUser_FullMethodName                        = "/header.UserMgr/UnbanUser"
	UserMgr_LookupByPhone_FullMethodName                    = "/header.UserMgr/LookupByPhone"
	UserMgr_UpdateView_FullMethodName                       = "/header.UserMgr/UpdateView"
	UserMgr_CreateView_FullMethodName                       = "/header.UserMgr/CreateView"
	UserMgr_DeleteView_FullMethodName                       = "/header.UserMgr/DeleteView"
	UserMgr_GetView_FullMethodName                          = "/header.UserMgr/GetView"
	UserMgr_ListViews_FullMethodName                        = "/header.UserMgr/ListViews"
	UserMgr_UpdateSegment_FullMethodName                    = "/header.UserMgr/UpdateSegment"
	UserMgr_CreateSegment_FullMethodName                    = "/header.UserMgr/CreateSegment"
	UserMgr_DeleteSegment_FullMethodName                    = "/header.UserMgr/DeleteSegment"
	UserMgr_GetSegment_FullMethodName                       = "/header.UserMgr/GetSegment"
	UserMgr_ListSegments_FullMethodName                     = "/header.UserMgr/ListSegments"
	UserMgr_AddToSegment_FullMethodName                     = "/header.UserMgr/AddToSegment"
	UserMgr_RemoveFromSegment_FullMethodName                = "/header.UserMgr/RemoveFromSegment"
	UserMgr_ListSegmentSyncs_FullMethodName                 = "/header.UserMgr/ListSegmentSyncs"
	UserMgr_UpdateSegmentSync_FullMethodName                = "/header.UserMgr/UpdateSegmentSync"
	UserMgr_GetSegmentSync_FullMethodName                   = "/header.UserMgr/GetSegmentSync"
	UserMgr_CreateSegmentSync_FullMethodName                = "/header.UserMgr/CreateSegmentSync"
	UserMgr_DeleteSegmentSync_FullMethodName                = "/header.UserMgr/DeleteSegmentSync"
	UserMgr_MatchSegmentSyncs_FullMethodName                = "/header.UserMgr/MatchSegmentSyncs"
	UserMgr_CheckUserSegmentSyncStatus_FullMethodName       = "/header.UserMgr/CheckUserSegmentSyncStatus"
	UserMgr_UpsertLabel_FullMethodName                      = "/header.UserMgr/UpsertLabel"
	UserMgr_DeleteLabel_FullMethodName                      = "/header.UserMgr/DeleteLabel"
	UserMgr_ListLabels_FullMethodName                       = "/header.UserMgr/ListLabels"
	UserMgr_GetLabel_FullMethodName                         = "/header.UserMgr/GetLabel"
	UserMgr_AddLeadOwner_FullMethodName                     = "/header.UserMgr/AddLeadOwner"
	UserMgr_RemoveLeadOwner_FullMethodName                  = "/header.UserMgr/RemoveLeadOwner"
	UserMgr_AddUserLabel_FullMethodName                     = "/header.UserMgr/AddUserLabel"
	UserMgr_RemoveUserLabel_FullMethodName                  = "/header.UserMgr/RemoveUserLabel"
	UserMgr_AddLeadConversionBy_FullMethodName              = "/header.UserMgr/AddLeadConversionBy"
	UserMgr_CreateShippingAddress_FullMethodName            = "/header.UserMgr/CreateShippingAddress"
	UserMgr_UpdateShippingAddress_FullMethodName            = "/header.UserMgr/UpdateShippingAddress"
	UserMgr_RemoveShippingAddress_FullMethodName            = "/header.UserMgr/RemoveShippingAddress"
	UserMgr_ListShippingAddress_FullMethodName              = "/header.UserMgr/ListShippingAddress"
	UserMgr_MakeDefaultShippingAddress_FullMethodName       = "/header.UserMgr/MakeDefaultShippingAddress"
	UserMgr_ListLeads_FullMethodName                        = "/header.UserMgr/ListLeads"
	UserMgr_ListLeads2_FullMethodName                       = "/header.UserMgr/ListLeads2"
	UserMgr_SuggestLeadField_FullMethodName                 = "/header.UserMgr/SuggestLeadField"
	UserMgr_LinkProductUrl_FullMethodName                   = "/header.UserMgr/LinkProductUrl"
	UserMgr_ListUserEvents_FullMethodName                   = "/header.UserMgr/ListUserEvents"
	UserMgr_CreateUserEvent_FullMethodName                  = "/header.UserMgr/CreateUserEvent"
	UserMgr_FillDevice_FullMethodName                       = "/header.UserMgr/FillDevice"
	UserMgr_ImportLead_FullMethodName                       = "/header.UserMgr/ImportLead"
	UserMgr_LinkTask_FullMethodName                         = "/header.UserMgr/LinkTask"
	UserMgr_CountUserProfiles_FullMethodName                = "/header.UserMgr/CountUserProfiles"
	UserMgr_ListUserIds_FullMethodName                      = "/header.UserMgr/ListUserIds"
	UserMgr_ListUserIdWithPhones_FullMethodName             = "/header.UserMgr/ListUserIdWithPhones"
	UserMgr_SearchUsers_FullMethodName                      = "/header.UserMgr/SearchUsers"
	UserMgr_ReportUser_FullMethodName                       = "/header.UserMgr/ReportUser"
	UserMgr_FetchLiveUsers_FullMethodName                   = "/header.UserMgr/FetchLiveUsers"
	UserMgr_StopLiveUsers_FullMethodName                    = "/header.UserMgr/StopLiveUsers"
	UserMgr_SuggestLiveFields_FullMethodName                = "/header.UserMgr/SuggestLiveFields"
	UserMgr_Presences_FullMethodName                        = "/header.UserMgr/Presences"
	UserMgr_UpdateSegmentMember_FullMethodName              = "/header.UserMgr/UpdateSegmentMember"
	UserMgr_RemoveSegmentMember_FullMethodName              = "/header.UserMgr/RemoveSegmentMember"
)

// UserMgrClient is the client API for UserMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// user services
type UserMgrClient interface {
	MergeUser(ctx context.Context, in *Users, opts ...grpc.CallOption) (*User, error)
	DetachUser(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	CreateUser2(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	TryUpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*TryUpdateUserResult, error)
	RemoveUser(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	RestoreUser(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ReadUser(ctx context.Context, in *Id, opts ...grpc.CallOption) (*User, error)
	ReadOrCreateUserByContactProfile(ctx context.Context, in *Id, opts ...grpc.CallOption) (*User, error)
	MatchUsers(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Users, error)
	BanUser(ctx context.Context, in *Id, opts ...grpc.CallOption) (*User, error)
	UnbanUser(ctx context.Context, in *Id, opts ...grpc.CallOption) (*User, error)
	LookupByPhone(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Users, error)
	UpdateView(ctx context.Context, in *UserView, opts ...grpc.CallOption) (*UserView, error)
	CreateView(ctx context.Context, in *UserView, opts ...grpc.CallOption) (*UserView, error)
	DeleteView(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	GetView(ctx context.Context, in *Id, opts ...grpc.CallOption) (*UserView, error)
	ListViews(ctx context.Context, in *Id, opts ...grpc.CallOption) (*UserViews, error)
	UpdateSegment(ctx context.Context, in *Segment, opts ...grpc.CallOption) (*Segment, error)
	CreateSegment(ctx context.Context, in *Segment, opts ...grpc.CallOption) (*Segment, error)
	DeleteSegment(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	GetSegment(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Segment, error)
	ListSegments(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Segments, error)
	AddToSegment(ctx context.Context, in *SegmentUsers, opts ...grpc.CallOption) (*Empty, error)
	RemoveFromSegment(ctx context.Context, in *SegmentUsers, opts ...grpc.CallOption) (*Empty, error)
	ListSegmentSyncs(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	UpdateSegmentSync(ctx context.Context, in *SegmentSync, opts ...grpc.CallOption) (*Response, error)
	GetSegmentSync(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	CreateSegmentSync(ctx context.Context, in *SegmentSync, opts ...grpc.CallOption) (*Response, error)
	DeleteSegmentSync(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	MatchSegmentSyncs(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
	CheckUserSegmentSyncStatus(ctx context.Context, in *UserSegmentSyncStatusCheck, opts ...grpc.CallOption) (*Response, error)
	UpsertLabel(ctx context.Context, in *Label, opts ...grpc.CallOption) (*Label, error)
	DeleteLabel(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ListLabels(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Labels, error)
	GetLabel(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Label, error)
	AddLeadOwner(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*Empty, error)
	RemoveLeadOwner(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*Empty, error)
	AddUserLabel(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*Empty, error)
	RemoveUserLabel(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*Empty, error)
	AddLeadConversionBy(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*Empty, error)
	CreateShippingAddress(ctx context.Context, in *Address, opts ...grpc.CallOption) (*Address, error)
	UpdateShippingAddress(ctx context.Context, in *Address, opts ...grpc.CallOption) (*Address, error)
	RemoveShippingAddress(ctx context.Context, in *Address, opts ...grpc.CallOption) (*Empty, error)
	ListShippingAddress(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ShippingAddresses, error)
	MakeDefaultShippingAddress(ctx context.Context, in *Address, opts ...grpc.CallOption) (*Empty, error)
	ListLeads(ctx context.Context, in *UserView, opts ...grpc.CallOption) (*Users, error)
	ListLeads2(ctx context.Context, in *UserView, opts ...grpc.CallOption) (*Users, error)
	SuggestLeadField(ctx context.Context, in *SuggestLeadFieldRequest, opts ...grpc.CallOption) (*SuggestLeadFieldResponse, error)
	LinkProductUrl(ctx context.Context, in *Product, opts ...grpc.CallOption) (*Product, error)
	ListUserEvents(ctx context.Context, in *ListUserEventsRequest, opts ...grpc.CallOption) (*Events, error)
	CreateUserEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error)
	FillDevice(ctx context.Context, in *common.Device, opts ...grpc.CallOption) (*common.Device, error)
	ImportLead(ctx context.Context, in *ImportLeadRequest, opts ...grpc.CallOption) (*ImportLeadResponse, error)
	LinkTask(ctx context.Context, in *Task, opts ...grpc.CallOption) (*Empty, error)
	CountUserProfiles(ctx context.Context, in *UsersRequest, opts ...grpc.CallOption) (*CountTouchpointResponse, error)
	ListUserIds(ctx context.Context, in *UsersRequest, opts ...grpc.CallOption) (*Ids, error)
	ListUserIdWithPhones(ctx context.Context, in *UsersRequest, opts ...grpc.CallOption) (*Users, error)
	SearchUsers(ctx context.Context, in *DocSearchRequest, opts ...grpc.CallOption) (*DocSearchResponse, error)
	ReportUser(ctx context.Context, in *UserReportRequest, opts ...grpc.CallOption) (*UserReportResponse, error)
	FetchLiveUsers(ctx context.Context, in *LiveUserView, opts ...grpc.CallOption) (*LiveUserView, error)
	StopLiveUsers(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	SuggestLiveFields(ctx context.Context, in *SuggestLeadFieldRequest, opts ...grpc.CallOption) (*SuggestLeadFieldResponse, error)
	Presences(ctx context.Context, in *PresencesRequest, opts ...grpc.CallOption) (*PresencesResponse, error)
	UpdateSegmentMember(ctx context.Context, in *ResourceGroupMember, opts ...grpc.CallOption) (*ResourceGroupMember, error)
	RemoveSegmentMember(ctx context.Context, in *ResourceGroupMember, opts ...grpc.CallOption) (*Empty, error)
}

type userMgrClient struct {
	cc grpc.ClientConnInterface
}

func NewUserMgrClient(cc grpc.ClientConnInterface) UserMgrClient {
	return &userMgrClient{cc}
}

func (c *userMgrClient) MergeUser(ctx context.Context, in *Users, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserMgr_MergeUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) DetachUser(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserMgr_DetachUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) CreateUser2(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserMgr_CreateUser2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserMgr_UpdateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) TryUpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*TryUpdateUserResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TryUpdateUserResult)
	err := c.cc.Invoke(ctx, UserMgr_TryUpdateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) RemoveUser(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserMgr_RemoveUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) RestoreUser(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserMgr_RestoreUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) ReadUser(ctx context.Context, in *Id, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserMgr_ReadUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) ReadOrCreateUserByContactProfile(ctx context.Context, in *Id, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserMgr_ReadOrCreateUserByContactProfile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) MatchUsers(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Users, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Users)
	err := c.cc.Invoke(ctx, UserMgr_MatchUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) BanUser(ctx context.Context, in *Id, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserMgr_BanUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) UnbanUser(ctx context.Context, in *Id, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserMgr_UnbanUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) LookupByPhone(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Users, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Users)
	err := c.cc.Invoke(ctx, UserMgr_LookupByPhone_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) UpdateView(ctx context.Context, in *UserView, opts ...grpc.CallOption) (*UserView, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserView)
	err := c.cc.Invoke(ctx, UserMgr_UpdateView_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) CreateView(ctx context.Context, in *UserView, opts ...grpc.CallOption) (*UserView, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserView)
	err := c.cc.Invoke(ctx, UserMgr_CreateView_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) DeleteView(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserMgr_DeleteView_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) GetView(ctx context.Context, in *Id, opts ...grpc.CallOption) (*UserView, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserView)
	err := c.cc.Invoke(ctx, UserMgr_GetView_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) ListViews(ctx context.Context, in *Id, opts ...grpc.CallOption) (*UserViews, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserViews)
	err := c.cc.Invoke(ctx, UserMgr_ListViews_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) UpdateSegment(ctx context.Context, in *Segment, opts ...grpc.CallOption) (*Segment, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Segment)
	err := c.cc.Invoke(ctx, UserMgr_UpdateSegment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) CreateSegment(ctx context.Context, in *Segment, opts ...grpc.CallOption) (*Segment, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Segment)
	err := c.cc.Invoke(ctx, UserMgr_CreateSegment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) DeleteSegment(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserMgr_DeleteSegment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) GetSegment(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Segment, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Segment)
	err := c.cc.Invoke(ctx, UserMgr_GetSegment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) ListSegments(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Segments, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Segments)
	err := c.cc.Invoke(ctx, UserMgr_ListSegments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) AddToSegment(ctx context.Context, in *SegmentUsers, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserMgr_AddToSegment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) RemoveFromSegment(ctx context.Context, in *SegmentUsers, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserMgr_RemoveFromSegment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) ListSegmentSyncs(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, UserMgr_ListSegmentSyncs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) UpdateSegmentSync(ctx context.Context, in *SegmentSync, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, UserMgr_UpdateSegmentSync_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) GetSegmentSync(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, UserMgr_GetSegmentSync_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) CreateSegmentSync(ctx context.Context, in *SegmentSync, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, UserMgr_CreateSegmentSync_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) DeleteSegmentSync(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, UserMgr_DeleteSegmentSync_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) MatchSegmentSyncs(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, UserMgr_MatchSegmentSyncs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) CheckUserSegmentSyncStatus(ctx context.Context, in *UserSegmentSyncStatusCheck, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, UserMgr_CheckUserSegmentSyncStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) UpsertLabel(ctx context.Context, in *Label, opts ...grpc.CallOption) (*Label, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Label)
	err := c.cc.Invoke(ctx, UserMgr_UpsertLabel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) DeleteLabel(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserMgr_DeleteLabel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) ListLabels(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Labels, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Labels)
	err := c.cc.Invoke(ctx, UserMgr_ListLabels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) GetLabel(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Label, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Label)
	err := c.cc.Invoke(ctx, UserMgr_GetLabel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) AddLeadOwner(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserMgr_AddLeadOwner_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) RemoveLeadOwner(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserMgr_RemoveLeadOwner_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) AddUserLabel(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserMgr_AddUserLabel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) RemoveUserLabel(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserMgr_RemoveUserLabel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) AddLeadConversionBy(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserMgr_AddLeadConversionBy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) CreateShippingAddress(ctx context.Context, in *Address, opts ...grpc.CallOption) (*Address, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Address)
	err := c.cc.Invoke(ctx, UserMgr_CreateShippingAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) UpdateShippingAddress(ctx context.Context, in *Address, opts ...grpc.CallOption) (*Address, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Address)
	err := c.cc.Invoke(ctx, UserMgr_UpdateShippingAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) RemoveShippingAddress(ctx context.Context, in *Address, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserMgr_RemoveShippingAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) ListShippingAddress(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ShippingAddresses, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShippingAddresses)
	err := c.cc.Invoke(ctx, UserMgr_ListShippingAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) MakeDefaultShippingAddress(ctx context.Context, in *Address, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserMgr_MakeDefaultShippingAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) ListLeads(ctx context.Context, in *UserView, opts ...grpc.CallOption) (*Users, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Users)
	err := c.cc.Invoke(ctx, UserMgr_ListLeads_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) ListLeads2(ctx context.Context, in *UserView, opts ...grpc.CallOption) (*Users, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Users)
	err := c.cc.Invoke(ctx, UserMgr_ListLeads2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) SuggestLeadField(ctx context.Context, in *SuggestLeadFieldRequest, opts ...grpc.CallOption) (*SuggestLeadFieldResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SuggestLeadFieldResponse)
	err := c.cc.Invoke(ctx, UserMgr_SuggestLeadField_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) LinkProductUrl(ctx context.Context, in *Product, opts ...grpc.CallOption) (*Product, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Product)
	err := c.cc.Invoke(ctx, UserMgr_LinkProductUrl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) ListUserEvents(ctx context.Context, in *ListUserEventsRequest, opts ...grpc.CallOption) (*Events, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Events)
	err := c.cc.Invoke(ctx, UserMgr_ListUserEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) CreateUserEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Event)
	err := c.cc.Invoke(ctx, UserMgr_CreateUserEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) FillDevice(ctx context.Context, in *common.Device, opts ...grpc.CallOption) (*common.Device, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(common.Device)
	err := c.cc.Invoke(ctx, UserMgr_FillDevice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) ImportLead(ctx context.Context, in *ImportLeadRequest, opts ...grpc.CallOption) (*ImportLeadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportLeadResponse)
	err := c.cc.Invoke(ctx, UserMgr_ImportLead_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) LinkTask(ctx context.Context, in *Task, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserMgr_LinkTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) CountUserProfiles(ctx context.Context, in *UsersRequest, opts ...grpc.CallOption) (*CountTouchpointResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CountTouchpointResponse)
	err := c.cc.Invoke(ctx, UserMgr_CountUserProfiles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) ListUserIds(ctx context.Context, in *UsersRequest, opts ...grpc.CallOption) (*Ids, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Ids)
	err := c.cc.Invoke(ctx, UserMgr_ListUserIds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) ListUserIdWithPhones(ctx context.Context, in *UsersRequest, opts ...grpc.CallOption) (*Users, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Users)
	err := c.cc.Invoke(ctx, UserMgr_ListUserIdWithPhones_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) SearchUsers(ctx context.Context, in *DocSearchRequest, opts ...grpc.CallOption) (*DocSearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DocSearchResponse)
	err := c.cc.Invoke(ctx, UserMgr_SearchUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) ReportUser(ctx context.Context, in *UserReportRequest, opts ...grpc.CallOption) (*UserReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserReportResponse)
	err := c.cc.Invoke(ctx, UserMgr_ReportUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) FetchLiveUsers(ctx context.Context, in *LiveUserView, opts ...grpc.CallOption) (*LiveUserView, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LiveUserView)
	err := c.cc.Invoke(ctx, UserMgr_FetchLiveUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) StopLiveUsers(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserMgr_StopLiveUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) SuggestLiveFields(ctx context.Context, in *SuggestLeadFieldRequest, opts ...grpc.CallOption) (*SuggestLeadFieldResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SuggestLeadFieldResponse)
	err := c.cc.Invoke(ctx, UserMgr_SuggestLiveFields_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) Presences(ctx context.Context, in *PresencesRequest, opts ...grpc.CallOption) (*PresencesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PresencesResponse)
	err := c.cc.Invoke(ctx, UserMgr_Presences_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) UpdateSegmentMember(ctx context.Context, in *ResourceGroupMember, opts ...grpc.CallOption) (*ResourceGroupMember, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResourceGroupMember)
	err := c.cc.Invoke(ctx, UserMgr_UpdateSegmentMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) RemoveSegmentMember(ctx context.Context, in *ResourceGroupMember, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserMgr_RemoveSegmentMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserMgrServer is the server API for UserMgr service.
// All implementations must embed UnimplementedUserMgrServer
// for forward compatibility.
//
// user services
type UserMgrServer interface {
	MergeUser(context.Context, *Users) (*User, error)
	DetachUser(context.Context, *Id) (*Empty, error)
	CreateUser2(context.Context, *User) (*User, error)
	UpdateUser(context.Context, *User) (*User, error)
	TryUpdateUser(context.Context, *User) (*TryUpdateUserResult, error)
	RemoveUser(context.Context, *Id) (*Empty, error)
	RestoreUser(context.Context, *Id) (*Empty, error)
	ReadUser(context.Context, *Id) (*User, error)
	ReadOrCreateUserByContactProfile(context.Context, *Id) (*User, error)
	MatchUsers(context.Context, *Ids) (*Users, error)
	BanUser(context.Context, *Id) (*User, error)
	UnbanUser(context.Context, *Id) (*User, error)
	LookupByPhone(context.Context, *Id) (*Users, error)
	UpdateView(context.Context, *UserView) (*UserView, error)
	CreateView(context.Context, *UserView) (*UserView, error)
	DeleteView(context.Context, *Id) (*Empty, error)
	GetView(context.Context, *Id) (*UserView, error)
	ListViews(context.Context, *Id) (*UserViews, error)
	UpdateSegment(context.Context, *Segment) (*Segment, error)
	CreateSegment(context.Context, *Segment) (*Segment, error)
	DeleteSegment(context.Context, *Id) (*Empty, error)
	GetSegment(context.Context, *Id) (*Segment, error)
	ListSegments(context.Context, *Id) (*Segments, error)
	AddToSegment(context.Context, *SegmentUsers) (*Empty, error)
	RemoveFromSegment(context.Context, *SegmentUsers) (*Empty, error)
	ListSegmentSyncs(context.Context, *Id) (*Response, error)
	UpdateSegmentSync(context.Context, *SegmentSync) (*Response, error)
	GetSegmentSync(context.Context, *Id) (*Response, error)
	CreateSegmentSync(context.Context, *SegmentSync) (*Response, error)
	DeleteSegmentSync(context.Context, *Id) (*Response, error)
	MatchSegmentSyncs(context.Context, *Ids) (*Response, error)
	CheckUserSegmentSyncStatus(context.Context, *UserSegmentSyncStatusCheck) (*Response, error)
	UpsertLabel(context.Context, *Label) (*Label, error)
	DeleteLabel(context.Context, *Id) (*Empty, error)
	ListLabels(context.Context, *Id) (*Labels, error)
	GetLabel(context.Context, *Id) (*Label, error)
	AddLeadOwner(context.Context, *UserRequest) (*Empty, error)
	RemoveLeadOwner(context.Context, *UserRequest) (*Empty, error)
	AddUserLabel(context.Context, *UserRequest) (*Empty, error)
	RemoveUserLabel(context.Context, *UserRequest) (*Empty, error)
	AddLeadConversionBy(context.Context, *UserRequest) (*Empty, error)
	CreateShippingAddress(context.Context, *Address) (*Address, error)
	UpdateShippingAddress(context.Context, *Address) (*Address, error)
	RemoveShippingAddress(context.Context, *Address) (*Empty, error)
	ListShippingAddress(context.Context, *Id) (*ShippingAddresses, error)
	MakeDefaultShippingAddress(context.Context, *Address) (*Empty, error)
	ListLeads(context.Context, *UserView) (*Users, error)
	ListLeads2(context.Context, *UserView) (*Users, error)
	SuggestLeadField(context.Context, *SuggestLeadFieldRequest) (*SuggestLeadFieldResponse, error)
	LinkProductUrl(context.Context, *Product) (*Product, error)
	ListUserEvents(context.Context, *ListUserEventsRequest) (*Events, error)
	CreateUserEvent(context.Context, *Event) (*Event, error)
	FillDevice(context.Context, *common.Device) (*common.Device, error)
	ImportLead(context.Context, *ImportLeadRequest) (*ImportLeadResponse, error)
	LinkTask(context.Context, *Task) (*Empty, error)
	CountUserProfiles(context.Context, *UsersRequest) (*CountTouchpointResponse, error)
	ListUserIds(context.Context, *UsersRequest) (*Ids, error)
	ListUserIdWithPhones(context.Context, *UsersRequest) (*Users, error)
	SearchUsers(context.Context, *DocSearchRequest) (*DocSearchResponse, error)
	ReportUser(context.Context, *UserReportRequest) (*UserReportResponse, error)
	FetchLiveUsers(context.Context, *LiveUserView) (*LiveUserView, error)
	StopLiveUsers(context.Context, *Id) (*Empty, error)
	SuggestLiveFields(context.Context, *SuggestLeadFieldRequest) (*SuggestLeadFieldResponse, error)
	Presences(context.Context, *PresencesRequest) (*PresencesResponse, error)
	UpdateSegmentMember(context.Context, *ResourceGroupMember) (*ResourceGroupMember, error)
	RemoveSegmentMember(context.Context, *ResourceGroupMember) (*Empty, error)
	mustEmbedUnimplementedUserMgrServer()
}

// UnimplementedUserMgrServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserMgrServer struct{}

func (UnimplementedUserMgrServer) MergeUser(context.Context, *Users) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MergeUser not implemented")
}
func (UnimplementedUserMgrServer) DetachUser(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetachUser not implemented")
}
func (UnimplementedUserMgrServer) CreateUser2(context.Context, *User) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser2 not implemented")
}
func (UnimplementedUserMgrServer) UpdateUser(context.Context, *User) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedUserMgrServer) TryUpdateUser(context.Context, *User) (*TryUpdateUserResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TryUpdateUser not implemented")
}
func (UnimplementedUserMgrServer) RemoveUser(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveUser not implemented")
}
func (UnimplementedUserMgrServer) RestoreUser(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestoreUser not implemented")
}
func (UnimplementedUserMgrServer) ReadUser(context.Context, *Id) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadUser not implemented")
}
func (UnimplementedUserMgrServer) ReadOrCreateUserByContactProfile(context.Context, *Id) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadOrCreateUserByContactProfile not implemented")
}
func (UnimplementedUserMgrServer) MatchUsers(context.Context, *Ids) (*Users, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchUsers not implemented")
}
func (UnimplementedUserMgrServer) BanUser(context.Context, *Id) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BanUser not implemented")
}
func (UnimplementedUserMgrServer) UnbanUser(context.Context, *Id) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnbanUser not implemented")
}
func (UnimplementedUserMgrServer) LookupByPhone(context.Context, *Id) (*Users, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LookupByPhone not implemented")
}
func (UnimplementedUserMgrServer) UpdateView(context.Context, *UserView) (*UserView, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateView not implemented")
}
func (UnimplementedUserMgrServer) CreateView(context.Context, *UserView) (*UserView, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateView not implemented")
}
func (UnimplementedUserMgrServer) DeleteView(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteView not implemented")
}
func (UnimplementedUserMgrServer) GetView(context.Context, *Id) (*UserView, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetView not implemented")
}
func (UnimplementedUserMgrServer) ListViews(context.Context, *Id) (*UserViews, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListViews not implemented")
}
func (UnimplementedUserMgrServer) UpdateSegment(context.Context, *Segment) (*Segment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSegment not implemented")
}
func (UnimplementedUserMgrServer) CreateSegment(context.Context, *Segment) (*Segment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSegment not implemented")
}
func (UnimplementedUserMgrServer) DeleteSegment(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSegment not implemented")
}
func (UnimplementedUserMgrServer) GetSegment(context.Context, *Id) (*Segment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSegment not implemented")
}
func (UnimplementedUserMgrServer) ListSegments(context.Context, *Id) (*Segments, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSegments not implemented")
}
func (UnimplementedUserMgrServer) AddToSegment(context.Context, *SegmentUsers) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddToSegment not implemented")
}
func (UnimplementedUserMgrServer) RemoveFromSegment(context.Context, *SegmentUsers) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveFromSegment not implemented")
}
func (UnimplementedUserMgrServer) ListSegmentSyncs(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSegmentSyncs not implemented")
}
func (UnimplementedUserMgrServer) UpdateSegmentSync(context.Context, *SegmentSync) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSegmentSync not implemented")
}
func (UnimplementedUserMgrServer) GetSegmentSync(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSegmentSync not implemented")
}
func (UnimplementedUserMgrServer) CreateSegmentSync(context.Context, *SegmentSync) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSegmentSync not implemented")
}
func (UnimplementedUserMgrServer) DeleteSegmentSync(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSegmentSync not implemented")
}
func (UnimplementedUserMgrServer) MatchSegmentSyncs(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchSegmentSyncs not implemented")
}
func (UnimplementedUserMgrServer) CheckUserSegmentSyncStatus(context.Context, *UserSegmentSyncStatusCheck) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckUserSegmentSyncStatus not implemented")
}
func (UnimplementedUserMgrServer) UpsertLabel(context.Context, *Label) (*Label, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertLabel not implemented")
}
func (UnimplementedUserMgrServer) DeleteLabel(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLabel not implemented")
}
func (UnimplementedUserMgrServer) ListLabels(context.Context, *Id) (*Labels, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLabels not implemented")
}
func (UnimplementedUserMgrServer) GetLabel(context.Context, *Id) (*Label, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLabel not implemented")
}
func (UnimplementedUserMgrServer) AddLeadOwner(context.Context, *UserRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddLeadOwner not implemented")
}
func (UnimplementedUserMgrServer) RemoveLeadOwner(context.Context, *UserRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveLeadOwner not implemented")
}
func (UnimplementedUserMgrServer) AddUserLabel(context.Context, *UserRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUserLabel not implemented")
}
func (UnimplementedUserMgrServer) RemoveUserLabel(context.Context, *UserRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveUserLabel not implemented")
}
func (UnimplementedUserMgrServer) AddLeadConversionBy(context.Context, *UserRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddLeadConversionBy not implemented")
}
func (UnimplementedUserMgrServer) CreateShippingAddress(context.Context, *Address) (*Address, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateShippingAddress not implemented")
}
func (UnimplementedUserMgrServer) UpdateShippingAddress(context.Context, *Address) (*Address, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateShippingAddress not implemented")
}
func (UnimplementedUserMgrServer) RemoveShippingAddress(context.Context, *Address) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveShippingAddress not implemented")
}
func (UnimplementedUserMgrServer) ListShippingAddress(context.Context, *Id) (*ShippingAddresses, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListShippingAddress not implemented")
}
func (UnimplementedUserMgrServer) MakeDefaultShippingAddress(context.Context, *Address) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MakeDefaultShippingAddress not implemented")
}
func (UnimplementedUserMgrServer) ListLeads(context.Context, *UserView) (*Users, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLeads not implemented")
}
func (UnimplementedUserMgrServer) ListLeads2(context.Context, *UserView) (*Users, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLeads2 not implemented")
}
func (UnimplementedUserMgrServer) SuggestLeadField(context.Context, *SuggestLeadFieldRequest) (*SuggestLeadFieldResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SuggestLeadField not implemented")
}
func (UnimplementedUserMgrServer) LinkProductUrl(context.Context, *Product) (*Product, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LinkProductUrl not implemented")
}
func (UnimplementedUserMgrServer) ListUserEvents(context.Context, *ListUserEventsRequest) (*Events, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUserEvents not implemented")
}
func (UnimplementedUserMgrServer) CreateUserEvent(context.Context, *Event) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUserEvent not implemented")
}
func (UnimplementedUserMgrServer) FillDevice(context.Context, *common.Device) (*common.Device, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FillDevice not implemented")
}
func (UnimplementedUserMgrServer) ImportLead(context.Context, *ImportLeadRequest) (*ImportLeadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportLead not implemented")
}
func (UnimplementedUserMgrServer) LinkTask(context.Context, *Task) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LinkTask not implemented")
}
func (UnimplementedUserMgrServer) CountUserProfiles(context.Context, *UsersRequest) (*CountTouchpointResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountUserProfiles not implemented")
}
func (UnimplementedUserMgrServer) ListUserIds(context.Context, *UsersRequest) (*Ids, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUserIds not implemented")
}
func (UnimplementedUserMgrServer) ListUserIdWithPhones(context.Context, *UsersRequest) (*Users, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUserIdWithPhones not implemented")
}
func (UnimplementedUserMgrServer) SearchUsers(context.Context, *DocSearchRequest) (*DocSearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchUsers not implemented")
}
func (UnimplementedUserMgrServer) ReportUser(context.Context, *UserReportRequest) (*UserReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportUser not implemented")
}
func (UnimplementedUserMgrServer) FetchLiveUsers(context.Context, *LiveUserView) (*LiveUserView, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FetchLiveUsers not implemented")
}
func (UnimplementedUserMgrServer) StopLiveUsers(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopLiveUsers not implemented")
}
func (UnimplementedUserMgrServer) SuggestLiveFields(context.Context, *SuggestLeadFieldRequest) (*SuggestLeadFieldResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SuggestLiveFields not implemented")
}
func (UnimplementedUserMgrServer) Presences(context.Context, *PresencesRequest) (*PresencesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Presences not implemented")
}
func (UnimplementedUserMgrServer) UpdateSegmentMember(context.Context, *ResourceGroupMember) (*ResourceGroupMember, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSegmentMember not implemented")
}
func (UnimplementedUserMgrServer) RemoveSegmentMember(context.Context, *ResourceGroupMember) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveSegmentMember not implemented")
}
func (UnimplementedUserMgrServer) mustEmbedUnimplementedUserMgrServer() {}
func (UnimplementedUserMgrServer) testEmbeddedByValue()                 {}

// UnsafeUserMgrServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserMgrServer will
// result in compilation errors.
type UnsafeUserMgrServer interface {
	mustEmbedUnimplementedUserMgrServer()
}

func RegisterUserMgrServer(s grpc.ServiceRegistrar, srv UserMgrServer) {
	// If the following call pancis, it indicates UnimplementedUserMgrServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserMgr_ServiceDesc, srv)
}

func _UserMgr_MergeUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Users)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).MergeUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_MergeUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).MergeUser(ctx, req.(*Users))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_DetachUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).DetachUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_DetachUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).DetachUser(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_CreateUser2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).CreateUser2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_CreateUser2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).CreateUser2(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_UpdateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).UpdateUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_TryUpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).TryUpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_TryUpdateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).TryUpdateUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_RemoveUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).RemoveUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_RemoveUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).RemoveUser(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_RestoreUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).RestoreUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_RestoreUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).RestoreUser(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_ReadUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).ReadUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_ReadUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).ReadUser(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_ReadOrCreateUserByContactProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).ReadOrCreateUserByContactProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_ReadOrCreateUserByContactProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).ReadOrCreateUserByContactProfile(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_MatchUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).MatchUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_MatchUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).MatchUsers(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_BanUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).BanUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_BanUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).BanUser(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_UnbanUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).UnbanUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_UnbanUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).UnbanUser(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_LookupByPhone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).LookupByPhone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_LookupByPhone_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).LookupByPhone(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_UpdateView_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserView)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).UpdateView(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_UpdateView_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).UpdateView(ctx, req.(*UserView))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_CreateView_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserView)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).CreateView(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_CreateView_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).CreateView(ctx, req.(*UserView))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_DeleteView_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).DeleteView(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_DeleteView_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).DeleteView(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_GetView_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).GetView(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_GetView_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).GetView(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_ListViews_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).ListViews(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_ListViews_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).ListViews(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_UpdateSegment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Segment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).UpdateSegment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_UpdateSegment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).UpdateSegment(ctx, req.(*Segment))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_CreateSegment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Segment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).CreateSegment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_CreateSegment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).CreateSegment(ctx, req.(*Segment))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_DeleteSegment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).DeleteSegment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_DeleteSegment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).DeleteSegment(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_GetSegment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).GetSegment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_GetSegment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).GetSegment(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_ListSegments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).ListSegments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_ListSegments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).ListSegments(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_AddToSegment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SegmentUsers)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).AddToSegment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_AddToSegment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).AddToSegment(ctx, req.(*SegmentUsers))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_RemoveFromSegment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SegmentUsers)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).RemoveFromSegment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_RemoveFromSegment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).RemoveFromSegment(ctx, req.(*SegmentUsers))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_ListSegmentSyncs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).ListSegmentSyncs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_ListSegmentSyncs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).ListSegmentSyncs(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_UpdateSegmentSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SegmentSync)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).UpdateSegmentSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_UpdateSegmentSync_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).UpdateSegmentSync(ctx, req.(*SegmentSync))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_GetSegmentSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).GetSegmentSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_GetSegmentSync_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).GetSegmentSync(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_CreateSegmentSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SegmentSync)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).CreateSegmentSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_CreateSegmentSync_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).CreateSegmentSync(ctx, req.(*SegmentSync))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_DeleteSegmentSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).DeleteSegmentSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_DeleteSegmentSync_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).DeleteSegmentSync(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_MatchSegmentSyncs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).MatchSegmentSyncs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_MatchSegmentSyncs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).MatchSegmentSyncs(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_CheckUserSegmentSyncStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserSegmentSyncStatusCheck)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).CheckUserSegmentSyncStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_CheckUserSegmentSyncStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).CheckUserSegmentSyncStatus(ctx, req.(*UserSegmentSyncStatusCheck))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_UpsertLabel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Label)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).UpsertLabel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_UpsertLabel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).UpsertLabel(ctx, req.(*Label))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_DeleteLabel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).DeleteLabel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_DeleteLabel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).DeleteLabel(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_ListLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).ListLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_ListLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).ListLabels(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_GetLabel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).GetLabel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_GetLabel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).GetLabel(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_AddLeadOwner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).AddLeadOwner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_AddLeadOwner_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).AddLeadOwner(ctx, req.(*UserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_RemoveLeadOwner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).RemoveLeadOwner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_RemoveLeadOwner_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).RemoveLeadOwner(ctx, req.(*UserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_AddUserLabel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).AddUserLabel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_AddUserLabel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).AddUserLabel(ctx, req.(*UserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_RemoveUserLabel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).RemoveUserLabel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_RemoveUserLabel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).RemoveUserLabel(ctx, req.(*UserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_AddLeadConversionBy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).AddLeadConversionBy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_AddLeadConversionBy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).AddLeadConversionBy(ctx, req.(*UserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_CreateShippingAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Address)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).CreateShippingAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_CreateShippingAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).CreateShippingAddress(ctx, req.(*Address))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_UpdateShippingAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Address)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).UpdateShippingAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_UpdateShippingAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).UpdateShippingAddress(ctx, req.(*Address))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_RemoveShippingAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Address)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).RemoveShippingAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_RemoveShippingAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).RemoveShippingAddress(ctx, req.(*Address))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_ListShippingAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).ListShippingAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_ListShippingAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).ListShippingAddress(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_MakeDefaultShippingAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Address)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).MakeDefaultShippingAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_MakeDefaultShippingAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).MakeDefaultShippingAddress(ctx, req.(*Address))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_ListLeads_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserView)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).ListLeads(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_ListLeads_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).ListLeads(ctx, req.(*UserView))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_ListLeads2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserView)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).ListLeads2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_ListLeads2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).ListLeads2(ctx, req.(*UserView))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_SuggestLeadField_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuggestLeadFieldRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).SuggestLeadField(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_SuggestLeadField_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).SuggestLeadField(ctx, req.(*SuggestLeadFieldRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_LinkProductUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Product)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).LinkProductUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_LinkProductUrl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).LinkProductUrl(ctx, req.(*Product))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_ListUserEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).ListUserEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_ListUserEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).ListUserEvents(ctx, req.(*ListUserEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_CreateUserEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).CreateUserEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_CreateUserEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).CreateUserEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_FillDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).FillDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_FillDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).FillDevice(ctx, req.(*common.Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_ImportLead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportLeadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).ImportLead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_ImportLead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).ImportLead(ctx, req.(*ImportLeadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_LinkTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Task)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).LinkTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_LinkTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).LinkTask(ctx, req.(*Task))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_CountUserProfiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).CountUserProfiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_CountUserProfiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).CountUserProfiles(ctx, req.(*UsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_ListUserIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).ListUserIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_ListUserIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).ListUserIds(ctx, req.(*UsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_ListUserIdWithPhones_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).ListUserIdWithPhones(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_ListUserIdWithPhones_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).ListUserIdWithPhones(ctx, req.(*UsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_SearchUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).SearchUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_SearchUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).SearchUsers(ctx, req.(*DocSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_ReportUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).ReportUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_ReportUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).ReportUser(ctx, req.(*UserReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_FetchLiveUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LiveUserView)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).FetchLiveUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_FetchLiveUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).FetchLiveUsers(ctx, req.(*LiveUserView))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_StopLiveUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).StopLiveUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_StopLiveUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).StopLiveUsers(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_SuggestLiveFields_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuggestLeadFieldRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).SuggestLiveFields(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_SuggestLiveFields_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).SuggestLiveFields(ctx, req.(*SuggestLeadFieldRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_Presences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PresencesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).Presences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_Presences_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).Presences(ctx, req.(*PresencesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_UpdateSegmentMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceGroupMember)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).UpdateSegmentMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_UpdateSegmentMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).UpdateSegmentMember(ctx, req.(*ResourceGroupMember))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_RemoveSegmentMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceGroupMember)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).RemoveSegmentMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMgr_RemoveSegmentMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).RemoveSegmentMember(ctx, req.(*ResourceGroupMember))
	}
	return interceptor(ctx, in, info, handler)
}

// UserMgr_ServiceDesc is the grpc.ServiceDesc for UserMgr service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserMgr_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.UserMgr",
	HandlerType: (*UserMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MergeUser",
			Handler:    _UserMgr_MergeUser_Handler,
		},
		{
			MethodName: "DetachUser",
			Handler:    _UserMgr_DetachUser_Handler,
		},
		{
			MethodName: "CreateUser2",
			Handler:    _UserMgr_CreateUser2_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _UserMgr_UpdateUser_Handler,
		},
		{
			MethodName: "TryUpdateUser",
			Handler:    _UserMgr_TryUpdateUser_Handler,
		},
		{
			MethodName: "RemoveUser",
			Handler:    _UserMgr_RemoveUser_Handler,
		},
		{
			MethodName: "RestoreUser",
			Handler:    _UserMgr_RestoreUser_Handler,
		},
		{
			MethodName: "ReadUser",
			Handler:    _UserMgr_ReadUser_Handler,
		},
		{
			MethodName: "ReadOrCreateUserByContactProfile",
			Handler:    _UserMgr_ReadOrCreateUserByContactProfile_Handler,
		},
		{
			MethodName: "MatchUsers",
			Handler:    _UserMgr_MatchUsers_Handler,
		},
		{
			MethodName: "BanUser",
			Handler:    _UserMgr_BanUser_Handler,
		},
		{
			MethodName: "UnbanUser",
			Handler:    _UserMgr_UnbanUser_Handler,
		},
		{
			MethodName: "LookupByPhone",
			Handler:    _UserMgr_LookupByPhone_Handler,
		},
		{
			MethodName: "UpdateView",
			Handler:    _UserMgr_UpdateView_Handler,
		},
		{
			MethodName: "CreateView",
			Handler:    _UserMgr_CreateView_Handler,
		},
		{
			MethodName: "DeleteView",
			Handler:    _UserMgr_DeleteView_Handler,
		},
		{
			MethodName: "GetView",
			Handler:    _UserMgr_GetView_Handler,
		},
		{
			MethodName: "ListViews",
			Handler:    _UserMgr_ListViews_Handler,
		},
		{
			MethodName: "UpdateSegment",
			Handler:    _UserMgr_UpdateSegment_Handler,
		},
		{
			MethodName: "CreateSegment",
			Handler:    _UserMgr_CreateSegment_Handler,
		},
		{
			MethodName: "DeleteSegment",
			Handler:    _UserMgr_DeleteSegment_Handler,
		},
		{
			MethodName: "GetSegment",
			Handler:    _UserMgr_GetSegment_Handler,
		},
		{
			MethodName: "ListSegments",
			Handler:    _UserMgr_ListSegments_Handler,
		},
		{
			MethodName: "AddToSegment",
			Handler:    _UserMgr_AddToSegment_Handler,
		},
		{
			MethodName: "RemoveFromSegment",
			Handler:    _UserMgr_RemoveFromSegment_Handler,
		},
		{
			MethodName: "ListSegmentSyncs",
			Handler:    _UserMgr_ListSegmentSyncs_Handler,
		},
		{
			MethodName: "UpdateSegmentSync",
			Handler:    _UserMgr_UpdateSegmentSync_Handler,
		},
		{
			MethodName: "GetSegmentSync",
			Handler:    _UserMgr_GetSegmentSync_Handler,
		},
		{
			MethodName: "CreateSegmentSync",
			Handler:    _UserMgr_CreateSegmentSync_Handler,
		},
		{
			MethodName: "DeleteSegmentSync",
			Handler:    _UserMgr_DeleteSegmentSync_Handler,
		},
		{
			MethodName: "MatchSegmentSyncs",
			Handler:    _UserMgr_MatchSegmentSyncs_Handler,
		},
		{
			MethodName: "CheckUserSegmentSyncStatus",
			Handler:    _UserMgr_CheckUserSegmentSyncStatus_Handler,
		},
		{
			MethodName: "UpsertLabel",
			Handler:    _UserMgr_UpsertLabel_Handler,
		},
		{
			MethodName: "DeleteLabel",
			Handler:    _UserMgr_DeleteLabel_Handler,
		},
		{
			MethodName: "ListLabels",
			Handler:    _UserMgr_ListLabels_Handler,
		},
		{
			MethodName: "GetLabel",
			Handler:    _UserMgr_GetLabel_Handler,
		},
		{
			MethodName: "AddLeadOwner",
			Handler:    _UserMgr_AddLeadOwner_Handler,
		},
		{
			MethodName: "RemoveLeadOwner",
			Handler:    _UserMgr_RemoveLeadOwner_Handler,
		},
		{
			MethodName: "AddUserLabel",
			Handler:    _UserMgr_AddUserLabel_Handler,
		},
		{
			MethodName: "RemoveUserLabel",
			Handler:    _UserMgr_RemoveUserLabel_Handler,
		},
		{
			MethodName: "AddLeadConversionBy",
			Handler:    _UserMgr_AddLeadConversionBy_Handler,
		},
		{
			MethodName: "CreateShippingAddress",
			Handler:    _UserMgr_CreateShippingAddress_Handler,
		},
		{
			MethodName: "UpdateShippingAddress",
			Handler:    _UserMgr_UpdateShippingAddress_Handler,
		},
		{
			MethodName: "RemoveShippingAddress",
			Handler:    _UserMgr_RemoveShippingAddress_Handler,
		},
		{
			MethodName: "ListShippingAddress",
			Handler:    _UserMgr_ListShippingAddress_Handler,
		},
		{
			MethodName: "MakeDefaultShippingAddress",
			Handler:    _UserMgr_MakeDefaultShippingAddress_Handler,
		},
		{
			MethodName: "ListLeads",
			Handler:    _UserMgr_ListLeads_Handler,
		},
		{
			MethodName: "ListLeads2",
			Handler:    _UserMgr_ListLeads2_Handler,
		},
		{
			MethodName: "SuggestLeadField",
			Handler:    _UserMgr_SuggestLeadField_Handler,
		},
		{
			MethodName: "LinkProductUrl",
			Handler:    _UserMgr_LinkProductUrl_Handler,
		},
		{
			MethodName: "ListUserEvents",
			Handler:    _UserMgr_ListUserEvents_Handler,
		},
		{
			MethodName: "CreateUserEvent",
			Handler:    _UserMgr_CreateUserEvent_Handler,
		},
		{
			MethodName: "FillDevice",
			Handler:    _UserMgr_FillDevice_Handler,
		},
		{
			MethodName: "ImportLead",
			Handler:    _UserMgr_ImportLead_Handler,
		},
		{
			MethodName: "LinkTask",
			Handler:    _UserMgr_LinkTask_Handler,
		},
		{
			MethodName: "CountUserProfiles",
			Handler:    _UserMgr_CountUserProfiles_Handler,
		},
		{
			MethodName: "ListUserIds",
			Handler:    _UserMgr_ListUserIds_Handler,
		},
		{
			MethodName: "ListUserIdWithPhones",
			Handler:    _UserMgr_ListUserIdWithPhones_Handler,
		},
		{
			MethodName: "SearchUsers",
			Handler:    _UserMgr_SearchUsers_Handler,
		},
		{
			MethodName: "ReportUser",
			Handler:    _UserMgr_ReportUser_Handler,
		},
		{
			MethodName: "FetchLiveUsers",
			Handler:    _UserMgr_FetchLiveUsers_Handler,
		},
		{
			MethodName: "StopLiveUsers",
			Handler:    _UserMgr_StopLiveUsers_Handler,
		},
		{
			MethodName: "SuggestLiveFields",
			Handler:    _UserMgr_SuggestLiveFields_Handler,
		},
		{
			MethodName: "Presences",
			Handler:    _UserMgr_Presences_Handler,
		},
		{
			MethodName: "UpdateSegmentMember",
			Handler:    _UserMgr_UpdateSegmentMember_Handler,
		},
		{
			MethodName: "RemoveSegmentMember",
			Handler:    _UserMgr_RemoveSegmentMember_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	NoteMgr_ListNotes_FullMethodName  = "/header.NoteMgr/ListNotes"
	NoteMgr_AddNote_FullMethodName    = "/header.NoteMgr/AddNote"
	NoteMgr_UpdateNote_FullMethodName = "/header.NoteMgr/UpdateNote"
	NoteMgr_DeleteNote_FullMethodName = "/header.NoteMgr/DeleteNote"
)

// NoteMgrClient is the client API for NoteMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NoteMgrClient interface {
	ListNotes(ctx context.Context, in *ListNotesRequest, opts ...grpc.CallOption) (*Notes, error)
	AddNote(ctx context.Context, in *Note, opts ...grpc.CallOption) (*Note, error)
	UpdateNote(ctx context.Context, in *Note, opts ...grpc.CallOption) (*Note, error)
	DeleteNote(ctx context.Context, in *DeleteNoteRequest, opts ...grpc.CallOption) (*Empty, error)
}

type noteMgrClient struct {
	cc grpc.ClientConnInterface
}

func NewNoteMgrClient(cc grpc.ClientConnInterface) NoteMgrClient {
	return &noteMgrClient{cc}
}

func (c *noteMgrClient) ListNotes(ctx context.Context, in *ListNotesRequest, opts ...grpc.CallOption) (*Notes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Notes)
	err := c.cc.Invoke(ctx, NoteMgr_ListNotes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *noteMgrClient) AddNote(ctx context.Context, in *Note, opts ...grpc.CallOption) (*Note, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Note)
	err := c.cc.Invoke(ctx, NoteMgr_AddNote_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *noteMgrClient) UpdateNote(ctx context.Context, in *Note, opts ...grpc.CallOption) (*Note, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Note)
	err := c.cc.Invoke(ctx, NoteMgr_UpdateNote_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *noteMgrClient) DeleteNote(ctx context.Context, in *DeleteNoteRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, NoteMgr_DeleteNote_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NoteMgrServer is the server API for NoteMgr service.
// All implementations must embed UnimplementedNoteMgrServer
// for forward compatibility.
type NoteMgrServer interface {
	ListNotes(context.Context, *ListNotesRequest) (*Notes, error)
	AddNote(context.Context, *Note) (*Note, error)
	UpdateNote(context.Context, *Note) (*Note, error)
	DeleteNote(context.Context, *DeleteNoteRequest) (*Empty, error)
	mustEmbedUnimplementedNoteMgrServer()
}

// UnimplementedNoteMgrServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNoteMgrServer struct{}

func (UnimplementedNoteMgrServer) ListNotes(context.Context, *ListNotesRequest) (*Notes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNotes not implemented")
}
func (UnimplementedNoteMgrServer) AddNote(context.Context, *Note) (*Note, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddNote not implemented")
}
func (UnimplementedNoteMgrServer) UpdateNote(context.Context, *Note) (*Note, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNote not implemented")
}
func (UnimplementedNoteMgrServer) DeleteNote(context.Context, *DeleteNoteRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNote not implemented")
}
func (UnimplementedNoteMgrServer) mustEmbedUnimplementedNoteMgrServer() {}
func (UnimplementedNoteMgrServer) testEmbeddedByValue()                 {}

// UnsafeNoteMgrServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NoteMgrServer will
// result in compilation errors.
type UnsafeNoteMgrServer interface {
	mustEmbedUnimplementedNoteMgrServer()
}

func RegisterNoteMgrServer(s grpc.ServiceRegistrar, srv NoteMgrServer) {
	// If the following call pancis, it indicates UnimplementedNoteMgrServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NoteMgr_ServiceDesc, srv)
}

func _NoteMgr_ListNotes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNotesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NoteMgrServer).ListNotes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NoteMgr_ListNotes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NoteMgrServer).ListNotes(ctx, req.(*ListNotesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NoteMgr_AddNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Note)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NoteMgrServer).AddNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NoteMgr_AddNote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NoteMgrServer).AddNote(ctx, req.(*Note))
	}
	return interceptor(ctx, in, info, handler)
}

func _NoteMgr_UpdateNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Note)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NoteMgrServer).UpdateNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NoteMgr_UpdateNote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NoteMgrServer).UpdateNote(ctx, req.(*Note))
	}
	return interceptor(ctx, in, info, handler)
}

func _NoteMgr_DeleteNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NoteMgrServer).DeleteNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NoteMgr_DeleteNote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NoteMgrServer).DeleteNote(ctx, req.(*DeleteNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NoteMgr_ServiceDesc is the grpc.ServiceDesc for NoteMgr service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NoteMgr_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.NoteMgr",
	HandlerType: (*NoteMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListNotes",
			Handler:    _NoteMgr_ListNotes_Handler,
		},
		{
			MethodName: "AddNote",
			Handler:    _NoteMgr_AddNote_Handler,
		},
		{
			MethodName: "UpdateNote",
			Handler:    _NoteMgr_UpdateNote_Handler,
		},
		{
			MethodName: "DeleteNote",
			Handler:    _NoteMgr_DeleteNote_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	AttributeMgr_ListAttributeDefinitions_FullMethodName  = "/header.AttributeMgr/ListAttributeDefinitions"
	AttributeMgr_ListAttributeDefinitions2_FullMethodName = "/header.AttributeMgr/ListAttributeDefinitions2"
	AttributeMgr_CreateAttributeDefinition_FullMethodName = "/header.AttributeMgr/CreateAttributeDefinition"
	AttributeMgr_UpdateAttributeDefinition_FullMethodName = "/header.AttributeMgr/UpdateAttributeDefinition"
)

// AttributeMgrClient is the client API for AttributeMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AttributeMgrClient interface {
	ListAttributeDefinitions(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AttributeDefinitions, error)
	ListAttributeDefinitions2(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	CreateAttributeDefinition(ctx context.Context, in *AttributeDefinition, opts ...grpc.CallOption) (*AttributeDefinition, error)
	UpdateAttributeDefinition(ctx context.Context, in *AttributeDefinition, opts ...grpc.CallOption) (*AttributeDefinition, error)
}

type attributeMgrClient struct {
	cc grpc.ClientConnInterface
}

func NewAttributeMgrClient(cc grpc.ClientConnInterface) AttributeMgrClient {
	return &attributeMgrClient{cc}
}

func (c *attributeMgrClient) ListAttributeDefinitions(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AttributeDefinitions, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AttributeDefinitions)
	err := c.cc.Invoke(ctx, AttributeMgr_ListAttributeDefinitions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *attributeMgrClient) ListAttributeDefinitions2(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AttributeMgr_ListAttributeDefinitions2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *attributeMgrClient) CreateAttributeDefinition(ctx context.Context, in *AttributeDefinition, opts ...grpc.CallOption) (*AttributeDefinition, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AttributeDefinition)
	err := c.cc.Invoke(ctx, AttributeMgr_CreateAttributeDefinition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *attributeMgrClient) UpdateAttributeDefinition(ctx context.Context, in *AttributeDefinition, opts ...grpc.CallOption) (*AttributeDefinition, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AttributeDefinition)
	err := c.cc.Invoke(ctx, AttributeMgr_UpdateAttributeDefinition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AttributeMgrServer is the server API for AttributeMgr service.
// All implementations must embed UnimplementedAttributeMgrServer
// for forward compatibility.
type AttributeMgrServer interface {
	ListAttributeDefinitions(context.Context, *Empty) (*AttributeDefinitions, error)
	ListAttributeDefinitions2(context.Context, *Id) (*Response, error)
	CreateAttributeDefinition(context.Context, *AttributeDefinition) (*AttributeDefinition, error)
	UpdateAttributeDefinition(context.Context, *AttributeDefinition) (*AttributeDefinition, error)
	mustEmbedUnimplementedAttributeMgrServer()
}

// UnimplementedAttributeMgrServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAttributeMgrServer struct{}

func (UnimplementedAttributeMgrServer) ListAttributeDefinitions(context.Context, *Empty) (*AttributeDefinitions, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAttributeDefinitions not implemented")
}
func (UnimplementedAttributeMgrServer) ListAttributeDefinitions2(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAttributeDefinitions2 not implemented")
}
func (UnimplementedAttributeMgrServer) CreateAttributeDefinition(context.Context, *AttributeDefinition) (*AttributeDefinition, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAttributeDefinition not implemented")
}
func (UnimplementedAttributeMgrServer) UpdateAttributeDefinition(context.Context, *AttributeDefinition) (*AttributeDefinition, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAttributeDefinition not implemented")
}
func (UnimplementedAttributeMgrServer) mustEmbedUnimplementedAttributeMgrServer() {}
func (UnimplementedAttributeMgrServer) testEmbeddedByValue()                      {}

// UnsafeAttributeMgrServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AttributeMgrServer will
// result in compilation errors.
type UnsafeAttributeMgrServer interface {
	mustEmbedUnimplementedAttributeMgrServer()
}

func RegisterAttributeMgrServer(s grpc.ServiceRegistrar, srv AttributeMgrServer) {
	// If the following call pancis, it indicates UnimplementedAttributeMgrServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AttributeMgr_ServiceDesc, srv)
}

func _AttributeMgr_ListAttributeDefinitions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttributeMgrServer).ListAttributeDefinitions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AttributeMgr_ListAttributeDefinitions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttributeMgrServer).ListAttributeDefinitions(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AttributeMgr_ListAttributeDefinitions2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttributeMgrServer).ListAttributeDefinitions2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AttributeMgr_ListAttributeDefinitions2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttributeMgrServer).ListAttributeDefinitions2(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AttributeMgr_CreateAttributeDefinition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttributeDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttributeMgrServer).CreateAttributeDefinition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AttributeMgr_CreateAttributeDefinition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttributeMgrServer).CreateAttributeDefinition(ctx, req.(*AttributeDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _AttributeMgr_UpdateAttributeDefinition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttributeDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttributeMgrServer).UpdateAttributeDefinition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AttributeMgr_UpdateAttributeDefinition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttributeMgrServer).UpdateAttributeDefinition(ctx, req.(*AttributeDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

// AttributeMgr_ServiceDesc is the grpc.ServiceDesc for AttributeMgr service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AttributeMgr_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.AttributeMgr",
	HandlerType: (*AttributeMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListAttributeDefinitions",
			Handler:    _AttributeMgr_ListAttributeDefinitions_Handler,
		},
		{
			MethodName: "ListAttributeDefinitions2",
			Handler:    _AttributeMgr_ListAttributeDefinitions2_Handler,
		},
		{
			MethodName: "CreateAttributeDefinition",
			Handler:    _AttributeMgr_CreateAttributeDefinition_Handler,
		},
		{
			MethodName: "UpdateAttributeDefinition",
			Handler:    _AttributeMgr_UpdateAttributeDefinition_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	WorkflowMgr_ListWorkflows_FullMethodName          = "/header.WorkflowMgr/ListWorkflows"
	WorkflowMgr_UpdateWorkflow_FullMethodName         = "/header.WorkflowMgr/UpdateWorkflow"
	WorkflowMgr_CreateWorkflow_FullMethodName         = "/header.WorkflowMgr/CreateWorkflow"
	WorkflowMgr_DeleteWorkflow_FullMethodName         = "/header.WorkflowMgr/DeleteWorkflow"
	WorkflowMgr_GetWorkflow_FullMethodName            = "/header.WorkflowMgr/GetWorkflow"
	WorkflowMgr_ListWorkflowVersions_FullMethodName   = "/header.WorkflowMgr/ListWorkflowVersions"
	WorkflowMgr_StartWorkflowSession_FullMethodName   = "/header.WorkflowMgr/StartWorkflowSession"
	WorkflowMgr_MatchWorkflows_FullMethodName         = "/header.WorkflowMgr/MatchWorkflows"
	WorkflowMgr_PumpWorkflowSession_FullMethodName    = "/header.WorkflowMgr/PumpWorkflowSession"
	WorkflowMgr_GetWorkflowSession_FullMethodName     = "/header.WorkflowMgr/GetWorkflowSession"
	WorkflowMgr_UpdateWorkflowSession_FullMethodName  = "/header.WorkflowMgr/UpdateWorkflowSession"
	WorkflowMgr_ListWorkflowSessions_FullMethodName   = "/header.WorkflowMgr/ListWorkflowSessions"
	WorkflowMgr_ListRelatedSessions_FullMethodName    = "/header.WorkflowMgr/ListRelatedSessions"
	WorkflowMgr_ListWorkflowLogs_FullMethodName       = "/header.WorkflowMgr/ListWorkflowLogs"
	WorkflowMgr_ReportWorkflow_FullMethodName         = "/header.WorkflowMgr/ReportWorkflow"
	WorkflowMgr_RunWorkflowAction_FullMethodName      = "/header.WorkflowMgr/RunWorkflowAction"
	WorkflowMgr_ListAIAgents_FullMethodName           = "/header.WorkflowMgr/ListAIAgents"
	WorkflowMgr_CreateAIAgent_FullMethodName          = "/header.WorkflowMgr/CreateAIAgent"
	WorkflowMgr_UpdateAIAgent_FullMethodName          = "/header.WorkflowMgr/UpdateAIAgent"
	WorkflowMgr_GetAIAgent_FullMethodName             = "/header.WorkflowMgr/GetAIAgent"
	WorkflowMgr_MatchAIAgent_FullMethodName           = "/header.WorkflowMgr/MatchAIAgent"
	WorkflowMgr_DeleteAIAgent_FullMethodName          = "/header.WorkflowMgr/DeleteAIAgent"
	WorkflowMgr_StartAiAgent_FullMethodName           = "/header.WorkflowMgr/StartAiAgent"
	WorkflowMgr_StopAIAgent_FullMethodName            = "/header.WorkflowMgr/StopAIAgent"
	WorkflowMgr_DeleteAIAgentDataEntry_FullMethodName = "/header.WorkflowMgr/DeleteAIAgentDataEntry"
	WorkflowMgr_AddAIAgentDataEntry_FullMethodName    = "/header.WorkflowMgr/AddAIAgentDataEntry"
	WorkflowMgr_ListAIDataGroup_FullMethodName        = "/header.WorkflowMgr/ListAIDataGroup"
	WorkflowMgr_SuggestAIDataEntry_FullMethodName     = "/header.WorkflowMgr/SuggestAIDataEntry"
	WorkflowMgr_CreateAIDataGroup_FullMethodName      = "/header.WorkflowMgr/CreateAIDataGroup"
	WorkflowMgr_UpdateAIDataGroup_FullMethodName      = "/header.WorkflowMgr/UpdateAIDataGroup"
	WorkflowMgr_DeleteAIDatagroup_FullMethodName      = "/header.WorkflowMgr/DeleteAIDatagroup"
	WorkflowMgr_CreateAIDataEntry_FullMethodName      = "/header.WorkflowMgr/CreateAIDataEntry"
	WorkflowMgr_ListAIDataEntry_FullMethodName        = "/header.WorkflowMgr/ListAIDataEntry"
	WorkflowMgr_GetAIDataEntry_FullMethodName         = "/header.WorkflowMgr/GetAIDataEntry"
	WorkflowMgr_UpdateAIDataEntry_FullMethodName      = "/header.WorkflowMgr/UpdateAIDataEntry"
	WorkflowMgr_ListAIDataEntryChunks_FullMethodName  = "/header.WorkflowMgr/ListAIDataEntryChunks"
	WorkflowMgr_RetrainAIDataEntry_FullMethodName     = "/header.WorkflowMgr/RetrainAIDataEntry"
	WorkflowMgr_DeleteAIDataEntry_FullMethodName      = "/header.WorkflowMgr/DeleteAIDataEntry"
	WorkflowMgr_MatchDataEntries_FullMethodName       = "/header.WorkflowMgr/MatchDataEntries"
	WorkflowMgr_ListAIAgentSpans_FullMethodName       = "/header.WorkflowMgr/ListAIAgentSpans"
	WorkflowMgr_ListAIAgentTraces_FullMethodName      = "/header.WorkflowMgr/ListAIAgentTraces"
	WorkflowMgr_ReportAIAgent_FullMethodName          = "/header.WorkflowMgr/ReportAIAgent"
	WorkflowMgr_TryWorkflowAction_FullMethodName      = "/header.WorkflowMgr/TryWorkflowAction"
	WorkflowMgr_ListAIAgentMessages_FullMethodName    = "/header.WorkflowMgr/ListAIAgentMessages"
	WorkflowMgr_ListConvertedLeads_FullMethodName     = "/header.WorkflowMgr/ListConvertedLeads"
	WorkflowMgr_GetAIResponseTrace_FullMethodName     = "/header.WorkflowMgr/GetAIResponseTrace"
	WorkflowMgr_ListNamedEntities_FullMethodName      = "/header.WorkflowMgr/ListNamedEntities"
	WorkflowMgr_CreateNamedEntity_FullMethodName      = "/header.WorkflowMgr/CreateNamedEntity"
	WorkflowMgr_UpdateNamedEntity_FullMethodName      = "/header.WorkflowMgr/UpdateNamedEntity"
	WorkflowMgr_GetNamedEntity_FullMethodName         = "/header.WorkflowMgr/GetNamedEntity"
	WorkflowMgr_MatchNamedEntities_FullMethodName     = "/header.WorkflowMgr/MatchNamedEntities"
)

// WorkflowMgrClient is the client API for WorkflowMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WorkflowMgrClient interface {
	ListWorkflows(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	UpdateWorkflow(ctx context.Context, in *Workflow, opts ...grpc.CallOption) (*Response, error)
	CreateWorkflow(ctx context.Context, in *Workflow, opts ...grpc.CallOption) (*Response, error)
	DeleteWorkflow(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	GetWorkflow(ctx context.Context, in *Workflow, opts ...grpc.CallOption) (*Response, error)
	ListWorkflowVersions(ctx context.Context, in *ListVersions, opts ...grpc.CallOption) (*Response, error)
	StartWorkflowSession(ctx context.Context, in *StartWorkflowSessionRequest, opts ...grpc.CallOption) (*Response, error)
	MatchWorkflows(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
	PumpWorkflowSession(ctx context.Context, in *WorkflowPulse, opts ...grpc.CallOption) (*Response, error)
	GetWorkflowSession(ctx context.Context, in *WorkflowSessionId, opts ...grpc.CallOption) (*Response, error)
	UpdateWorkflowSession(ctx context.Context, in *UpdateWorkflowSessionRequest, opts ...grpc.CallOption) (*Response, error)
	ListWorkflowSessions(ctx context.Context, in *ListWorkflowSessionRequest, opts ...grpc.CallOption) (*Response, error)
	ListRelatedSessions(ctx context.Context, in *ListWorkflowLogRequest, opts ...grpc.CallOption) (*Response, error)
	ListWorkflowLogs(ctx context.Context, in *ListWorkflowLogRequest, opts ...grpc.CallOption) (*Response, error)
	ReportWorkflow(ctx context.Context, in *WorkflowReportRequest, opts ...grpc.CallOption) (*Response, error)
	RunWorkflowAction(ctx context.Context, in *RunWorkflowActionRequest, opts ...grpc.CallOption) (*Response, error)
	ListAIAgents(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	CreateAIAgent(ctx context.Context, in *AIAgent, opts ...grpc.CallOption) (*Response, error)
	UpdateAIAgent(ctx context.Context, in *AIAgent, opts ...grpc.CallOption) (*Response, error)
	GetAIAgent(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	MatchAIAgent(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
	DeleteAIAgent(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	StartAiAgent(ctx context.Context, in *RunAiAgentRequest, opts ...grpc.CallOption) (*Empty, error)
	StopAIAgent(ctx context.Context, in *RunAiAgentRequest, opts ...grpc.CallOption) (*Empty, error)
	DeleteAIAgentDataEntry(ctx context.Context, in *AIAgentDataEntryRequest, opts ...grpc.CallOption) (*Response, error)
	AddAIAgentDataEntry(ctx context.Context, in *AIAgentDataEntryRequest, opts ...grpc.CallOption) (*Response, error)
	ListAIDataGroup(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	SuggestAIDataEntry(ctx context.Context, in *SuggestAIDataEntryRequest, opts ...grpc.CallOption) (*Response, error)
	CreateAIDataGroup(ctx context.Context, in *AIDataGroup, opts ...grpc.CallOption) (*Response, error)
	UpdateAIDataGroup(ctx context.Context, in *AIDataGroup, opts ...grpc.CallOption) (*Response, error)
	DeleteAIDatagroup(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	CreateAIDataEntry(ctx context.Context, in *AIDataEntry, opts ...grpc.CallOption) (*Response, error)
	ListAIDataEntry(ctx context.Context, in *ListAIDataEntryRequest, opts ...grpc.CallOption) (*Response, error)
	GetAIDataEntry(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	UpdateAIDataEntry(ctx context.Context, in *AIDataEntry, opts ...grpc.CallOption) (*Response, error)
	ListAIDataEntryChunks(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	RetrainAIDataEntry(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	DeleteAIDataEntry(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	MatchDataEntries(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
	ListAIAgentSpans(ctx context.Context, in *LLMSpansRequest, opts ...grpc.CallOption) (*Response, error)
	ListAIAgentTraces(ctx context.Context, in *LLMTracesRequest, opts ...grpc.CallOption) (*Response, error)
	ReportAIAgent(ctx context.Context, in *ReportAIAgentRequest, opts ...grpc.CallOption) (*AIAgentReportResponse, error)
	TryWorkflowAction(ctx context.Context, in *StartWorkflowSessionRequest, opts ...grpc.CallOption) (*Empty, error)
	ListAIAgentMessages(ctx context.Context, in *ListAIAgentMessageRequest, opts ...grpc.CallOption) (*Response, error)
	ListConvertedLeads(ctx context.Context, in *ReportAIAgentRequest, opts ...grpc.CallOption) (*Response, error)
	GetAIResponseTrace(ctx context.Context, in *AIAgentTraceRequest, opts ...grpc.CallOption) (*Response, error)
	ListNamedEntities(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	CreateNamedEntity(ctx context.Context, in *NamedEntity, opts ...grpc.CallOption) (*Response, error)
	UpdateNamedEntity(ctx context.Context, in *NamedEntity, opts ...grpc.CallOption) (*Response, error)
	GetNamedEntity(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	MatchNamedEntities(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
}

type workflowMgrClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkflowMgrClient(cc grpc.ClientConnInterface) WorkflowMgrClient {
	return &workflowMgrClient{cc}
}

func (c *workflowMgrClient) ListWorkflows(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_ListWorkflows_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) UpdateWorkflow(ctx context.Context, in *Workflow, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_UpdateWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) CreateWorkflow(ctx context.Context, in *Workflow, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_CreateWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) DeleteWorkflow(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_DeleteWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) GetWorkflow(ctx context.Context, in *Workflow, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_GetWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) ListWorkflowVersions(ctx context.Context, in *ListVersions, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_ListWorkflowVersions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) StartWorkflowSession(ctx context.Context, in *StartWorkflowSessionRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_StartWorkflowSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) MatchWorkflows(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_MatchWorkflows_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) PumpWorkflowSession(ctx context.Context, in *WorkflowPulse, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_PumpWorkflowSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) GetWorkflowSession(ctx context.Context, in *WorkflowSessionId, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_GetWorkflowSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) UpdateWorkflowSession(ctx context.Context, in *UpdateWorkflowSessionRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_UpdateWorkflowSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) ListWorkflowSessions(ctx context.Context, in *ListWorkflowSessionRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_ListWorkflowSessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) ListRelatedSessions(ctx context.Context, in *ListWorkflowLogRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_ListRelatedSessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) ListWorkflowLogs(ctx context.Context, in *ListWorkflowLogRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_ListWorkflowLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) ReportWorkflow(ctx context.Context, in *WorkflowReportRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_ReportWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) RunWorkflowAction(ctx context.Context, in *RunWorkflowActionRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_RunWorkflowAction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) ListAIAgents(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_ListAIAgents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) CreateAIAgent(ctx context.Context, in *AIAgent, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_CreateAIAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) UpdateAIAgent(ctx context.Context, in *AIAgent, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_UpdateAIAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) GetAIAgent(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_GetAIAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) MatchAIAgent(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_MatchAIAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) DeleteAIAgent(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_DeleteAIAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) StartAiAgent(ctx context.Context, in *RunAiAgentRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, WorkflowMgr_StartAiAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) StopAIAgent(ctx context.Context, in *RunAiAgentRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, WorkflowMgr_StopAIAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) DeleteAIAgentDataEntry(ctx context.Context, in *AIAgentDataEntryRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_DeleteAIAgentDataEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) AddAIAgentDataEntry(ctx context.Context, in *AIAgentDataEntryRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_AddAIAgentDataEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) ListAIDataGroup(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_ListAIDataGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) SuggestAIDataEntry(ctx context.Context, in *SuggestAIDataEntryRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_SuggestAIDataEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) CreateAIDataGroup(ctx context.Context, in *AIDataGroup, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_CreateAIDataGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) UpdateAIDataGroup(ctx context.Context, in *AIDataGroup, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_UpdateAIDataGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) DeleteAIDatagroup(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, WorkflowMgr_DeleteAIDatagroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) CreateAIDataEntry(ctx context.Context, in *AIDataEntry, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_CreateAIDataEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) ListAIDataEntry(ctx context.Context, in *ListAIDataEntryRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_ListAIDataEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) GetAIDataEntry(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_GetAIDataEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) UpdateAIDataEntry(ctx context.Context, in *AIDataEntry, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_UpdateAIDataEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) ListAIDataEntryChunks(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_ListAIDataEntryChunks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) RetrainAIDataEntry(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_RetrainAIDataEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) DeleteAIDataEntry(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, WorkflowMgr_DeleteAIDataEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) MatchDataEntries(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_MatchDataEntries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) ListAIAgentSpans(ctx context.Context, in *LLMSpansRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_ListAIAgentSpans_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) ListAIAgentTraces(ctx context.Context, in *LLMTracesRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_ListAIAgentTraces_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) ReportAIAgent(ctx context.Context, in *ReportAIAgentRequest, opts ...grpc.CallOption) (*AIAgentReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AIAgentReportResponse)
	err := c.cc.Invoke(ctx, WorkflowMgr_ReportAIAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) TryWorkflowAction(ctx context.Context, in *StartWorkflowSessionRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, WorkflowMgr_TryWorkflowAction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) ListAIAgentMessages(ctx context.Context, in *ListAIAgentMessageRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_ListAIAgentMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) ListConvertedLeads(ctx context.Context, in *ReportAIAgentRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_ListConvertedLeads_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) GetAIResponseTrace(ctx context.Context, in *AIAgentTraceRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_GetAIResponseTrace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) ListNamedEntities(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_ListNamedEntities_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) CreateNamedEntity(ctx context.Context, in *NamedEntity, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_CreateNamedEntity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) UpdateNamedEntity(ctx context.Context, in *NamedEntity, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_UpdateNamedEntity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) GetNamedEntity(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_GetNamedEntity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowMgrClient) MatchNamedEntities(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WorkflowMgr_MatchNamedEntities_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkflowMgrServer is the server API for WorkflowMgr service.
// All implementations must embed UnimplementedWorkflowMgrServer
// for forward compatibility.
type WorkflowMgrServer interface {
	ListWorkflows(context.Context, *Id) (*Response, error)
	UpdateWorkflow(context.Context, *Workflow) (*Response, error)
	CreateWorkflow(context.Context, *Workflow) (*Response, error)
	DeleteWorkflow(context.Context, *Id) (*Response, error)
	GetWorkflow(context.Context, *Workflow) (*Response, error)
	ListWorkflowVersions(context.Context, *ListVersions) (*Response, error)
	StartWorkflowSession(context.Context, *StartWorkflowSessionRequest) (*Response, error)
	MatchWorkflows(context.Context, *Ids) (*Response, error)
	PumpWorkflowSession(context.Context, *WorkflowPulse) (*Response, error)
	GetWorkflowSession(context.Context, *WorkflowSessionId) (*Response, error)
	UpdateWorkflowSession(context.Context, *UpdateWorkflowSessionRequest) (*Response, error)
	ListWorkflowSessions(context.Context, *ListWorkflowSessionRequest) (*Response, error)
	ListRelatedSessions(context.Context, *ListWorkflowLogRequest) (*Response, error)
	ListWorkflowLogs(context.Context, *ListWorkflowLogRequest) (*Response, error)
	ReportWorkflow(context.Context, *WorkflowReportRequest) (*Response, error)
	RunWorkflowAction(context.Context, *RunWorkflowActionRequest) (*Response, error)
	ListAIAgents(context.Context, *Id) (*Response, error)
	CreateAIAgent(context.Context, *AIAgent) (*Response, error)
	UpdateAIAgent(context.Context, *AIAgent) (*Response, error)
	GetAIAgent(context.Context, *Id) (*Response, error)
	MatchAIAgent(context.Context, *Ids) (*Response, error)
	DeleteAIAgent(context.Context, *Id) (*Response, error)
	StartAiAgent(context.Context, *RunAiAgentRequest) (*Empty, error)
	StopAIAgent(context.Context, *RunAiAgentRequest) (*Empty, error)
	DeleteAIAgentDataEntry(context.Context, *AIAgentDataEntryRequest) (*Response, error)
	AddAIAgentDataEntry(context.Context, *AIAgentDataEntryRequest) (*Response, error)
	ListAIDataGroup(context.Context, *Id) (*Response, error)
	SuggestAIDataEntry(context.Context, *SuggestAIDataEntryRequest) (*Response, error)
	CreateAIDataGroup(context.Context, *AIDataGroup) (*Response, error)
	UpdateAIDataGroup(context.Context, *AIDataGroup) (*Response, error)
	DeleteAIDatagroup(context.Context, *Id) (*Empty, error)
	CreateAIDataEntry(context.Context, *AIDataEntry) (*Response, error)
	ListAIDataEntry(context.Context, *ListAIDataEntryRequest) (*Response, error)
	GetAIDataEntry(context.Context, *Id) (*Response, error)
	UpdateAIDataEntry(context.Context, *AIDataEntry) (*Response, error)
	ListAIDataEntryChunks(context.Context, *Id) (*Response, error)
	RetrainAIDataEntry(context.Context, *Id) (*Response, error)
	DeleteAIDataEntry(context.Context, *Id) (*Empty, error)
	MatchDataEntries(context.Context, *Ids) (*Response, error)
	ListAIAgentSpans(context.Context, *LLMSpansRequest) (*Response, error)
	ListAIAgentTraces(context.Context, *LLMTracesRequest) (*Response, error)
	ReportAIAgent(context.Context, *ReportAIAgentRequest) (*AIAgentReportResponse, error)
	TryWorkflowAction(context.Context, *StartWorkflowSessionRequest) (*Empty, error)
	ListAIAgentMessages(context.Context, *ListAIAgentMessageRequest) (*Response, error)
	ListConvertedLeads(context.Context, *ReportAIAgentRequest) (*Response, error)
	GetAIResponseTrace(context.Context, *AIAgentTraceRequest) (*Response, error)
	ListNamedEntities(context.Context, *Id) (*Response, error)
	CreateNamedEntity(context.Context, *NamedEntity) (*Response, error)
	UpdateNamedEntity(context.Context, *NamedEntity) (*Response, error)
	GetNamedEntity(context.Context, *Id) (*Response, error)
	MatchNamedEntities(context.Context, *Ids) (*Response, error)
	mustEmbedUnimplementedWorkflowMgrServer()
}

// UnimplementedWorkflowMgrServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedWorkflowMgrServer struct{}

func (UnimplementedWorkflowMgrServer) ListWorkflows(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWorkflows not implemented")
}
func (UnimplementedWorkflowMgrServer) UpdateWorkflow(context.Context, *Workflow) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWorkflow not implemented")
}
func (UnimplementedWorkflowMgrServer) CreateWorkflow(context.Context, *Workflow) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateWorkflow not implemented")
}
func (UnimplementedWorkflowMgrServer) DeleteWorkflow(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWorkflow not implemented")
}
func (UnimplementedWorkflowMgrServer) GetWorkflow(context.Context, *Workflow) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkflow not implemented")
}
func (UnimplementedWorkflowMgrServer) ListWorkflowVersions(context.Context, *ListVersions) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWorkflowVersions not implemented")
}
func (UnimplementedWorkflowMgrServer) StartWorkflowSession(context.Context, *StartWorkflowSessionRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartWorkflowSession not implemented")
}
func (UnimplementedWorkflowMgrServer) MatchWorkflows(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchWorkflows not implemented")
}
func (UnimplementedWorkflowMgrServer) PumpWorkflowSession(context.Context, *WorkflowPulse) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PumpWorkflowSession not implemented")
}
func (UnimplementedWorkflowMgrServer) GetWorkflowSession(context.Context, *WorkflowSessionId) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkflowSession not implemented")
}
func (UnimplementedWorkflowMgrServer) UpdateWorkflowSession(context.Context, *UpdateWorkflowSessionRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWorkflowSession not implemented")
}
func (UnimplementedWorkflowMgrServer) ListWorkflowSessions(context.Context, *ListWorkflowSessionRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWorkflowSessions not implemented")
}
func (UnimplementedWorkflowMgrServer) ListRelatedSessions(context.Context, *ListWorkflowLogRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRelatedSessions not implemented")
}
func (UnimplementedWorkflowMgrServer) ListWorkflowLogs(context.Context, *ListWorkflowLogRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWorkflowLogs not implemented")
}
func (UnimplementedWorkflowMgrServer) ReportWorkflow(context.Context, *WorkflowReportRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportWorkflow not implemented")
}
func (UnimplementedWorkflowMgrServer) RunWorkflowAction(context.Context, *RunWorkflowActionRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunWorkflowAction not implemented")
}
func (UnimplementedWorkflowMgrServer) ListAIAgents(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAIAgents not implemented")
}
func (UnimplementedWorkflowMgrServer) CreateAIAgent(context.Context, *AIAgent) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAIAgent not implemented")
}
func (UnimplementedWorkflowMgrServer) UpdateAIAgent(context.Context, *AIAgent) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAIAgent not implemented")
}
func (UnimplementedWorkflowMgrServer) GetAIAgent(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAIAgent not implemented")
}
func (UnimplementedWorkflowMgrServer) MatchAIAgent(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchAIAgent not implemented")
}
func (UnimplementedWorkflowMgrServer) DeleteAIAgent(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAIAgent not implemented")
}
func (UnimplementedWorkflowMgrServer) StartAiAgent(context.Context, *RunAiAgentRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartAiAgent not implemented")
}
func (UnimplementedWorkflowMgrServer) StopAIAgent(context.Context, *RunAiAgentRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopAIAgent not implemented")
}
func (UnimplementedWorkflowMgrServer) DeleteAIAgentDataEntry(context.Context, *AIAgentDataEntryRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAIAgentDataEntry not implemented")
}
func (UnimplementedWorkflowMgrServer) AddAIAgentDataEntry(context.Context, *AIAgentDataEntryRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddAIAgentDataEntry not implemented")
}
func (UnimplementedWorkflowMgrServer) ListAIDataGroup(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAIDataGroup not implemented")
}
func (UnimplementedWorkflowMgrServer) SuggestAIDataEntry(context.Context, *SuggestAIDataEntryRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SuggestAIDataEntry not implemented")
}
func (UnimplementedWorkflowMgrServer) CreateAIDataGroup(context.Context, *AIDataGroup) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAIDataGroup not implemented")
}
func (UnimplementedWorkflowMgrServer) UpdateAIDataGroup(context.Context, *AIDataGroup) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAIDataGroup not implemented")
}
func (UnimplementedWorkflowMgrServer) DeleteAIDatagroup(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAIDatagroup not implemented")
}
func (UnimplementedWorkflowMgrServer) CreateAIDataEntry(context.Context, *AIDataEntry) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAIDataEntry not implemented")
}
func (UnimplementedWorkflowMgrServer) ListAIDataEntry(context.Context, *ListAIDataEntryRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAIDataEntry not implemented")
}
func (UnimplementedWorkflowMgrServer) GetAIDataEntry(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAIDataEntry not implemented")
}
func (UnimplementedWorkflowMgrServer) UpdateAIDataEntry(context.Context, *AIDataEntry) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAIDataEntry not implemented")
}
func (UnimplementedWorkflowMgrServer) ListAIDataEntryChunks(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAIDataEntryChunks not implemented")
}
func (UnimplementedWorkflowMgrServer) RetrainAIDataEntry(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetrainAIDataEntry not implemented")
}
func (UnimplementedWorkflowMgrServer) DeleteAIDataEntry(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAIDataEntry not implemented")
}
func (UnimplementedWorkflowMgrServer) MatchDataEntries(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchDataEntries not implemented")
}
func (UnimplementedWorkflowMgrServer) ListAIAgentSpans(context.Context, *LLMSpansRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAIAgentSpans not implemented")
}
func (UnimplementedWorkflowMgrServer) ListAIAgentTraces(context.Context, *LLMTracesRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAIAgentTraces not implemented")
}
func (UnimplementedWorkflowMgrServer) ReportAIAgent(context.Context, *ReportAIAgentRequest) (*AIAgentReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportAIAgent not implemented")
}
func (UnimplementedWorkflowMgrServer) TryWorkflowAction(context.Context, *StartWorkflowSessionRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TryWorkflowAction not implemented")
}
func (UnimplementedWorkflowMgrServer) ListAIAgentMessages(context.Context, *ListAIAgentMessageRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAIAgentMessages not implemented")
}
func (UnimplementedWorkflowMgrServer) ListConvertedLeads(context.Context, *ReportAIAgentRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListConvertedLeads not implemented")
}
func (UnimplementedWorkflowMgrServer) GetAIResponseTrace(context.Context, *AIAgentTraceRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAIResponseTrace not implemented")
}
func (UnimplementedWorkflowMgrServer) ListNamedEntities(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNamedEntities not implemented")
}
func (UnimplementedWorkflowMgrServer) CreateNamedEntity(context.Context, *NamedEntity) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNamedEntity not implemented")
}
func (UnimplementedWorkflowMgrServer) UpdateNamedEntity(context.Context, *NamedEntity) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNamedEntity not implemented")
}
func (UnimplementedWorkflowMgrServer) GetNamedEntity(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNamedEntity not implemented")
}
func (UnimplementedWorkflowMgrServer) MatchNamedEntities(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchNamedEntities not implemented")
}
func (UnimplementedWorkflowMgrServer) mustEmbedUnimplementedWorkflowMgrServer() {}
func (UnimplementedWorkflowMgrServer) testEmbeddedByValue()                     {}

// UnsafeWorkflowMgrServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkflowMgrServer will
// result in compilation errors.
type UnsafeWorkflowMgrServer interface {
	mustEmbedUnimplementedWorkflowMgrServer()
}

func RegisterWorkflowMgrServer(s grpc.ServiceRegistrar, srv WorkflowMgrServer) {
	// If the following call pancis, it indicates UnimplementedWorkflowMgrServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&WorkflowMgr_ServiceDesc, srv)
}

func _WorkflowMgr_ListWorkflows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).ListWorkflows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_ListWorkflows_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).ListWorkflows(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_UpdateWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Workflow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).UpdateWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_UpdateWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).UpdateWorkflow(ctx, req.(*Workflow))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_CreateWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Workflow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).CreateWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_CreateWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).CreateWorkflow(ctx, req.(*Workflow))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_DeleteWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).DeleteWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_DeleteWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).DeleteWorkflow(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_GetWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Workflow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).GetWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_GetWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).GetWorkflow(ctx, req.(*Workflow))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_ListWorkflowVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVersions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).ListWorkflowVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_ListWorkflowVersions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).ListWorkflowVersions(ctx, req.(*ListVersions))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_StartWorkflowSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartWorkflowSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).StartWorkflowSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_StartWorkflowSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).StartWorkflowSession(ctx, req.(*StartWorkflowSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_MatchWorkflows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).MatchWorkflows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_MatchWorkflows_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).MatchWorkflows(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_PumpWorkflowSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkflowPulse)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).PumpWorkflowSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_PumpWorkflowSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).PumpWorkflowSession(ctx, req.(*WorkflowPulse))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_GetWorkflowSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkflowSessionId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).GetWorkflowSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_GetWorkflowSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).GetWorkflowSession(ctx, req.(*WorkflowSessionId))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_UpdateWorkflowSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWorkflowSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).UpdateWorkflowSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_UpdateWorkflowSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).UpdateWorkflowSession(ctx, req.(*UpdateWorkflowSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_ListWorkflowSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWorkflowSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).ListWorkflowSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_ListWorkflowSessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).ListWorkflowSessions(ctx, req.(*ListWorkflowSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_ListRelatedSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWorkflowLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).ListRelatedSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_ListRelatedSessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).ListRelatedSessions(ctx, req.(*ListWorkflowLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_ListWorkflowLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWorkflowLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).ListWorkflowLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_ListWorkflowLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).ListWorkflowLogs(ctx, req.(*ListWorkflowLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_ReportWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkflowReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).ReportWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_ReportWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).ReportWorkflow(ctx, req.(*WorkflowReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_RunWorkflowAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunWorkflowActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).RunWorkflowAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_RunWorkflowAction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).RunWorkflowAction(ctx, req.(*RunWorkflowActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_ListAIAgents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).ListAIAgents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_ListAIAgents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).ListAIAgents(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_CreateAIAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AIAgent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).CreateAIAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_CreateAIAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).CreateAIAgent(ctx, req.(*AIAgent))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_UpdateAIAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AIAgent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).UpdateAIAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_UpdateAIAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).UpdateAIAgent(ctx, req.(*AIAgent))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_GetAIAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).GetAIAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_GetAIAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).GetAIAgent(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_MatchAIAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).MatchAIAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_MatchAIAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).MatchAIAgent(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_DeleteAIAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).DeleteAIAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_DeleteAIAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).DeleteAIAgent(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_StartAiAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunAiAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).StartAiAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_StartAiAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).StartAiAgent(ctx, req.(*RunAiAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_StopAIAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunAiAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).StopAIAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_StopAIAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).StopAIAgent(ctx, req.(*RunAiAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_DeleteAIAgentDataEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AIAgentDataEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).DeleteAIAgentDataEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_DeleteAIAgentDataEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).DeleteAIAgentDataEntry(ctx, req.(*AIAgentDataEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_AddAIAgentDataEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AIAgentDataEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).AddAIAgentDataEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_AddAIAgentDataEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).AddAIAgentDataEntry(ctx, req.(*AIAgentDataEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_ListAIDataGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).ListAIDataGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_ListAIDataGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).ListAIDataGroup(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_SuggestAIDataEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuggestAIDataEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).SuggestAIDataEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_SuggestAIDataEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).SuggestAIDataEntry(ctx, req.(*SuggestAIDataEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_CreateAIDataGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AIDataGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).CreateAIDataGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_CreateAIDataGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).CreateAIDataGroup(ctx, req.(*AIDataGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_UpdateAIDataGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AIDataGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).UpdateAIDataGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_UpdateAIDataGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).UpdateAIDataGroup(ctx, req.(*AIDataGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_DeleteAIDatagroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).DeleteAIDatagroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_DeleteAIDatagroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).DeleteAIDatagroup(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_CreateAIDataEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AIDataEntry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).CreateAIDataEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_CreateAIDataEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).CreateAIDataEntry(ctx, req.(*AIDataEntry))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_ListAIDataEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAIDataEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).ListAIDataEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_ListAIDataEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).ListAIDataEntry(ctx, req.(*ListAIDataEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_GetAIDataEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).GetAIDataEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_GetAIDataEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).GetAIDataEntry(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_UpdateAIDataEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AIDataEntry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).UpdateAIDataEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_UpdateAIDataEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).UpdateAIDataEntry(ctx, req.(*AIDataEntry))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_ListAIDataEntryChunks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).ListAIDataEntryChunks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_ListAIDataEntryChunks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).ListAIDataEntryChunks(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_RetrainAIDataEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).RetrainAIDataEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_RetrainAIDataEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).RetrainAIDataEntry(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_DeleteAIDataEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).DeleteAIDataEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_DeleteAIDataEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).DeleteAIDataEntry(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_MatchDataEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).MatchDataEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_MatchDataEntries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).MatchDataEntries(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_ListAIAgentSpans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LLMSpansRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).ListAIAgentSpans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_ListAIAgentSpans_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).ListAIAgentSpans(ctx, req.(*LLMSpansRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_ListAIAgentTraces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LLMTracesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).ListAIAgentTraces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_ListAIAgentTraces_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).ListAIAgentTraces(ctx, req.(*LLMTracesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_ReportAIAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportAIAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).ReportAIAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_ReportAIAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).ReportAIAgent(ctx, req.(*ReportAIAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_TryWorkflowAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartWorkflowSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).TryWorkflowAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_TryWorkflowAction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).TryWorkflowAction(ctx, req.(*StartWorkflowSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_ListAIAgentMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAIAgentMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).ListAIAgentMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_ListAIAgentMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).ListAIAgentMessages(ctx, req.(*ListAIAgentMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_ListConvertedLeads_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportAIAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).ListConvertedLeads(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_ListConvertedLeads_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).ListConvertedLeads(ctx, req.(*ReportAIAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_GetAIResponseTrace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AIAgentTraceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).GetAIResponseTrace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_GetAIResponseTrace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).GetAIResponseTrace(ctx, req.(*AIAgentTraceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_ListNamedEntities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).ListNamedEntities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_ListNamedEntities_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).ListNamedEntities(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_CreateNamedEntity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NamedEntity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).CreateNamedEntity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_CreateNamedEntity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).CreateNamedEntity(ctx, req.(*NamedEntity))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_UpdateNamedEntity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NamedEntity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).UpdateNamedEntity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_UpdateNamedEntity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).UpdateNamedEntity(ctx, req.(*NamedEntity))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_GetNamedEntity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).GetNamedEntity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_GetNamedEntity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).GetNamedEntity(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowMgr_MatchNamedEntities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowMgrServer).MatchNamedEntities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowMgr_MatchNamedEntities_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowMgrServer).MatchNamedEntities(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

// WorkflowMgr_ServiceDesc is the grpc.ServiceDesc for WorkflowMgr service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorkflowMgr_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.WorkflowMgr",
	HandlerType: (*WorkflowMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListWorkflows",
			Handler:    _WorkflowMgr_ListWorkflows_Handler,
		},
		{
			MethodName: "UpdateWorkflow",
			Handler:    _WorkflowMgr_UpdateWorkflow_Handler,
		},
		{
			MethodName: "CreateWorkflow",
			Handler:    _WorkflowMgr_CreateWorkflow_Handler,
		},
		{
			MethodName: "DeleteWorkflow",
			Handler:    _WorkflowMgr_DeleteWorkflow_Handler,
		},
		{
			MethodName: "GetWorkflow",
			Handler:    _WorkflowMgr_GetWorkflow_Handler,
		},
		{
			MethodName: "ListWorkflowVersions",
			Handler:    _WorkflowMgr_ListWorkflowVersions_Handler,
		},
		{
			MethodName: "StartWorkflowSession",
			Handler:    _WorkflowMgr_StartWorkflowSession_Handler,
		},
		{
			MethodName: "MatchWorkflows",
			Handler:    _WorkflowMgr_MatchWorkflows_Handler,
		},
		{
			MethodName: "PumpWorkflowSession",
			Handler:    _WorkflowMgr_PumpWorkflowSession_Handler,
		},
		{
			MethodName: "GetWorkflowSession",
			Handler:    _WorkflowMgr_GetWorkflowSession_Handler,
		},
		{
			MethodName: "UpdateWorkflowSession",
			Handler:    _WorkflowMgr_UpdateWorkflowSession_Handler,
		},
		{
			MethodName: "ListWorkflowSessions",
			Handler:    _WorkflowMgr_ListWorkflowSessions_Handler,
		},
		{
			MethodName: "ListRelatedSessions",
			Handler:    _WorkflowMgr_ListRelatedSessions_Handler,
		},
		{
			MethodName: "ListWorkflowLogs",
			Handler:    _WorkflowMgr_ListWorkflowLogs_Handler,
		},
		{
			MethodName: "ReportWorkflow",
			Handler:    _WorkflowMgr_ReportWorkflow_Handler,
		},
		{
			MethodName: "RunWorkflowAction",
			Handler:    _WorkflowMgr_RunWorkflowAction_Handler,
		},
		{
			MethodName: "ListAIAgents",
			Handler:    _WorkflowMgr_ListAIAgents_Handler,
		},
		{
			MethodName: "CreateAIAgent",
			Handler:    _WorkflowMgr_CreateAIAgent_Handler,
		},
		{
			MethodName: "UpdateAIAgent",
			Handler:    _WorkflowMgr_UpdateAIAgent_Handler,
		},
		{
			MethodName: "GetAIAgent",
			Handler:    _WorkflowMgr_GetAIAgent_Handler,
		},
		{
			MethodName: "MatchAIAgent",
			Handler:    _WorkflowMgr_MatchAIAgent_Handler,
		},
		{
			MethodName: "DeleteAIAgent",
			Handler:    _WorkflowMgr_DeleteAIAgent_Handler,
		},
		{
			MethodName: "StartAiAgent",
			Handler:    _WorkflowMgr_StartAiAgent_Handler,
		},
		{
			MethodName: "StopAIAgent",
			Handler:    _WorkflowMgr_StopAIAgent_Handler,
		},
		{
			MethodName: "DeleteAIAgentDataEntry",
			Handler:    _WorkflowMgr_DeleteAIAgentDataEntry_Handler,
		},
		{
			MethodName: "AddAIAgentDataEntry",
			Handler:    _WorkflowMgr_AddAIAgentDataEntry_Handler,
		},
		{
			MethodName: "ListAIDataGroup",
			Handler:    _WorkflowMgr_ListAIDataGroup_Handler,
		},
		{
			MethodName: "SuggestAIDataEntry",
			Handler:    _WorkflowMgr_SuggestAIDataEntry_Handler,
		},
		{
			MethodName: "CreateAIDataGroup",
			Handler:    _WorkflowMgr_CreateAIDataGroup_Handler,
		},
		{
			MethodName: "UpdateAIDataGroup",
			Handler:    _WorkflowMgr_UpdateAIDataGroup_Handler,
		},
		{
			MethodName: "DeleteAIDatagroup",
			Handler:    _WorkflowMgr_DeleteAIDatagroup_Handler,
		},
		{
			MethodName: "CreateAIDataEntry",
			Handler:    _WorkflowMgr_CreateAIDataEntry_Handler,
		},
		{
			MethodName: "ListAIDataEntry",
			Handler:    _WorkflowMgr_ListAIDataEntry_Handler,
		},
		{
			MethodName: "GetAIDataEntry",
			Handler:    _WorkflowMgr_GetAIDataEntry_Handler,
		},
		{
			MethodName: "UpdateAIDataEntry",
			Handler:    _WorkflowMgr_UpdateAIDataEntry_Handler,
		},
		{
			MethodName: "ListAIDataEntryChunks",
			Handler:    _WorkflowMgr_ListAIDataEntryChunks_Handler,
		},
		{
			MethodName: "RetrainAIDataEntry",
			Handler:    _WorkflowMgr_RetrainAIDataEntry_Handler,
		},
		{
			MethodName: "DeleteAIDataEntry",
			Handler:    _WorkflowMgr_DeleteAIDataEntry_Handler,
		},
		{
			MethodName: "MatchDataEntries",
			Handler:    _WorkflowMgr_MatchDataEntries_Handler,
		},
		{
			MethodName: "ListAIAgentSpans",
			Handler:    _WorkflowMgr_ListAIAgentSpans_Handler,
		},
		{
			MethodName: "ListAIAgentTraces",
			Handler:    _WorkflowMgr_ListAIAgentTraces_Handler,
		},
		{
			MethodName: "ReportAIAgent",
			Handler:    _WorkflowMgr_ReportAIAgent_Handler,
		},
		{
			MethodName: "TryWorkflowAction",
			Handler:    _WorkflowMgr_TryWorkflowAction_Handler,
		},
		{
			MethodName: "ListAIAgentMessages",
			Handler:    _WorkflowMgr_ListAIAgentMessages_Handler,
		},
		{
			MethodName: "ListConvertedLeads",
			Handler:    _WorkflowMgr_ListConvertedLeads_Handler,
		},
		{
			MethodName: "GetAIResponseTrace",
			Handler:    _WorkflowMgr_GetAIResponseTrace_Handler,
		},
		{
			MethodName: "ListNamedEntities",
			Handler:    _WorkflowMgr_ListNamedEntities_Handler,
		},
		{
			MethodName: "CreateNamedEntity",
			Handler:    _WorkflowMgr_CreateNamedEntity_Handler,
		},
		{
			MethodName: "UpdateNamedEntity",
			Handler:    _WorkflowMgr_UpdateNamedEntity_Handler,
		},
		{
			MethodName: "GetNamedEntity",
			Handler:    _WorkflowMgr_GetNamedEntity_Handler,
		},
		{
			MethodName: "MatchNamedEntities",
			Handler:    _WorkflowMgr_MatchNamedEntities_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	ConversationMgr_AssignRule_FullMethodName               = "/header.ConversationMgr/AssignRule"
	ConversationMgr_ReassignConversation_FullMethodName     = "/header.ConversationMgr/ReassignConversation"
	ConversationMgr_PongMessage_FullMethodName              = "/header.ConversationMgr/PongMessage"
	ConversationMgr_StartConversation_FullMethodName        = "/header.ConversationMgr/StartConversation"
	ConversationMgr_EndConversation_FullMethodName          = "/header.ConversationMgr/EndConversation"
	ConversationMgr_GetConversation_FullMethodName          = "/header.ConversationMgr/GetConversation"
	ConversationMgr_GetFullConversation_FullMethodName      = "/header.ConversationMgr/GetFullConversation"
	ConversationMgr_ListConversations_FullMethodName        = "/header.ConversationMgr/ListConversations"
	ConversationMgr_ListConversations2_FullMethodName       = "/header.ConversationMgr/ListConversations2"
	ConversationMgr_MatchConversations_FullMethodName       = "/header.ConversationMgr/MatchConversations"
	ConversationMgr_TagConversation_FullMethodName          = "/header.ConversationMgr/TagConversation"
	ConversationMgr_UntagConversation_FullMethodName        = "/header.ConversationMgr/UntagConversation"
	ConversationMgr_JoinConversation_FullMethodName         = "/header.ConversationMgr/JoinConversation"
	ConversationMgr_LeftConversation_FullMethodName         = "/header.ConversationMgr/LeftConversation"
	ConversationMgr_MarkReadTopic_FullMethodName            = "/header.ConversationMgr/MarkReadTopic"
	ConversationMgr_UpdateConversationInfo_FullMethodName   = "/header.ConversationMgr/UpdateConversationInfo"
	ConversationMgr_UpdateMuteConversation_FullMethodName   = "/header.ConversationMgr/UpdateMuteConversation"
	ConversationMgr_UpdateConversationMember_FullMethodName = "/header.ConversationMgr/UpdateConversationMember"
	ConversationMgr_UnwatchConversation_FullMethodName      = "/header.ConversationMgr/UnwatchConversation"
	ConversationMgr_UnhiddenConversation_FullMethodName     = "/header.ConversationMgr/UnhiddenConversation"
	ConversationMgr_UnsentMessage_FullMethodName            = "/header.ConversationMgr/UnsentMessage"
	ConversationMgr_DismissConversation_FullMethodName      = "/header.ConversationMgr/DismissConversation"
	ConversationMgr_ReconsiderConversation_FullMethodName   = "/header.ConversationMgr/ReconsiderConversation"
	ConversationMgr_UpdateEndchatSetting_FullMethodName     = "/header.ConversationMgr/UpdateEndchatSetting"
	ConversationMgr_GetEndchatSetting_FullMethodName        = "/header.ConversationMgr/GetEndchatSetting"
	ConversationMgr_TerminateBot_FullMethodName             = "/header.ConversationMgr/TerminateBot"
	ConversationMgr_SendMessage_FullMethodName              = "/header.ConversationMgr/SendMessage"
	ConversationMgr_SendOmniChannelMessage_FullMethodName   = "/header.ConversationMgr/SendOmniChannelMessage"
	ConversationMgr_UpdateMessage_FullMethodName            = "/header.ConversationMgr/UpdateMessage"
	ConversationMgr_ListEvents_FullMethodName               = "/header.ConversationMgr/ListEvents"
	ConversationMgr_ReadConvoEvent_FullMethodName           = "/header.ConversationMgr/ReadConvoEvent"
	ConversationMgr_Deintegrate_FullMethodName              = "/header.ConversationMgr/Deintegrate"
	ConversationMgr_ListIntegrations2_FullMethodName        = "/header.ConversationMgr/ListIntegrations2"
	ConversationMgr_MatchIntegration_FullMethodName         = "/header.ConversationMgr/MatchIntegration"
	ConversationMgr_Integrate_FullMethodName                = "/header.ConversationMgr/Integrate"
	ConversationMgr_UpsertIntegration_FullMethodName        = "/header.ConversationMgr/UpsertIntegration"
	ConversationMgr_GetIntegration_FullMethodName           = "/header.ConversationMgr/GetIntegration"
	ConversationMgr_UpdateIntegrationMember_FullMethodName  = "/header.ConversationMgr/UpdateIntegrationMember"
	ConversationMgr_RemoveIntegrationMember_FullMethodName  = "/header.ConversationMgr/RemoveIntegrationMember"
	ConversationMgr_UpdateRule_FullMethodName               = "/header.ConversationMgr/UpdateRule"
	ConversationMgr_CreateRule_FullMethodName               = "/header.ConversationMgr/CreateRule"
	ConversationMgr_DeleteRule_FullMethodName               = "/header.ConversationMgr/DeleteRule"
	ConversationMgr_ReadRule_FullMethodName                 = "/header.ConversationMgr/ReadRule"
	ConversationMgr_MatchRule_FullMethodName                = "/header.ConversationMgr/MatchRule"
	ConversationMgr_ListRules2_FullMethodName               = "/header.ConversationMgr/ListRules2"
	ConversationMgr_GetRuleOrder_FullMethodName             = "/header.ConversationMgr/GetRuleOrder"
	ConversationMgr_UpdateRuleOrder_FullMethodName          = "/header.ConversationMgr/UpdateRuleOrder"
	ConversationMgr_ListPhoneDevices_FullMethodName         = "/header.ConversationMgr/ListPhoneDevices"
	ConversationMgr_CreatePhoneDevice_FullMethodName        = "/header.ConversationMgr/CreatePhoneDevice"
	ConversationMgr_UpdatePhoneDevice_FullMethodName        = "/header.ConversationMgr/UpdatePhoneDevice"
	ConversationMgr_DeletePhoneDevice_FullMethodName        = "/header.ConversationMgr/DeletePhoneDevice"
	ConversationMgr_ReadPhoneDevice_FullMethodName          = "/header.ConversationMgr/ReadPhoneDevice"
	ConversationMgr_TestNumber_FullMethodName               = "/header.ConversationMgr/TestNumber"
	ConversationMgr_ActiveNumber_FullMethodName             = "/header.ConversationMgr/ActiveNumber"
	ConversationMgr_ListCallSettings_FullMethodName         = "/header.ConversationMgr/ListCallSettings"
	ConversationMgr_UpdateCallSetting_FullMethodName        = "/header.ConversationMgr/UpdateCallSetting"
	ConversationMgr_BlockNumber_FullMethodName              = "/header.ConversationMgr/BlockNumber"
	ConversationMgr_ListBlockedNumbers_FullMethodName       = "/header.ConversationMgr/ListBlockedNumbers"
	ConversationMgr_UnblockNumber_FullMethodName            = "/header.ConversationMgr/UnblockNumber"
	ConversationMgr_ListGreetingAudio_FullMethodName        = "/header.ConversationMgr/ListGreetingAudio"
	ConversationMgr_CreateGreetingAudio_FullMethodName      = "/header.ConversationMgr/CreateGreetingAudio"
	ConversationMgr_UpdateGreetingAudio_FullMethodName      = "/header.ConversationMgr/UpdateGreetingAudio"
	ConversationMgr_DeleteGreetingAudio_FullMethodName      = "/header.ConversationMgr/DeleteGreetingAudio"
	ConversationMgr_OriginateCall_FullMethodName            = "/header.ConversationMgr/OriginateCall"
	ConversationMgr_ListMyRecentCalls_FullMethodName        = "/header.ConversationMgr/ListMyRecentCalls"
	ConversationMgr_SaveMessage_FullMethodName              = "/header.ConversationMgr/SaveMessage"
	ConversationMgr_ApplyMessage_FullMethodName             = "/header.ConversationMgr/ApplyMessage"
	ConversationMgr_CountAgentUnreadMessages_FullMethodName = "/header.ConversationMgr/CountAgentUnreadMessages"
	ConversationMgr_OnWebUserCreated_FullMethodName         = "/header.ConversationMgr/OnWebUserCreated"
	ConversationMgr_OnBotUpdated_FullMethodName             = "/header.ConversationMgr/OnBotUpdated"
	ConversationMgr_OnBotDeleted_FullMethodName             = "/header.ConversationMgr/OnBotDeleted"
	ConversationMgr_OnAIAgentUpdated_FullMethodName         = "/header.ConversationMgr/OnAIAgentUpdated"
	ConversationMgr_NotifyHuman_FullMethodName              = "/header.ConversationMgr/NotifyHuman"
	ConversationMgr_MarkAsHumanHandled_FullMethodName       = "/header.ConversationMgr/MarkAsHumanHandled"
	ConversationMgr_ReportMessages_FullMethodName           = "/header.ConversationMgr/ReportMessages"
	ConversationMgr_VerifyWebsiteByVisit_FullMethodName     = "/header.ConversationMgr/VerifyWebsiteByVisit"
	ConversationMgr_VerifyWebsiteByDNS_FullMethodName       = "/header.ConversationMgr/VerifyWebsiteByDNS"
)

// ConversationMgrClient is the client API for ConversationMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConversationMgrClient interface {
	AssignRule(ctx context.Context, in *AssignRequest, opts ...grpc.CallOption) (*RouteResult, error)
	ReassignConversation(ctx context.Context, in *Id, opts ...grpc.CallOption) (*RouteResult, error)
	PongMessage(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error)
	StartConversation(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*Conversation, error)
	EndConversation(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Conversation, error)
	GetConversation(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Conversation, error)
	GetFullConversation(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	ListConversations(ctx context.Context, in *ListConversationsRequest, opts ...grpc.CallOption) (*Conversations, error)
	ListConversations2(ctx context.Context, in *ListConversationsRequest, opts ...grpc.CallOption) (*Response, error)
	MatchConversations(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Conversations, error)
	TagConversation(ctx context.Context, in *TagRequest, opts ...grpc.CallOption) (*Empty, error)
	UntagConversation(ctx context.Context, in *TagRequest, opts ...grpc.CallOption) (*Empty, error)
	JoinConversation(ctx context.Context, in *ConversationMember, opts ...grpc.CallOption) (*Empty, error)
	LeftConversation(ctx context.Context, in *ConversationMember, opts ...grpc.CallOption) (*Empty, error)
	MarkReadTopic(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	UpdateConversationInfo(ctx context.Context, in *Conversation, opts ...grpc.CallOption) (*Conversation, error)
	UpdateMuteConversation(ctx context.Context, in *Conversation, opts ...grpc.CallOption) (*Empty, error)
	UpdateConversationMember(ctx context.Context, in *ConversationMember, opts ...grpc.CallOption) (*Response, error)
	UnwatchConversation(ctx context.Context, in *Conversation, opts ...grpc.CallOption) (*Empty, error)
	UnhiddenConversation(ctx context.Context, in *Conversation, opts ...grpc.CallOption) (*Empty, error)
	UnsentMessage(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error)
	DismissConversation(ctx context.Context, in *Conversation, opts ...grpc.CallOption) (*Empty, error)
	ReconsiderConversation(ctx context.Context, in *Conversation, opts ...grpc.CallOption) (*Empty, error)
	UpdateEndchatSetting(ctx context.Context, in *EndchatSetting, opts ...grpc.CallOption) (*EndchatSetting, error)
	GetEndchatSetting(ctx context.Context, in *Id, opts ...grpc.CallOption) (*EndchatSetting, error)
	TerminateBot(ctx context.Context, in *BotTerminated, opts ...grpc.CallOption) (*Event, error)
	SendMessage(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error)
	SendOmniChannelMessage(ctx context.Context, in *SendOmniChannelMessageRequest, opts ...grpc.CallOption) (*Event, error)
	UpdateMessage(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error)
	// rpc PinMessage(header.Event) returns (header.Empty);
	// rpc UnpinMessage(header.Event) returns (header.Empty);
	ListEvents(ctx context.Context, in *ListConversationEventsRequest, opts ...grpc.CallOption) (*Events, error)
	ReadConvoEvent(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Response, error)
	Deintegrate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ListIntegrations2(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	MatchIntegration(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
	Integrate(ctx context.Context, in *Integration, opts ...grpc.CallOption) (*Integration, error)
	UpsertIntegration(ctx context.Context, in *Integration, opts ...grpc.CallOption) (*Integration, error)
	GetIntegration(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Integration, error)
	UpdateIntegrationMember(ctx context.Context, in *ResourceGroupMember, opts ...grpc.CallOption) (*ResourceGroupMember, error)
	RemoveIntegrationMember(ctx context.Context, in *ResourceGroupMember, opts ...grpc.CallOption) (*Empty, error)
	UpdateRule(ctx context.Context, in *Rule, opts ...grpc.CallOption) (*Rule, error)
	CreateRule(ctx context.Context, in *Rule, opts ...grpc.CallOption) (*Rule, error)
	DeleteRule(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ReadRule(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Rule, error)
	MatchRule(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
	ListRules2(ctx context.Context, in *ListRuleRequest, opts ...grpc.CallOption) (*Response, error)
	GetRuleOrder(ctx context.Context, in *Id, opts ...grpc.CallOption) (*RuleOrder, error)
	UpdateRuleOrder(ctx context.Context, in *RuleOrder, opts ...grpc.CallOption) (*RuleOrder, error)
	ListPhoneDevices(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	CreatePhoneDevice(ctx context.Context, in *PhoneDevice, opts ...grpc.CallOption) (*PhoneDevice, error)
	UpdatePhoneDevice(ctx context.Context, in *PhoneDevice, opts ...grpc.CallOption) (*PhoneDevice, error)
	DeletePhoneDevice(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ReadPhoneDevice(ctx context.Context, in *Id, opts ...grpc.CallOption) (*PhoneDevice, error)
	TestNumber(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Integration, error)
	ActiveNumber(ctx context.Context, in *Integration, opts ...grpc.CallOption) (*Integration, error)
	ListCallSettings(ctx context.Context, in *Id, opts ...grpc.CallOption) (*CallSettings, error)
	UpdateCallSetting(ctx context.Context, in *CallSetting, opts ...grpc.CallOption) (*CallSetting, error)
	BlockNumber(ctx context.Context, in *BlockedNumber, opts ...grpc.CallOption) (*BlockedNumber, error)
	ListBlockedNumbers(ctx context.Context, in *Id, opts ...grpc.CallOption) (*BlockedNumbers, error)
	UnblockNumber(ctx context.Context, in *BlockedNumber, opts ...grpc.CallOption) (*Empty, error)
	ListGreetingAudio(ctx context.Context, in *Id, opts ...grpc.CallOption) (*GreetingAudios, error)
	CreateGreetingAudio(ctx context.Context, in *GreetingAudio, opts ...grpc.CallOption) (*GreetingAudio, error)
	UpdateGreetingAudio(ctx context.Context, in *GreetingAudio, opts ...grpc.CallOption) (*Response, error)
	DeleteGreetingAudio(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	// try to make an outbound call from subiz
	OriginateCall(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*Conversation, error)
	ListMyRecentCalls(ctx context.Context, in *Id, opts ...grpc.CallOption) (*RecentCallRecords, error)
	// sync, called from fabikon
	SaveMessage(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error)
	ApplyMessage(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error)
	CountAgentUnreadMessages(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	OnWebUserCreated(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	OnBotUpdated(ctx context.Context, in *Bot, opts ...grpc.CallOption) (*Response, error)
	OnBotDeleted(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	OnAIAgentUpdated(ctx context.Context, in *AIAgent, opts ...grpc.CallOption) (*Response, error)
	// for ai agent to notify human
	NotifyHuman(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Response, error)
	MarkAsHumanHandled(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	ReportMessages(ctx context.Context, in *ReportConvoMessageRequest, opts ...grpc.CallOption) (*Response, error)
	VerifyWebsiteByVisit(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	VerifyWebsiteByDNS(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
}

type conversationMgrClient struct {
	cc grpc.ClientConnInterface
}

func NewConversationMgrClient(cc grpc.ClientConnInterface) ConversationMgrClient {
	return &conversationMgrClient{cc}
}

func (c *conversationMgrClient) AssignRule(ctx context.Context, in *AssignRequest, opts ...grpc.CallOption) (*RouteResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RouteResult)
	err := c.cc.Invoke(ctx, ConversationMgr_AssignRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) ReassignConversation(ctx context.Context, in *Id, opts ...grpc.CallOption) (*RouteResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RouteResult)
	err := c.cc.Invoke(ctx, ConversationMgr_ReassignConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) PongMessage(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Event)
	err := c.cc.Invoke(ctx, ConversationMgr_PongMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) StartConversation(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*Conversation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Conversation)
	err := c.cc.Invoke(ctx, ConversationMgr_StartConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) EndConversation(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Conversation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Conversation)
	err := c.cc.Invoke(ctx, ConversationMgr_EndConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) GetConversation(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Conversation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Conversation)
	err := c.cc.Invoke(ctx, ConversationMgr_GetConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) GetFullConversation(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ConversationMgr_GetFullConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) ListConversations(ctx context.Context, in *ListConversationsRequest, opts ...grpc.CallOption) (*Conversations, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Conversations)
	err := c.cc.Invoke(ctx, ConversationMgr_ListConversations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) ListConversations2(ctx context.Context, in *ListConversationsRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ConversationMgr_ListConversations2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) MatchConversations(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Conversations, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Conversations)
	err := c.cc.Invoke(ctx, ConversationMgr_MatchConversations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) TagConversation(ctx context.Context, in *TagRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ConversationMgr_TagConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) UntagConversation(ctx context.Context, in *TagRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ConversationMgr_UntagConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) JoinConversation(ctx context.Context, in *ConversationMember, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ConversationMgr_JoinConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) LeftConversation(ctx context.Context, in *ConversationMember, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ConversationMgr_LeftConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) MarkReadTopic(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ConversationMgr_MarkReadTopic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) UpdateConversationInfo(ctx context.Context, in *Conversation, opts ...grpc.CallOption) (*Conversation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Conversation)
	err := c.cc.Invoke(ctx, ConversationMgr_UpdateConversationInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) UpdateMuteConversation(ctx context.Context, in *Conversation, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ConversationMgr_UpdateMuteConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) UpdateConversationMember(ctx context.Context, in *ConversationMember, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ConversationMgr_UpdateConversationMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) UnwatchConversation(ctx context.Context, in *Conversation, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ConversationMgr_UnwatchConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) UnhiddenConversation(ctx context.Context, in *Conversation, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ConversationMgr_UnhiddenConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) UnsentMessage(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Event)
	err := c.cc.Invoke(ctx, ConversationMgr_UnsentMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) DismissConversation(ctx context.Context, in *Conversation, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ConversationMgr_DismissConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) ReconsiderConversation(ctx context.Context, in *Conversation, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ConversationMgr_ReconsiderConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) UpdateEndchatSetting(ctx context.Context, in *EndchatSetting, opts ...grpc.CallOption) (*EndchatSetting, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EndchatSetting)
	err := c.cc.Invoke(ctx, ConversationMgr_UpdateEndchatSetting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) GetEndchatSetting(ctx context.Context, in *Id, opts ...grpc.CallOption) (*EndchatSetting, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EndchatSetting)
	err := c.cc.Invoke(ctx, ConversationMgr_GetEndchatSetting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) TerminateBot(ctx context.Context, in *BotTerminated, opts ...grpc.CallOption) (*Event, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Event)
	err := c.cc.Invoke(ctx, ConversationMgr_TerminateBot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) SendMessage(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Event)
	err := c.cc.Invoke(ctx, ConversationMgr_SendMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) SendOmniChannelMessage(ctx context.Context, in *SendOmniChannelMessageRequest, opts ...grpc.CallOption) (*Event, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Event)
	err := c.cc.Invoke(ctx, ConversationMgr_SendOmniChannelMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) UpdateMessage(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Event)
	err := c.cc.Invoke(ctx, ConversationMgr_UpdateMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) ListEvents(ctx context.Context, in *ListConversationEventsRequest, opts ...grpc.CallOption) (*Events, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Events)
	err := c.cc.Invoke(ctx, ConversationMgr_ListEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) ReadConvoEvent(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ConversationMgr_ReadConvoEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) Deintegrate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ConversationMgr_Deintegrate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) ListIntegrations2(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ConversationMgr_ListIntegrations2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) MatchIntegration(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ConversationMgr_MatchIntegration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) Integrate(ctx context.Context, in *Integration, opts ...grpc.CallOption) (*Integration, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Integration)
	err := c.cc.Invoke(ctx, ConversationMgr_Integrate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) UpsertIntegration(ctx context.Context, in *Integration, opts ...grpc.CallOption) (*Integration, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Integration)
	err := c.cc.Invoke(ctx, ConversationMgr_UpsertIntegration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) GetIntegration(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Integration, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Integration)
	err := c.cc.Invoke(ctx, ConversationMgr_GetIntegration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) UpdateIntegrationMember(ctx context.Context, in *ResourceGroupMember, opts ...grpc.CallOption) (*ResourceGroupMember, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResourceGroupMember)
	err := c.cc.Invoke(ctx, ConversationMgr_UpdateIntegrationMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) RemoveIntegrationMember(ctx context.Context, in *ResourceGroupMember, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ConversationMgr_RemoveIntegrationMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) UpdateRule(ctx context.Context, in *Rule, opts ...grpc.CallOption) (*Rule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Rule)
	err := c.cc.Invoke(ctx, ConversationMgr_UpdateRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) CreateRule(ctx context.Context, in *Rule, opts ...grpc.CallOption) (*Rule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Rule)
	err := c.cc.Invoke(ctx, ConversationMgr_CreateRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) DeleteRule(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ConversationMgr_DeleteRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) ReadRule(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Rule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Rule)
	err := c.cc.Invoke(ctx, ConversationMgr_ReadRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) MatchRule(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ConversationMgr_MatchRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) ListRules2(ctx context.Context, in *ListRuleRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ConversationMgr_ListRules2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) GetRuleOrder(ctx context.Context, in *Id, opts ...grpc.CallOption) (*RuleOrder, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RuleOrder)
	err := c.cc.Invoke(ctx, ConversationMgr_GetRuleOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) UpdateRuleOrder(ctx context.Context, in *RuleOrder, opts ...grpc.CallOption) (*RuleOrder, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RuleOrder)
	err := c.cc.Invoke(ctx, ConversationMgr_UpdateRuleOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) ListPhoneDevices(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ConversationMgr_ListPhoneDevices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) CreatePhoneDevice(ctx context.Context, in *PhoneDevice, opts ...grpc.CallOption) (*PhoneDevice, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PhoneDevice)
	err := c.cc.Invoke(ctx, ConversationMgr_CreatePhoneDevice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) UpdatePhoneDevice(ctx context.Context, in *PhoneDevice, opts ...grpc.CallOption) (*PhoneDevice, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PhoneDevice)
	err := c.cc.Invoke(ctx, ConversationMgr_UpdatePhoneDevice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) DeletePhoneDevice(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ConversationMgr_DeletePhoneDevice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) ReadPhoneDevice(ctx context.Context, in *Id, opts ...grpc.CallOption) (*PhoneDevice, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PhoneDevice)
	err := c.cc.Invoke(ctx, ConversationMgr_ReadPhoneDevice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) TestNumber(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Integration, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Integration)
	err := c.cc.Invoke(ctx, ConversationMgr_TestNumber_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) ActiveNumber(ctx context.Context, in *Integration, opts ...grpc.CallOption) (*Integration, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Integration)
	err := c.cc.Invoke(ctx, ConversationMgr_ActiveNumber_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) ListCallSettings(ctx context.Context, in *Id, opts ...grpc.CallOption) (*CallSettings, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CallSettings)
	err := c.cc.Invoke(ctx, ConversationMgr_ListCallSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) UpdateCallSetting(ctx context.Context, in *CallSetting, opts ...grpc.CallOption) (*CallSetting, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CallSetting)
	err := c.cc.Invoke(ctx, ConversationMgr_UpdateCallSetting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) BlockNumber(ctx context.Context, in *BlockedNumber, opts ...grpc.CallOption) (*BlockedNumber, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BlockedNumber)
	err := c.cc.Invoke(ctx, ConversationMgr_BlockNumber_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) ListBlockedNumbers(ctx context.Context, in *Id, opts ...grpc.CallOption) (*BlockedNumbers, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BlockedNumbers)
	err := c.cc.Invoke(ctx, ConversationMgr_ListBlockedNumbers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) UnblockNumber(ctx context.Context, in *BlockedNumber, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ConversationMgr_UnblockNumber_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) ListGreetingAudio(ctx context.Context, in *Id, opts ...grpc.CallOption) (*GreetingAudios, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GreetingAudios)
	err := c.cc.Invoke(ctx, ConversationMgr_ListGreetingAudio_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) CreateGreetingAudio(ctx context.Context, in *GreetingAudio, opts ...grpc.CallOption) (*GreetingAudio, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GreetingAudio)
	err := c.cc.Invoke(ctx, ConversationMgr_CreateGreetingAudio_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) UpdateGreetingAudio(ctx context.Context, in *GreetingAudio, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ConversationMgr_UpdateGreetingAudio_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) DeleteGreetingAudio(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ConversationMgr_DeleteGreetingAudio_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) OriginateCall(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*Conversation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Conversation)
	err := c.cc.Invoke(ctx, ConversationMgr_OriginateCall_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) ListMyRecentCalls(ctx context.Context, in *Id, opts ...grpc.CallOption) (*RecentCallRecords, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecentCallRecords)
	err := c.cc.Invoke(ctx, ConversationMgr_ListMyRecentCalls_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) SaveMessage(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Event)
	err := c.cc.Invoke(ctx, ConversationMgr_SaveMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) ApplyMessage(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Event)
	err := c.cc.Invoke(ctx, ConversationMgr_ApplyMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) CountAgentUnreadMessages(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ConversationMgr_CountAgentUnreadMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) OnWebUserCreated(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ConversationMgr_OnWebUserCreated_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) OnBotUpdated(ctx context.Context, in *Bot, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ConversationMgr_OnBotUpdated_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) OnBotDeleted(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ConversationMgr_OnBotDeleted_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) OnAIAgentUpdated(ctx context.Context, in *AIAgent, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ConversationMgr_OnAIAgentUpdated_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) NotifyHuman(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ConversationMgr_NotifyHuman_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) MarkAsHumanHandled(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ConversationMgr_MarkAsHumanHandled_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) ReportMessages(ctx context.Context, in *ReportConvoMessageRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ConversationMgr_ReportMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) VerifyWebsiteByVisit(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ConversationMgr_VerifyWebsiteByVisit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) VerifyWebsiteByDNS(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ConversationMgr_VerifyWebsiteByDNS_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConversationMgrServer is the server API for ConversationMgr service.
// All implementations must embed UnimplementedConversationMgrServer
// for forward compatibility.
type ConversationMgrServer interface {
	AssignRule(context.Context, *AssignRequest) (*RouteResult, error)
	ReassignConversation(context.Context, *Id) (*RouteResult, error)
	PongMessage(context.Context, *Event) (*Event, error)
	StartConversation(context.Context, *StartRequest) (*Conversation, error)
	EndConversation(context.Context, *Id) (*Conversation, error)
	GetConversation(context.Context, *Id) (*Conversation, error)
	GetFullConversation(context.Context, *Id) (*Response, error)
	ListConversations(context.Context, *ListConversationsRequest) (*Conversations, error)
	ListConversations2(context.Context, *ListConversationsRequest) (*Response, error)
	MatchConversations(context.Context, *Ids) (*Conversations, error)
	TagConversation(context.Context, *TagRequest) (*Empty, error)
	UntagConversation(context.Context, *TagRequest) (*Empty, error)
	JoinConversation(context.Context, *ConversationMember) (*Empty, error)
	LeftConversation(context.Context, *ConversationMember) (*Empty, error)
	MarkReadTopic(context.Context, *Id) (*Empty, error)
	UpdateConversationInfo(context.Context, *Conversation) (*Conversation, error)
	UpdateMuteConversation(context.Context, *Conversation) (*Empty, error)
	UpdateConversationMember(context.Context, *ConversationMember) (*Response, error)
	UnwatchConversation(context.Context, *Conversation) (*Empty, error)
	UnhiddenConversation(context.Context, *Conversation) (*Empty, error)
	UnsentMessage(context.Context, *Event) (*Event, error)
	DismissConversation(context.Context, *Conversation) (*Empty, error)
	ReconsiderConversation(context.Context, *Conversation) (*Empty, error)
	UpdateEndchatSetting(context.Context, *EndchatSetting) (*EndchatSetting, error)
	GetEndchatSetting(context.Context, *Id) (*EndchatSetting, error)
	TerminateBot(context.Context, *BotTerminated) (*Event, error)
	SendMessage(context.Context, *Event) (*Event, error)
	SendOmniChannelMessage(context.Context, *SendOmniChannelMessageRequest) (*Event, error)
	UpdateMessage(context.Context, *Event) (*Event, error)
	// rpc PinMessage(header.Event) returns (header.Empty);
	// rpc UnpinMessage(header.Event) returns (header.Empty);
	ListEvents(context.Context, *ListConversationEventsRequest) (*Events, error)
	ReadConvoEvent(context.Context, *Message) (*Response, error)
	Deintegrate(context.Context, *Id) (*Empty, error)
	ListIntegrations2(context.Context, *Id) (*Response, error)
	MatchIntegration(context.Context, *Ids) (*Response, error)
	Integrate(context.Context, *Integration) (*Integration, error)
	UpsertIntegration(context.Context, *Integration) (*Integration, error)
	GetIntegration(context.Context, *Id) (*Integration, error)
	UpdateIntegrationMember(context.Context, *ResourceGroupMember) (*ResourceGroupMember, error)
	RemoveIntegrationMember(context.Context, *ResourceGroupMember) (*Empty, error)
	UpdateRule(context.Context, *Rule) (*Rule, error)
	CreateRule(context.Context, *Rule) (*Rule, error)
	DeleteRule(context.Context, *Id) (*Empty, error)
	ReadRule(context.Context, *Id) (*Rule, error)
	MatchRule(context.Context, *Ids) (*Response, error)
	ListRules2(context.Context, *ListRuleRequest) (*Response, error)
	GetRuleOrder(context.Context, *Id) (*RuleOrder, error)
	UpdateRuleOrder(context.Context, *RuleOrder) (*RuleOrder, error)
	ListPhoneDevices(context.Context, *Id) (*Response, error)
	CreatePhoneDevice(context.Context, *PhoneDevice) (*PhoneDevice, error)
	UpdatePhoneDevice(context.Context, *PhoneDevice) (*PhoneDevice, error)
	DeletePhoneDevice(context.Context, *Id) (*Empty, error)
	ReadPhoneDevice(context.Context, *Id) (*PhoneDevice, error)
	TestNumber(context.Context, *Id) (*Integration, error)
	ActiveNumber(context.Context, *Integration) (*Integration, error)
	ListCallSettings(context.Context, *Id) (*CallSettings, error)
	UpdateCallSetting(context.Context, *CallSetting) (*CallSetting, error)
	BlockNumber(context.Context, *BlockedNumber) (*BlockedNumber, error)
	ListBlockedNumbers(context.Context, *Id) (*BlockedNumbers, error)
	UnblockNumber(context.Context, *BlockedNumber) (*Empty, error)
	ListGreetingAudio(context.Context, *Id) (*GreetingAudios, error)
	CreateGreetingAudio(context.Context, *GreetingAudio) (*GreetingAudio, error)
	UpdateGreetingAudio(context.Context, *GreetingAudio) (*Response, error)
	DeleteGreetingAudio(context.Context, *Id) (*Response, error)
	// try to make an outbound call from subiz
	OriginateCall(context.Context, *StartRequest) (*Conversation, error)
	ListMyRecentCalls(context.Context, *Id) (*RecentCallRecords, error)
	// sync, called from fabikon
	SaveMessage(context.Context, *Event) (*Event, error)
	ApplyMessage(context.Context, *Event) (*Event, error)
	CountAgentUnreadMessages(context.Context, *Id) (*Response, error)
	OnWebUserCreated(context.Context, *Id) (*Empty, error)
	OnBotUpdated(context.Context, *Bot) (*Response, error)
	OnBotDeleted(context.Context, *Id) (*Response, error)
	OnAIAgentUpdated(context.Context, *AIAgent) (*Response, error)
	// for ai agent to notify human
	NotifyHuman(context.Context, *Event) (*Response, error)
	MarkAsHumanHandled(context.Context, *Id) (*Response, error)
	ReportMessages(context.Context, *ReportConvoMessageRequest) (*Response, error)
	VerifyWebsiteByVisit(context.Context, *Id) (*Response, error)
	VerifyWebsiteByDNS(context.Context, *Id) (*Response, error)
	mustEmbedUnimplementedConversationMgrServer()
}

// UnimplementedConversationMgrServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConversationMgrServer struct{}

func (UnimplementedConversationMgrServer) AssignRule(context.Context, *AssignRequest) (*RouteResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssignRule not implemented")
}
func (UnimplementedConversationMgrServer) ReassignConversation(context.Context, *Id) (*RouteResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReassignConversation not implemented")
}
func (UnimplementedConversationMgrServer) PongMessage(context.Context, *Event) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PongMessage not implemented")
}
func (UnimplementedConversationMgrServer) StartConversation(context.Context, *StartRequest) (*Conversation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartConversation not implemented")
}
func (UnimplementedConversationMgrServer) EndConversation(context.Context, *Id) (*Conversation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EndConversation not implemented")
}
func (UnimplementedConversationMgrServer) GetConversation(context.Context, *Id) (*Conversation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConversation not implemented")
}
func (UnimplementedConversationMgrServer) GetFullConversation(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFullConversation not implemented")
}
func (UnimplementedConversationMgrServer) ListConversations(context.Context, *ListConversationsRequest) (*Conversations, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListConversations not implemented")
}
func (UnimplementedConversationMgrServer) ListConversations2(context.Context, *ListConversationsRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListConversations2 not implemented")
}
func (UnimplementedConversationMgrServer) MatchConversations(context.Context, *Ids) (*Conversations, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchConversations not implemented")
}
func (UnimplementedConversationMgrServer) TagConversation(context.Context, *TagRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TagConversation not implemented")
}
func (UnimplementedConversationMgrServer) UntagConversation(context.Context, *TagRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UntagConversation not implemented")
}
func (UnimplementedConversationMgrServer) JoinConversation(context.Context, *ConversationMember) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinConversation not implemented")
}
func (UnimplementedConversationMgrServer) LeftConversation(context.Context, *ConversationMember) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeftConversation not implemented")
}
func (UnimplementedConversationMgrServer) MarkReadTopic(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkReadTopic not implemented")
}
func (UnimplementedConversationMgrServer) UpdateConversationInfo(context.Context, *Conversation) (*Conversation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateConversationInfo not implemented")
}
func (UnimplementedConversationMgrServer) UpdateMuteConversation(context.Context, *Conversation) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMuteConversation not implemented")
}
func (UnimplementedConversationMgrServer) UpdateConversationMember(context.Context, *ConversationMember) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateConversationMember not implemented")
}
func (UnimplementedConversationMgrServer) UnwatchConversation(context.Context, *Conversation) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnwatchConversation not implemented")
}
func (UnimplementedConversationMgrServer) UnhiddenConversation(context.Context, *Conversation) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnhiddenConversation not implemented")
}
func (UnimplementedConversationMgrServer) UnsentMessage(context.Context, *Event) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnsentMessage not implemented")
}
func (UnimplementedConversationMgrServer) DismissConversation(context.Context, *Conversation) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DismissConversation not implemented")
}
func (UnimplementedConversationMgrServer) ReconsiderConversation(context.Context, *Conversation) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReconsiderConversation not implemented")
}
func (UnimplementedConversationMgrServer) UpdateEndchatSetting(context.Context, *EndchatSetting) (*EndchatSetting, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateEndchatSetting not implemented")
}
func (UnimplementedConversationMgrServer) GetEndchatSetting(context.Context, *Id) (*EndchatSetting, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEndchatSetting not implemented")
}
func (UnimplementedConversationMgrServer) TerminateBot(context.Context, *BotTerminated) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TerminateBot not implemented")
}
func (UnimplementedConversationMgrServer) SendMessage(context.Context, *Event) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMessage not implemented")
}
func (UnimplementedConversationMgrServer) SendOmniChannelMessage(context.Context, *SendOmniChannelMessageRequest) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendOmniChannelMessage not implemented")
}
func (UnimplementedConversationMgrServer) UpdateMessage(context.Context, *Event) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMessage not implemented")
}
func (UnimplementedConversationMgrServer) ListEvents(context.Context, *ListConversationEventsRequest) (*Events, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListEvents not implemented")
}
func (UnimplementedConversationMgrServer) ReadConvoEvent(context.Context, *Message) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadConvoEvent not implemented")
}
func (UnimplementedConversationMgrServer) Deintegrate(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Deintegrate not implemented")
}
func (UnimplementedConversationMgrServer) ListIntegrations2(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListIntegrations2 not implemented")
}
func (UnimplementedConversationMgrServer) MatchIntegration(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchIntegration not implemented")
}
func (UnimplementedConversationMgrServer) Integrate(context.Context, *Integration) (*Integration, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Integrate not implemented")
}
func (UnimplementedConversationMgrServer) UpsertIntegration(context.Context, *Integration) (*Integration, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertIntegration not implemented")
}
func (UnimplementedConversationMgrServer) GetIntegration(context.Context, *Id) (*Integration, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIntegration not implemented")
}
func (UnimplementedConversationMgrServer) UpdateIntegrationMember(context.Context, *ResourceGroupMember) (*ResourceGroupMember, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateIntegrationMember not implemented")
}
func (UnimplementedConversationMgrServer) RemoveIntegrationMember(context.Context, *ResourceGroupMember) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveIntegrationMember not implemented")
}
func (UnimplementedConversationMgrServer) UpdateRule(context.Context, *Rule) (*Rule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRule not implemented")
}
func (UnimplementedConversationMgrServer) CreateRule(context.Context, *Rule) (*Rule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRule not implemented")
}
func (UnimplementedConversationMgrServer) DeleteRule(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRule not implemented")
}
func (UnimplementedConversationMgrServer) ReadRule(context.Context, *Id) (*Rule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadRule not implemented")
}
func (UnimplementedConversationMgrServer) MatchRule(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchRule not implemented")
}
func (UnimplementedConversationMgrServer) ListRules2(context.Context, *ListRuleRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRules2 not implemented")
}
func (UnimplementedConversationMgrServer) GetRuleOrder(context.Context, *Id) (*RuleOrder, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRuleOrder not implemented")
}
func (UnimplementedConversationMgrServer) UpdateRuleOrder(context.Context, *RuleOrder) (*RuleOrder, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRuleOrder not implemented")
}
func (UnimplementedConversationMgrServer) ListPhoneDevices(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPhoneDevices not implemented")
}
func (UnimplementedConversationMgrServer) CreatePhoneDevice(context.Context, *PhoneDevice) (*PhoneDevice, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePhoneDevice not implemented")
}
func (UnimplementedConversationMgrServer) UpdatePhoneDevice(context.Context, *PhoneDevice) (*PhoneDevice, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePhoneDevice not implemented")
}
func (UnimplementedConversationMgrServer) DeletePhoneDevice(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePhoneDevice not implemented")
}
func (UnimplementedConversationMgrServer) ReadPhoneDevice(context.Context, *Id) (*PhoneDevice, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadPhoneDevice not implemented")
}
func (UnimplementedConversationMgrServer) TestNumber(context.Context, *Id) (*Integration, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestNumber not implemented")
}
func (UnimplementedConversationMgrServer) ActiveNumber(context.Context, *Integration) (*Integration, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActiveNumber not implemented")
}
func (UnimplementedConversationMgrServer) ListCallSettings(context.Context, *Id) (*CallSettings, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCallSettings not implemented")
}
func (UnimplementedConversationMgrServer) UpdateCallSetting(context.Context, *CallSetting) (*CallSetting, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCallSetting not implemented")
}
func (UnimplementedConversationMgrServer) BlockNumber(context.Context, *BlockedNumber) (*BlockedNumber, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockNumber not implemented")
}
func (UnimplementedConversationMgrServer) ListBlockedNumbers(context.Context, *Id) (*BlockedNumbers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBlockedNumbers not implemented")
}
func (UnimplementedConversationMgrServer) UnblockNumber(context.Context, *BlockedNumber) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnblockNumber not implemented")
}
func (UnimplementedConversationMgrServer) ListGreetingAudio(context.Context, *Id) (*GreetingAudios, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGreetingAudio not implemented")
}
func (UnimplementedConversationMgrServer) CreateGreetingAudio(context.Context, *GreetingAudio) (*GreetingAudio, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateGreetingAudio not implemented")
}
func (UnimplementedConversationMgrServer) UpdateGreetingAudio(context.Context, *GreetingAudio) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGreetingAudio not implemented")
}
func (UnimplementedConversationMgrServer) DeleteGreetingAudio(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGreetingAudio not implemented")
}
func (UnimplementedConversationMgrServer) OriginateCall(context.Context, *StartRequest) (*Conversation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OriginateCall not implemented")
}
func (UnimplementedConversationMgrServer) ListMyRecentCalls(context.Context, *Id) (*RecentCallRecords, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMyRecentCalls not implemented")
}
func (UnimplementedConversationMgrServer) SaveMessage(context.Context, *Event) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveMessage not implemented")
}
func (UnimplementedConversationMgrServer) ApplyMessage(context.Context, *Event) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyMessage not implemented")
}
func (UnimplementedConversationMgrServer) CountAgentUnreadMessages(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountAgentUnreadMessages not implemented")
}
func (UnimplementedConversationMgrServer) OnWebUserCreated(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnWebUserCreated not implemented")
}
func (UnimplementedConversationMgrServer) OnBotUpdated(context.Context, *Bot) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnBotUpdated not implemented")
}
func (UnimplementedConversationMgrServer) OnBotDeleted(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnBotDeleted not implemented")
}
func (UnimplementedConversationMgrServer) OnAIAgentUpdated(context.Context, *AIAgent) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnAIAgentUpdated not implemented")
}
func (UnimplementedConversationMgrServer) NotifyHuman(context.Context, *Event) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyHuman not implemented")
}
func (UnimplementedConversationMgrServer) MarkAsHumanHandled(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkAsHumanHandled not implemented")
}
func (UnimplementedConversationMgrServer) ReportMessages(context.Context, *ReportConvoMessageRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportMessages not implemented")
}
func (UnimplementedConversationMgrServer) VerifyWebsiteByVisit(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyWebsiteByVisit not implemented")
}
func (UnimplementedConversationMgrServer) VerifyWebsiteByDNS(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyWebsiteByDNS not implemented")
}
func (UnimplementedConversationMgrServer) mustEmbedUnimplementedConversationMgrServer() {}
func (UnimplementedConversationMgrServer) testEmbeddedByValue()                         {}

// UnsafeConversationMgrServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConversationMgrServer will
// result in compilation errors.
type UnsafeConversationMgrServer interface {
	mustEmbedUnimplementedConversationMgrServer()
}

func RegisterConversationMgrServer(s grpc.ServiceRegistrar, srv ConversationMgrServer) {
	// If the following call pancis, it indicates UnimplementedConversationMgrServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ConversationMgr_ServiceDesc, srv)
}

func _ConversationMgr_AssignRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).AssignRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_AssignRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).AssignRule(ctx, req.(*AssignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_ReassignConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).ReassignConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_ReassignConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).ReassignConversation(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_PongMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).PongMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_PongMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).PongMessage(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_StartConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).StartConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_StartConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).StartConversation(ctx, req.(*StartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_EndConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).EndConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_EndConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).EndConversation(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_GetConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).GetConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_GetConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).GetConversation(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_GetFullConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).GetFullConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_GetFullConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).GetFullConversation(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_ListConversations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListConversationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).ListConversations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_ListConversations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).ListConversations(ctx, req.(*ListConversationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_ListConversations2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListConversationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).ListConversations2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_ListConversations2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).ListConversations2(ctx, req.(*ListConversationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_MatchConversations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).MatchConversations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_MatchConversations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).MatchConversations(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_TagConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).TagConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_TagConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).TagConversation(ctx, req.(*TagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_UntagConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).UntagConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_UntagConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).UntagConversation(ctx, req.(*TagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_JoinConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConversationMember)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).JoinConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_JoinConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).JoinConversation(ctx, req.(*ConversationMember))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_LeftConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConversationMember)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).LeftConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_LeftConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).LeftConversation(ctx, req.(*ConversationMember))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_MarkReadTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).MarkReadTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_MarkReadTopic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).MarkReadTopic(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_UpdateConversationInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Conversation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).UpdateConversationInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_UpdateConversationInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).UpdateConversationInfo(ctx, req.(*Conversation))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_UpdateMuteConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Conversation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).UpdateMuteConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_UpdateMuteConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).UpdateMuteConversation(ctx, req.(*Conversation))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_UpdateConversationMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConversationMember)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).UpdateConversationMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_UpdateConversationMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).UpdateConversationMember(ctx, req.(*ConversationMember))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_UnwatchConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Conversation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).UnwatchConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_UnwatchConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).UnwatchConversation(ctx, req.(*Conversation))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_UnhiddenConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Conversation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).UnhiddenConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_UnhiddenConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).UnhiddenConversation(ctx, req.(*Conversation))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_UnsentMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).UnsentMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_UnsentMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).UnsentMessage(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_DismissConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Conversation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).DismissConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_DismissConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).DismissConversation(ctx, req.(*Conversation))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_ReconsiderConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Conversation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).ReconsiderConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_ReconsiderConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).ReconsiderConversation(ctx, req.(*Conversation))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_UpdateEndchatSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndchatSetting)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).UpdateEndchatSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_UpdateEndchatSetting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).UpdateEndchatSetting(ctx, req.(*EndchatSetting))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_GetEndchatSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).GetEndchatSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_GetEndchatSetting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).GetEndchatSetting(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_TerminateBot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BotTerminated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).TerminateBot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_TerminateBot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).TerminateBot(ctx, req.(*BotTerminated))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_SendMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).SendMessage(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_SendOmniChannelMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendOmniChannelMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).SendOmniChannelMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_SendOmniChannelMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).SendOmniChannelMessage(ctx, req.(*SendOmniChannelMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_UpdateMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).UpdateMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_UpdateMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).UpdateMessage(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_ListEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListConversationEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).ListEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_ListEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).ListEvents(ctx, req.(*ListConversationEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_ReadConvoEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).ReadConvoEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_ReadConvoEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).ReadConvoEvent(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_Deintegrate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).Deintegrate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_Deintegrate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).Deintegrate(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_ListIntegrations2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).ListIntegrations2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_ListIntegrations2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).ListIntegrations2(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_MatchIntegration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).MatchIntegration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_MatchIntegration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).MatchIntegration(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_Integrate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Integration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).Integrate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_Integrate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).Integrate(ctx, req.(*Integration))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_UpsertIntegration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Integration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).UpsertIntegration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_UpsertIntegration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).UpsertIntegration(ctx, req.(*Integration))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_GetIntegration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).GetIntegration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_GetIntegration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).GetIntegration(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_UpdateIntegrationMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceGroupMember)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).UpdateIntegrationMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_UpdateIntegrationMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).UpdateIntegrationMember(ctx, req.(*ResourceGroupMember))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_RemoveIntegrationMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceGroupMember)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).RemoveIntegrationMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_RemoveIntegrationMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).RemoveIntegrationMember(ctx, req.(*ResourceGroupMember))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_UpdateRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Rule)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).UpdateRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_UpdateRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).UpdateRule(ctx, req.(*Rule))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_CreateRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Rule)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).CreateRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_CreateRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).CreateRule(ctx, req.(*Rule))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_DeleteRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).DeleteRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_DeleteRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).DeleteRule(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_ReadRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).ReadRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_ReadRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).ReadRule(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_MatchRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).MatchRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_MatchRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).MatchRule(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_ListRules2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).ListRules2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_ListRules2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).ListRules2(ctx, req.(*ListRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_GetRuleOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).GetRuleOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_GetRuleOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).GetRuleOrder(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_UpdateRuleOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).UpdateRuleOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_UpdateRuleOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).UpdateRuleOrder(ctx, req.(*RuleOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_ListPhoneDevices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).ListPhoneDevices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_ListPhoneDevices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).ListPhoneDevices(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_CreatePhoneDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PhoneDevice)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).CreatePhoneDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_CreatePhoneDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).CreatePhoneDevice(ctx, req.(*PhoneDevice))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_UpdatePhoneDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PhoneDevice)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).UpdatePhoneDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_UpdatePhoneDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).UpdatePhoneDevice(ctx, req.(*PhoneDevice))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_DeletePhoneDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).DeletePhoneDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_DeletePhoneDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).DeletePhoneDevice(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_ReadPhoneDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).ReadPhoneDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_ReadPhoneDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).ReadPhoneDevice(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_TestNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).TestNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_TestNumber_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).TestNumber(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_ActiveNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Integration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).ActiveNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_ActiveNumber_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).ActiveNumber(ctx, req.(*Integration))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_ListCallSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).ListCallSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_ListCallSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).ListCallSettings(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_UpdateCallSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallSetting)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).UpdateCallSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_UpdateCallSetting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).UpdateCallSetting(ctx, req.(*CallSetting))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_BlockNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockedNumber)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).BlockNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_BlockNumber_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).BlockNumber(ctx, req.(*BlockedNumber))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_ListBlockedNumbers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).ListBlockedNumbers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_ListBlockedNumbers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).ListBlockedNumbers(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_UnblockNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockedNumber)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).UnblockNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_UnblockNumber_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).UnblockNumber(ctx, req.(*BlockedNumber))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_ListGreetingAudio_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).ListGreetingAudio(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_ListGreetingAudio_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).ListGreetingAudio(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_CreateGreetingAudio_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GreetingAudio)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).CreateGreetingAudio(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_CreateGreetingAudio_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).CreateGreetingAudio(ctx, req.(*GreetingAudio))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_UpdateGreetingAudio_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GreetingAudio)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).UpdateGreetingAudio(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_UpdateGreetingAudio_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).UpdateGreetingAudio(ctx, req.(*GreetingAudio))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_DeleteGreetingAudio_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).DeleteGreetingAudio(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_DeleteGreetingAudio_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).DeleteGreetingAudio(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_OriginateCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).OriginateCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_OriginateCall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).OriginateCall(ctx, req.(*StartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_ListMyRecentCalls_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).ListMyRecentCalls(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_ListMyRecentCalls_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).ListMyRecentCalls(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_SaveMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).SaveMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_SaveMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).SaveMessage(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_ApplyMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).ApplyMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_ApplyMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).ApplyMessage(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_CountAgentUnreadMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).CountAgentUnreadMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_CountAgentUnreadMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).CountAgentUnreadMessages(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_OnWebUserCreated_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).OnWebUserCreated(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_OnWebUserCreated_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).OnWebUserCreated(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_OnBotUpdated_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Bot)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).OnBotUpdated(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_OnBotUpdated_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).OnBotUpdated(ctx, req.(*Bot))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_OnBotDeleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).OnBotDeleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_OnBotDeleted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).OnBotDeleted(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_OnAIAgentUpdated_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AIAgent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).OnAIAgentUpdated(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_OnAIAgentUpdated_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).OnAIAgentUpdated(ctx, req.(*AIAgent))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_NotifyHuman_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).NotifyHuman(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_NotifyHuman_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).NotifyHuman(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_MarkAsHumanHandled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).MarkAsHumanHandled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_MarkAsHumanHandled_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).MarkAsHumanHandled(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_ReportMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportConvoMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).ReportMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_ReportMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).ReportMessages(ctx, req.(*ReportConvoMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_VerifyWebsiteByVisit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).VerifyWebsiteByVisit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_VerifyWebsiteByVisit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).VerifyWebsiteByVisit(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_VerifyWebsiteByDNS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).VerifyWebsiteByDNS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationMgr_VerifyWebsiteByDNS_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).VerifyWebsiteByDNS(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

// ConversationMgr_ServiceDesc is the grpc.ServiceDesc for ConversationMgr service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConversationMgr_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.ConversationMgr",
	HandlerType: (*ConversationMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AssignRule",
			Handler:    _ConversationMgr_AssignRule_Handler,
		},
		{
			MethodName: "ReassignConversation",
			Handler:    _ConversationMgr_ReassignConversation_Handler,
		},
		{
			MethodName: "PongMessage",
			Handler:    _ConversationMgr_PongMessage_Handler,
		},
		{
			MethodName: "StartConversation",
			Handler:    _ConversationMgr_StartConversation_Handler,
		},
		{
			MethodName: "EndConversation",
			Handler:    _ConversationMgr_EndConversation_Handler,
		},
		{
			MethodName: "GetConversation",
			Handler:    _ConversationMgr_GetConversation_Handler,
		},
		{
			MethodName: "GetFullConversation",
			Handler:    _ConversationMgr_GetFullConversation_Handler,
		},
		{
			MethodName: "ListConversations",
			Handler:    _ConversationMgr_ListConversations_Handler,
		},
		{
			MethodName: "ListConversations2",
			Handler:    _ConversationMgr_ListConversations2_Handler,
		},
		{
			MethodName: "MatchConversations",
			Handler:    _ConversationMgr_MatchConversations_Handler,
		},
		{
			MethodName: "TagConversation",
			Handler:    _ConversationMgr_TagConversation_Handler,
		},
		{
			MethodName: "UntagConversation",
			Handler:    _ConversationMgr_UntagConversation_Handler,
		},
		{
			MethodName: "JoinConversation",
			Handler:    _ConversationMgr_JoinConversation_Handler,
		},
		{
			MethodName: "LeftConversation",
			Handler:    _ConversationMgr_LeftConversation_Handler,
		},
		{
			MethodName: "MarkReadTopic",
			Handler:    _ConversationMgr_MarkReadTopic_Handler,
		},
		{
			MethodName: "UpdateConversationInfo",
			Handler:    _ConversationMgr_UpdateConversationInfo_Handler,
		},
		{
			MethodName: "UpdateMuteConversation",
			Handler:    _ConversationMgr_UpdateMuteConversation_Handler,
		},
		{
			MethodName: "UpdateConversationMember",
			Handler:    _ConversationMgr_UpdateConversationMember_Handler,
		},
		{
			MethodName: "UnwatchConversation",
			Handler:    _ConversationMgr_UnwatchConversation_Handler,
		},
		{
			MethodName: "UnhiddenConversation",
			Handler:    _ConversationMgr_UnhiddenConversation_Handler,
		},
		{
			MethodName: "UnsentMessage",
			Handler:    _ConversationMgr_UnsentMessage_Handler,
		},
		{
			MethodName: "DismissConversation",
			Handler:    _ConversationMgr_DismissConversation_Handler,
		},
		{
			MethodName: "ReconsiderConversation",
			Handler:    _ConversationMgr_ReconsiderConversation_Handler,
		},
		{
			MethodName: "UpdateEndchatSetting",
			Handler:    _ConversationMgr_UpdateEndchatSetting_Handler,
		},
		{
			MethodName: "GetEndchatSetting",
			Handler:    _ConversationMgr_GetEndchatSetting_Handler,
		},
		{
			MethodName: "TerminateBot",
			Handler:    _ConversationMgr_TerminateBot_Handler,
		},
		{
			MethodName: "SendMessage",
			Handler:    _ConversationMgr_SendMessage_Handler,
		},
		{
			MethodName: "SendOmniChannelMessage",
			Handler:    _ConversationMgr_SendOmniChannelMessage_Handler,
		},
		{
			MethodName: "UpdateMessage",
			Handler:    _ConversationMgr_UpdateMessage_Handler,
		},
		{
			MethodName: "ListEvents",
			Handler:    _ConversationMgr_ListEvents_Handler,
		},
		{
			MethodName: "ReadConvoEvent",
			Handler:    _ConversationMgr_ReadConvoEvent_Handler,
		},
		{
			MethodName: "Deintegrate",
			Handler:    _ConversationMgr_Deintegrate_Handler,
		},
		{
			MethodName: "ListIntegrations2",
			Handler:    _ConversationMgr_ListIntegrations2_Handler,
		},
		{
			MethodName: "MatchIntegration",
			Handler:    _ConversationMgr_MatchIntegration_Handler,
		},
		{
			MethodName: "Integrate",
			Handler:    _ConversationMgr_Integrate_Handler,
		},
		{
			MethodName: "UpsertIntegration",
			Handler:    _ConversationMgr_UpsertIntegration_Handler,
		},
		{
			MethodName: "GetIntegration",
			Handler:    _ConversationMgr_GetIntegration_Handler,
		},
		{
			MethodName: "UpdateIntegrationMember",
			Handler:    _ConversationMgr_UpdateIntegrationMember_Handler,
		},
		{
			MethodName: "RemoveIntegrationMember",
			Handler:    _ConversationMgr_RemoveIntegrationMember_Handler,
		},
		{
			MethodName: "UpdateRule",
			Handler:    _ConversationMgr_UpdateRule_Handler,
		},
		{
			MethodName: "CreateRule",
			Handler:    _ConversationMgr_CreateRule_Handler,
		},
		{
			MethodName: "DeleteRule",
			Handler:    _ConversationMgr_DeleteRule_Handler,
		},
		{
			MethodName: "ReadRule",
			Handler:    _ConversationMgr_ReadRule_Handler,
		},
		{
			MethodName: "MatchRule",
			Handler:    _ConversationMgr_MatchRule_Handler,
		},
		{
			MethodName: "ListRules2",
			Handler:    _ConversationMgr_ListRules2_Handler,
		},
		{
			MethodName: "GetRuleOrder",
			Handler:    _ConversationMgr_GetRuleOrder_Handler,
		},
		{
			MethodName: "UpdateRuleOrder",
			Handler:    _ConversationMgr_UpdateRuleOrder_Handler,
		},
		{
			MethodName: "ListPhoneDevices",
			Handler:    _ConversationMgr_ListPhoneDevices_Handler,
		},
		{
			MethodName: "CreatePhoneDevice",
			Handler:    _ConversationMgr_CreatePhoneDevice_Handler,
		},
		{
			MethodName: "UpdatePhoneDevice",
			Handler:    _ConversationMgr_UpdatePhoneDevice_Handler,
		},
		{
			MethodName: "DeletePhoneDevice",
			Handler:    _ConversationMgr_DeletePhoneDevice_Handler,
		},
		{
			MethodName: "ReadPhoneDevice",
			Handler:    _ConversationMgr_ReadPhoneDevice_Handler,
		},
		{
			MethodName: "TestNumber",
			Handler:    _ConversationMgr_TestNumber_Handler,
		},
		{
			MethodName: "ActiveNumber",
			Handler:    _ConversationMgr_ActiveNumber_Handler,
		},
		{
			MethodName: "ListCallSettings",
			Handler:    _ConversationMgr_ListCallSettings_Handler,
		},
		{
			MethodName: "UpdateCallSetting",
			Handler:    _ConversationMgr_UpdateCallSetting_Handler,
		},
		{
			MethodName: "BlockNumber",
			Handler:    _ConversationMgr_BlockNumber_Handler,
		},
		{
			MethodName: "ListBlockedNumbers",
			Handler:    _ConversationMgr_ListBlockedNumbers_Handler,
		},
		{
			MethodName: "UnblockNumber",
			Handler:    _ConversationMgr_UnblockNumber_Handler,
		},
		{
			MethodName: "ListGreetingAudio",
			Handler:    _ConversationMgr_ListGreetingAudio_Handler,
		},
		{
			MethodName: "CreateGreetingAudio",
			Handler:    _ConversationMgr_CreateGreetingAudio_Handler,
		},
		{
			MethodName: "UpdateGreetingAudio",
			Handler:    _ConversationMgr_UpdateGreetingAudio_Handler,
		},
		{
			MethodName: "DeleteGreetingAudio",
			Handler:    _ConversationMgr_DeleteGreetingAudio_Handler,
		},
		{
			MethodName: "OriginateCall",
			Handler:    _ConversationMgr_OriginateCall_Handler,
		},
		{
			MethodName: "ListMyRecentCalls",
			Handler:    _ConversationMgr_ListMyRecentCalls_Handler,
		},
		{
			MethodName: "SaveMessage",
			Handler:    _ConversationMgr_SaveMessage_Handler,
		},
		{
			MethodName: "ApplyMessage",
			Handler:    _ConversationMgr_ApplyMessage_Handler,
		},
		{
			MethodName: "CountAgentUnreadMessages",
			Handler:    _ConversationMgr_CountAgentUnreadMessages_Handler,
		},
		{
			MethodName: "OnWebUserCreated",
			Handler:    _ConversationMgr_OnWebUserCreated_Handler,
		},
		{
			MethodName: "OnBotUpdated",
			Handler:    _ConversationMgr_OnBotUpdated_Handler,
		},
		{
			MethodName: "OnBotDeleted",
			Handler:    _ConversationMgr_OnBotDeleted_Handler,
		},
		{
			MethodName: "OnAIAgentUpdated",
			Handler:    _ConversationMgr_OnAIAgentUpdated_Handler,
		},
		{
			MethodName: "NotifyHuman",
			Handler:    _ConversationMgr_NotifyHuman_Handler,
		},
		{
			MethodName: "MarkAsHumanHandled",
			Handler:    _ConversationMgr_MarkAsHumanHandled_Handler,
		},
		{
			MethodName: "ReportMessages",
			Handler:    _ConversationMgr_ReportMessages_Handler,
		},
		{
			MethodName: "VerifyWebsiteByVisit",
			Handler:    _ConversationMgr_VerifyWebsiteByVisit_Handler,
		},
		{
			MethodName: "VerifyWebsiteByDNS",
			Handler:    _ConversationMgr_VerifyWebsiteByDNS_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	TicketMgr_CreateTicketType_FullMethodName          = "/header.TicketMgr/CreateTicketType"
	TicketMgr_UpdateTicketType_FullMethodName          = "/header.TicketMgr/UpdateTicketType"
	TicketMgr_ListTicketTypes_FullMethodName           = "/header.TicketMgr/ListTicketTypes"
	TicketMgr_GetTicketType_FullMethodName             = "/header.TicketMgr/GetTicketType"
	TicketMgr_DeleteTicketType_FullMethodName          = "/header.TicketMgr/DeleteTicketType"
	TicketMgr_CreateTicket_FullMethodName              = "/header.TicketMgr/CreateTicket"
	TicketMgr_UpdateTicket_FullMethodName              = "/header.TicketMgr/UpdateTicket"
	TicketMgr_DeleteTicket_FullMethodName              = "/header.TicketMgr/DeleteTicket"
	TicketMgr_RecoverTicket_FullMethodName             = "/header.TicketMgr/RecoverTicket"
	TicketMgr_GetTicket_FullMethodName                 = "/header.TicketMgr/GetTicket"
	TicketMgr_ListTickets_FullMethodName               = "/header.TicketMgr/ListTickets"
	TicketMgr_MatchTickets_FullMethodName              = "/header.TicketMgr/MatchTickets"
	TicketMgr_CreateTicketView_FullMethodName          = "/header.TicketMgr/CreateTicketView"
	TicketMgr_UpdateTicketView_FullMethodName          = "/header.TicketMgr/UpdateTicketView"
	TicketMgr_DeleteTicketView_FullMethodName          = "/header.TicketMgr/DeleteTicketView"
	TicketMgr_GetTicketView_FullMethodName             = "/header.TicketMgr/GetTicketView"
	TicketMgr_ListTicketViews_FullMethodName           = "/header.TicketMgr/ListTicketViews"
	TicketMgr_CreateTicketTemplate_FullMethodName      = "/header.TicketMgr/CreateTicketTemplate"
	TicketMgr_UpdateTicketTemplate_FullMethodName      = "/header.TicketMgr/UpdateTicketTemplate"
	TicketMgr_DeleteTicketTemplate_FullMethodName      = "/header.TicketMgr/DeleteTicketTemplate"
	TicketMgr_GetTicketTemplate_FullMethodName         = "/header.TicketMgr/GetTicketTemplate"
	TicketMgr_ListTicketTemplates_FullMethodName       = "/header.TicketMgr/ListTicketTemplates"
	TicketMgr_PongTicketEvent_FullMethodName           = "/header.TicketMgr/PongTicketEvent"
	TicketMgr_TagTicket_FullMethodName                 = "/header.TicketMgr/TagTicket"
	TicketMgr_UntagTicket_FullMethodName               = "/header.TicketMgr/UntagTicket"
	TicketMgr_JoinTicket_FullMethodName                = "/header.TicketMgr/JoinTicket"
	TicketMgr_LeftTicket_FullMethodName                = "/header.TicketMgr/LeftTicket"
	TicketMgr_ReadTickets_FullMethodName               = "/header.TicketMgr/ReadTickets"
	TicketMgr_UnreadTickets_FullMethodName             = "/header.TicketMgr/UnreadTickets"
	TicketMgr_SubscribedTickets_FullMethodName         = "/header.TicketMgr/SubscribedTickets"
	TicketMgr_UnSubscribedTickets_FullMethodName       = "/header.TicketMgr/UnSubscribedTickets"
	TicketMgr_SendTicketEvent_FullMethodName           = "/header.TicketMgr/SendTicketEvent"
	TicketMgr_ListTicketEvents_FullMethodName          = "/header.TicketMgr/ListTicketEvents"
	TicketMgr_ListImportantTicketEvents_FullMethodName = "/header.TicketMgr/ListImportantTicketEvents"
	TicketMgr_UpdateTicketTypeMember_FullMethodName    = "/header.TicketMgr/UpdateTicketTypeMember"
	TicketMgr_RemoveTicketTypeMember_FullMethodName    = "/header.TicketMgr/RemoveTicketTypeMember"
	TicketMgr_CreateSLAPolicy_FullMethodName           = "/header.TicketMgr/CreateSLAPolicy"
	TicketMgr_UpdateSLAPolicy_FullMethodName           = "/header.TicketMgr/UpdateSLAPolicy"
	TicketMgr_DeleteSLAPolicy_FullMethodName           = "/header.TicketMgr/DeleteSLAPolicy"
	TicketMgr_ListSLAPolicies_FullMethodName           = "/header.TicketMgr/ListSLAPolicies"
	TicketMgr_GetSLAPolicy_FullMethodName              = "/header.TicketMgr/GetSLAPolicy"
	TicketMgr_ListTicketSLAViolations_FullMethodName   = "/header.TicketMgr/ListTicketSLAViolations"
	TicketMgr_RateTicket_FullMethodName                = "/header.TicketMgr/RateTicket"
	TicketMgr_GetTicketRating_FullMethodName           = "/header.TicketMgr/GetTicketRating"
	TicketMgr_UpdateTicketRule_FullMethodName          = "/header.TicketMgr/UpdateTicketRule"
	TicketMgr_CreateTicketRule_FullMethodName          = "/header.TicketMgr/CreateTicketRule"
	TicketMgr_DeleteTicketRule_FullMethodName          = "/header.TicketMgr/DeleteTicketRule"
	TicketMgr_ReadTicketRule_FullMethodName            = "/header.TicketMgr/ReadTicketRule"
	TicketMgr_ListTicketRules_FullMethodName           = "/header.TicketMgr/ListTicketRules"
	TicketMgr_ReportTickets_FullMethodName             = "/header.TicketMgr/ReportTickets"
	TicketMgr_ReportSlaViolations_FullMethodName       = "/header.TicketMgr/ReportSlaViolations"
	TicketMgr_ReportRatings_FullMethodName             = "/header.TicketMgr/ReportRatings"
	TicketMgr_ListRatings_FullMethodName               = "/header.TicketMgr/ListRatings"
	TicketMgr_ListSlaViolations_FullMethodName         = "/header.TicketMgr/ListSlaViolations"
	TicketMgr_GetTicketIdsByConvoId_FullMethodName     = "/header.TicketMgr/GetTicketIdsByConvoId"
)

// TicketMgrClient is the client API for TicketMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TicketMgrClient interface {
	// ticket type
	CreateTicketType(ctx context.Context, in *TicketType, opts ...grpc.CallOption) (*TicketType, error)
	UpdateTicketType(ctx context.Context, in *TicketType, opts ...grpc.CallOption) (*TicketType, error)
	ListTicketTypes(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	GetTicketType(ctx context.Context, in *Id, opts ...grpc.CallOption) (*TicketType, error)
	DeleteTicketType(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	CreateTicket(ctx context.Context, in *Ticket, opts ...grpc.CallOption) (*Ticket, error)
	UpdateTicket(ctx context.Context, in *Ticket, opts ...grpc.CallOption) (*Ticket, error)
	DeleteTicket(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	RecoverTicket(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	GetTicket(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Ticket, error)
	ListTickets(ctx context.Context, in *ListTicketRequest, opts ...grpc.CallOption) (*Response, error)
	MatchTickets(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
	CreateTicketView(ctx context.Context, in *TicketView, opts ...grpc.CallOption) (*TicketView, error)
	UpdateTicketView(ctx context.Context, in *TicketView, opts ...grpc.CallOption) (*TicketView, error)
	DeleteTicketView(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	GetTicketView(ctx context.Context, in *Id, opts ...grpc.CallOption) (*TicketView, error)
	ListTicketViews(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Response, error)
	CreateTicketTemplate(ctx context.Context, in *TicketTemplate, opts ...grpc.CallOption) (*TicketTemplate, error)
	UpdateTicketTemplate(ctx context.Context, in *TicketTemplate, opts ...grpc.CallOption) (*TicketTemplate, error)
	DeleteTicketTemplate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	GetTicketTemplate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*TicketTemplate, error)
	ListTicketTemplates(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Response, error)
	PongTicketEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error)
	TagTicket(ctx context.Context, in *TagRequest, opts ...grpc.CallOption) (*Empty, error)
	UntagTicket(ctx context.Context, in *TagRequest, opts ...grpc.CallOption) (*Empty, error)
	JoinTicket(ctx context.Context, in *ConversationMember, opts ...grpc.CallOption) (*Empty, error)
	LeftTicket(ctx context.Context, in *ConversationMember, opts ...grpc.CallOption) (*Empty, error)
	ReadTickets(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Empty, error)
	UnreadTickets(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Empty, error)
	SubscribedTickets(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Empty, error)
	UnSubscribedTickets(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Empty, error)
	SendTicketEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error)
	ListTicketEvents(ctx context.Context, in *ListConversationEventsRequest, opts ...grpc.CallOption) (*Events, error)
	ListImportantTicketEvents(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Events, error)
	UpdateTicketTypeMember(ctx context.Context, in *ResourceGroupMember, opts ...grpc.CallOption) (*ResourceGroupMember, error)
	RemoveTicketTypeMember(ctx context.Context, in *ResourceGroupMember, opts ...grpc.CallOption) (*Empty, error)
	CreateSLAPolicy(ctx context.Context, in *SLAPolicy, opts ...grpc.CallOption) (*SLAPolicy, error)
	UpdateSLAPolicy(ctx context.Context, in *SLAPolicy, opts ...grpc.CallOption) (*SLAPolicy, error)
	DeleteSLAPolicy(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ListSLAPolicies(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Response, error)
	GetSLAPolicy(ctx context.Context, in *Id, opts ...grpc.CallOption) (*SLAPolicy, error)
	ListTicketSLAViolations(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	RateTicket(ctx context.Context, in *Rating, opts ...grpc.CallOption) (*Response, error)
	GetTicketRating(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Rating, error)
	UpdateTicketRule(ctx context.Context, in *Rule, opts ...grpc.CallOption) (*Response, error)
	CreateTicketRule(ctx context.Context, in *Rule, opts ...grpc.CallOption) (*Response, error)
	DeleteTicketRule(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ReadTicketRule(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	ListTicketRules(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	ReportTickets(ctx context.Context, in *ConvoReportRequest, opts ...grpc.CallOption) (*ConvoReportResponse, error)
	ReportSlaViolations(ctx context.Context, in *ConvoReportRequest, opts ...grpc.CallOption) (*ConvoReportResponse, error)
	ReportRatings(ctx context.Context, in *ConvoReportRequest, opts ...grpc.CallOption) (*ConvoReportResponse, error)
	ListRatings(ctx context.Context, in *ConvoReportRequest, opts ...grpc.CallOption) (*Response, error)
	ListSlaViolations(ctx context.Context, in *ConvoReportRequest, opts ...grpc.CallOption) (*Response, error)
	// internal only
	GetTicketIdsByConvoId(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Ids, error)
}

type ticketMgrClient struct {
	cc grpc.ClientConnInterface
}

func NewTicketMgrClient(cc grpc.ClientConnInterface) TicketMgrClient {
	return &ticketMgrClient{cc}
}

func (c *ticketMgrClient) CreateTicketType(ctx context.Context, in *TicketType, opts ...grpc.CallOption) (*TicketType, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TicketType)
	err := c.cc.Invoke(ctx, TicketMgr_CreateTicketType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) UpdateTicketType(ctx context.Context, in *TicketType, opts ...grpc.CallOption) (*TicketType, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TicketType)
	err := c.cc.Invoke(ctx, TicketMgr_UpdateTicketType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) ListTicketTypes(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, TicketMgr_ListTicketTypes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) GetTicketType(ctx context.Context, in *Id, opts ...grpc.CallOption) (*TicketType, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TicketType)
	err := c.cc.Invoke(ctx, TicketMgr_GetTicketType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) DeleteTicketType(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TicketMgr_DeleteTicketType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) CreateTicket(ctx context.Context, in *Ticket, opts ...grpc.CallOption) (*Ticket, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Ticket)
	err := c.cc.Invoke(ctx, TicketMgr_CreateTicket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) UpdateTicket(ctx context.Context, in *Ticket, opts ...grpc.CallOption) (*Ticket, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Ticket)
	err := c.cc.Invoke(ctx, TicketMgr_UpdateTicket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) DeleteTicket(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TicketMgr_DeleteTicket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) RecoverTicket(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TicketMgr_RecoverTicket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) GetTicket(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Ticket, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Ticket)
	err := c.cc.Invoke(ctx, TicketMgr_GetTicket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) ListTickets(ctx context.Context, in *ListTicketRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, TicketMgr_ListTickets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) MatchTickets(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, TicketMgr_MatchTickets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) CreateTicketView(ctx context.Context, in *TicketView, opts ...grpc.CallOption) (*TicketView, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TicketView)
	err := c.cc.Invoke(ctx, TicketMgr_CreateTicketView_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) UpdateTicketView(ctx context.Context, in *TicketView, opts ...grpc.CallOption) (*TicketView, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TicketView)
	err := c.cc.Invoke(ctx, TicketMgr_UpdateTicketView_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) DeleteTicketView(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TicketMgr_DeleteTicketView_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) GetTicketView(ctx context.Context, in *Id, opts ...grpc.CallOption) (*TicketView, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TicketView)
	err := c.cc.Invoke(ctx, TicketMgr_GetTicketView_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) ListTicketViews(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, TicketMgr_ListTicketViews_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) CreateTicketTemplate(ctx context.Context, in *TicketTemplate, opts ...grpc.CallOption) (*TicketTemplate, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TicketTemplate)
	err := c.cc.Invoke(ctx, TicketMgr_CreateTicketTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) UpdateTicketTemplate(ctx context.Context, in *TicketTemplate, opts ...grpc.CallOption) (*TicketTemplate, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TicketTemplate)
	err := c.cc.Invoke(ctx, TicketMgr_UpdateTicketTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) DeleteTicketTemplate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TicketMgr_DeleteTicketTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) GetTicketTemplate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*TicketTemplate, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TicketTemplate)
	err := c.cc.Invoke(ctx, TicketMgr_GetTicketTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) ListTicketTemplates(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, TicketMgr_ListTicketTemplates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) PongTicketEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Event)
	err := c.cc.Invoke(ctx, TicketMgr_PongTicketEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) TagTicket(ctx context.Context, in *TagRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TicketMgr_TagTicket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) UntagTicket(ctx context.Context, in *TagRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TicketMgr_UntagTicket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) JoinTicket(ctx context.Context, in *ConversationMember, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TicketMgr_JoinTicket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) LeftTicket(ctx context.Context, in *ConversationMember, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TicketMgr_LeftTicket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) ReadTickets(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TicketMgr_ReadTickets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) UnreadTickets(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TicketMgr_UnreadTickets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) SubscribedTickets(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TicketMgr_SubscribedTickets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) UnSubscribedTickets(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TicketMgr_UnSubscribedTickets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) SendTicketEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Event)
	err := c.cc.Invoke(ctx, TicketMgr_SendTicketEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) ListTicketEvents(ctx context.Context, in *ListConversationEventsRequest, opts ...grpc.CallOption) (*Events, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Events)
	err := c.cc.Invoke(ctx, TicketMgr_ListTicketEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) ListImportantTicketEvents(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Events, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Events)
	err := c.cc.Invoke(ctx, TicketMgr_ListImportantTicketEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) UpdateTicketTypeMember(ctx context.Context, in *ResourceGroupMember, opts ...grpc.CallOption) (*ResourceGroupMember, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResourceGroupMember)
	err := c.cc.Invoke(ctx, TicketMgr_UpdateTicketTypeMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) RemoveTicketTypeMember(ctx context.Context, in *ResourceGroupMember, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TicketMgr_RemoveTicketTypeMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) CreateSLAPolicy(ctx context.Context, in *SLAPolicy, opts ...grpc.CallOption) (*SLAPolicy, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SLAPolicy)
	err := c.cc.Invoke(ctx, TicketMgr_CreateSLAPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) UpdateSLAPolicy(ctx context.Context, in *SLAPolicy, opts ...grpc.CallOption) (*SLAPolicy, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SLAPolicy)
	err := c.cc.Invoke(ctx, TicketMgr_UpdateSLAPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) DeleteSLAPolicy(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TicketMgr_DeleteSLAPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) ListSLAPolicies(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, TicketMgr_ListSLAPolicies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) GetSLAPolicy(ctx context.Context, in *Id, opts ...grpc.CallOption) (*SLAPolicy, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SLAPolicy)
	err := c.cc.Invoke(ctx, TicketMgr_GetSLAPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) ListTicketSLAViolations(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, TicketMgr_ListTicketSLAViolations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) RateTicket(ctx context.Context, in *Rating, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, TicketMgr_RateTicket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) GetTicketRating(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Rating, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Rating)
	err := c.cc.Invoke(ctx, TicketMgr_GetTicketRating_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) UpdateTicketRule(ctx context.Context, in *Rule, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, TicketMgr_UpdateTicketRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) CreateTicketRule(ctx context.Context, in *Rule, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, TicketMgr_CreateTicketRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) DeleteTicketRule(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TicketMgr_DeleteTicketRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) ReadTicketRule(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, TicketMgr_ReadTicketRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) ListTicketRules(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, TicketMgr_ListTicketRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) ReportTickets(ctx context.Context, in *ConvoReportRequest, opts ...grpc.CallOption) (*ConvoReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConvoReportResponse)
	err := c.cc.Invoke(ctx, TicketMgr_ReportTickets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) ReportSlaViolations(ctx context.Context, in *ConvoReportRequest, opts ...grpc.CallOption) (*ConvoReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConvoReportResponse)
	err := c.cc.Invoke(ctx, TicketMgr_ReportSlaViolations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) ReportRatings(ctx context.Context, in *ConvoReportRequest, opts ...grpc.CallOption) (*ConvoReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConvoReportResponse)
	err := c.cc.Invoke(ctx, TicketMgr_ReportRatings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) ListRatings(ctx context.Context, in *ConvoReportRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, TicketMgr_ListRatings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) ListSlaViolations(ctx context.Context, in *ConvoReportRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, TicketMgr_ListSlaViolations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) GetTicketIdsByConvoId(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Ids, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Ids)
	err := c.cc.Invoke(ctx, TicketMgr_GetTicketIdsByConvoId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TicketMgrServer is the server API for TicketMgr service.
// All implementations must embed UnimplementedTicketMgrServer
// for forward compatibility.
type TicketMgrServer interface {
	// ticket type
	CreateTicketType(context.Context, *TicketType) (*TicketType, error)
	UpdateTicketType(context.Context, *TicketType) (*TicketType, error)
	ListTicketTypes(context.Context, *Id) (*Response, error)
	GetTicketType(context.Context, *Id) (*TicketType, error)
	DeleteTicketType(context.Context, *Id) (*Empty, error)
	CreateTicket(context.Context, *Ticket) (*Ticket, error)
	UpdateTicket(context.Context, *Ticket) (*Ticket, error)
	DeleteTicket(context.Context, *Id) (*Empty, error)
	RecoverTicket(context.Context, *Id) (*Empty, error)
	GetTicket(context.Context, *Id) (*Ticket, error)
	ListTickets(context.Context, *ListTicketRequest) (*Response, error)
	MatchTickets(context.Context, *Ids) (*Response, error)
	CreateTicketView(context.Context, *TicketView) (*TicketView, error)
	UpdateTicketView(context.Context, *TicketView) (*TicketView, error)
	DeleteTicketView(context.Context, *Id) (*Empty, error)
	GetTicketView(context.Context, *Id) (*TicketView, error)
	ListTicketViews(context.Context, *Empty) (*Response, error)
	CreateTicketTemplate(context.Context, *TicketTemplate) (*TicketTemplate, error)
	UpdateTicketTemplate(context.Context, *TicketTemplate) (*TicketTemplate, error)
	DeleteTicketTemplate(context.Context, *Id) (*Empty, error)
	GetTicketTemplate(context.Context, *Id) (*TicketTemplate, error)
	ListTicketTemplates(context.Context, *Empty) (*Response, error)
	PongTicketEvent(context.Context, *Event) (*Event, error)
	TagTicket(context.Context, *TagRequest) (*Empty, error)
	UntagTicket(context.Context, *TagRequest) (*Empty, error)
	JoinTicket(context.Context, *ConversationMember) (*Empty, error)
	LeftTicket(context.Context, *ConversationMember) (*Empty, error)
	ReadTickets(context.Context, *Ids) (*Empty, error)
	UnreadTickets(context.Context, *Ids) (*Empty, error)
	SubscribedTickets(context.Context, *Ids) (*Empty, error)
	UnSubscribedTickets(context.Context, *Ids) (*Empty, error)
	SendTicketEvent(context.Context, *Event) (*Event, error)
	ListTicketEvents(context.Context, *ListConversationEventsRequest) (*Events, error)
	ListImportantTicketEvents(context.Context, *Id) (*Events, error)
	UpdateTicketTypeMember(context.Context, *ResourceGroupMember) (*ResourceGroupMember, error)
	RemoveTicketTypeMember(context.Context, *ResourceGroupMember) (*Empty, error)
	CreateSLAPolicy(context.Context, *SLAPolicy) (*SLAPolicy, error)
	UpdateSLAPolicy(context.Context, *SLAPolicy) (*SLAPolicy, error)
	DeleteSLAPolicy(context.Context, *Id) (*Empty, error)
	ListSLAPolicies(context.Context, *Empty) (*Response, error)
	GetSLAPolicy(context.Context, *Id) (*SLAPolicy, error)
	ListTicketSLAViolations(context.Context, *Id) (*Response, error)
	RateTicket(context.Context, *Rating) (*Response, error)
	GetTicketRating(context.Context, *Id) (*Rating, error)
	UpdateTicketRule(context.Context, *Rule) (*Response, error)
	CreateTicketRule(context.Context, *Rule) (*Response, error)
	DeleteTicketRule(context.Context, *Id) (*Empty, error)
	ReadTicketRule(context.Context, *Id) (*Response, error)
	ListTicketRules(context.Context, *Id) (*Response, error)
	ReportTickets(context.Context, *ConvoReportRequest) (*ConvoReportResponse, error)
	ReportSlaViolations(context.Context, *ConvoReportRequest) (*ConvoReportResponse, error)
	ReportRatings(context.Context, *ConvoReportRequest) (*ConvoReportResponse, error)
	ListRatings(context.Context, *ConvoReportRequest) (*Response, error)
	ListSlaViolations(context.Context, *ConvoReportRequest) (*Response, error)
	// internal only
	GetTicketIdsByConvoId(context.Context, *Id) (*Ids, error)
	mustEmbedUnimplementedTicketMgrServer()
}

// UnimplementedTicketMgrServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTicketMgrServer struct{}

func (UnimplementedTicketMgrServer) CreateTicketType(context.Context, *TicketType) (*TicketType, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTicketType not implemented")
}
func (UnimplementedTicketMgrServer) UpdateTicketType(context.Context, *TicketType) (*TicketType, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTicketType not implemented")
}
func (UnimplementedTicketMgrServer) ListTicketTypes(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTicketTypes not implemented")
}
func (UnimplementedTicketMgrServer) GetTicketType(context.Context, *Id) (*TicketType, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTicketType not implemented")
}
func (UnimplementedTicketMgrServer) DeleteTicketType(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTicketType not implemented")
}
func (UnimplementedTicketMgrServer) CreateTicket(context.Context, *Ticket) (*Ticket, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTicket not implemented")
}
func (UnimplementedTicketMgrServer) UpdateTicket(context.Context, *Ticket) (*Ticket, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTicket not implemented")
}
func (UnimplementedTicketMgrServer) DeleteTicket(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTicket not implemented")
}
func (UnimplementedTicketMgrServer) RecoverTicket(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecoverTicket not implemented")
}
func (UnimplementedTicketMgrServer) GetTicket(context.Context, *Id) (*Ticket, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTicket not implemented")
}
func (UnimplementedTicketMgrServer) ListTickets(context.Context, *ListTicketRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTickets not implemented")
}
func (UnimplementedTicketMgrServer) MatchTickets(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchTickets not implemented")
}
func (UnimplementedTicketMgrServer) CreateTicketView(context.Context, *TicketView) (*TicketView, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTicketView not implemented")
}
func (UnimplementedTicketMgrServer) UpdateTicketView(context.Context, *TicketView) (*TicketView, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTicketView not implemented")
}
func (UnimplementedTicketMgrServer) DeleteTicketView(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTicketView not implemented")
}
func (UnimplementedTicketMgrServer) GetTicketView(context.Context, *Id) (*TicketView, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTicketView not implemented")
}
func (UnimplementedTicketMgrServer) ListTicketViews(context.Context, *Empty) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTicketViews not implemented")
}
func (UnimplementedTicketMgrServer) CreateTicketTemplate(context.Context, *TicketTemplate) (*TicketTemplate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTicketTemplate not implemented")
}
func (UnimplementedTicketMgrServer) UpdateTicketTemplate(context.Context, *TicketTemplate) (*TicketTemplate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTicketTemplate not implemented")
}
func (UnimplementedTicketMgrServer) DeleteTicketTemplate(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTicketTemplate not implemented")
}
func (UnimplementedTicketMgrServer) GetTicketTemplate(context.Context, *Id) (*TicketTemplate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTicketTemplate not implemented")
}
func (UnimplementedTicketMgrServer) ListTicketTemplates(context.Context, *Empty) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTicketTemplates not implemented")
}
func (UnimplementedTicketMgrServer) PongTicketEvent(context.Context, *Event) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PongTicketEvent not implemented")
}
func (UnimplementedTicketMgrServer) TagTicket(context.Context, *TagRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TagTicket not implemented")
}
func (UnimplementedTicketMgrServer) UntagTicket(context.Context, *TagRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UntagTicket not implemented")
}
func (UnimplementedTicketMgrServer) JoinTicket(context.Context, *ConversationMember) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinTicket not implemented")
}
func (UnimplementedTicketMgrServer) LeftTicket(context.Context, *ConversationMember) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeftTicket not implemented")
}
func (UnimplementedTicketMgrServer) ReadTickets(context.Context, *Ids) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadTickets not implemented")
}
func (UnimplementedTicketMgrServer) UnreadTickets(context.Context, *Ids) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnreadTickets not implemented")
}
func (UnimplementedTicketMgrServer) SubscribedTickets(context.Context, *Ids) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubscribedTickets not implemented")
}
func (UnimplementedTicketMgrServer) UnSubscribedTickets(context.Context, *Ids) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnSubscribedTickets not implemented")
}
func (UnimplementedTicketMgrServer) SendTicketEvent(context.Context, *Event) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendTicketEvent not implemented")
}
func (UnimplementedTicketMgrServer) ListTicketEvents(context.Context, *ListConversationEventsRequest) (*Events, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTicketEvents not implemented")
}
func (UnimplementedTicketMgrServer) ListImportantTicketEvents(context.Context, *Id) (*Events, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListImportantTicketEvents not implemented")
}
func (UnimplementedTicketMgrServer) UpdateTicketTypeMember(context.Context, *ResourceGroupMember) (*ResourceGroupMember, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTicketTypeMember not implemented")
}
func (UnimplementedTicketMgrServer) RemoveTicketTypeMember(context.Context, *ResourceGroupMember) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveTicketTypeMember not implemented")
}
func (UnimplementedTicketMgrServer) CreateSLAPolicy(context.Context, *SLAPolicy) (*SLAPolicy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSLAPolicy not implemented")
}
func (UnimplementedTicketMgrServer) UpdateSLAPolicy(context.Context, *SLAPolicy) (*SLAPolicy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSLAPolicy not implemented")
}
func (UnimplementedTicketMgrServer) DeleteSLAPolicy(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSLAPolicy not implemented")
}
func (UnimplementedTicketMgrServer) ListSLAPolicies(context.Context, *Empty) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSLAPolicies not implemented")
}
func (UnimplementedTicketMgrServer) GetSLAPolicy(context.Context, *Id) (*SLAPolicy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSLAPolicy not implemented")
}
func (UnimplementedTicketMgrServer) ListTicketSLAViolations(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTicketSLAViolations not implemented")
}
func (UnimplementedTicketMgrServer) RateTicket(context.Context, *Rating) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RateTicket not implemented")
}
func (UnimplementedTicketMgrServer) GetTicketRating(context.Context, *Id) (*Rating, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTicketRating not implemented")
}
func (UnimplementedTicketMgrServer) UpdateTicketRule(context.Context, *Rule) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTicketRule not implemented")
}
func (UnimplementedTicketMgrServer) CreateTicketRule(context.Context, *Rule) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTicketRule not implemented")
}
func (UnimplementedTicketMgrServer) DeleteTicketRule(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTicketRule not implemented")
}
func (UnimplementedTicketMgrServer) ReadTicketRule(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadTicketRule not implemented")
}
func (UnimplementedTicketMgrServer) ListTicketRules(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTicketRules not implemented")
}
func (UnimplementedTicketMgrServer) ReportTickets(context.Context, *ConvoReportRequest) (*ConvoReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportTickets not implemented")
}
func (UnimplementedTicketMgrServer) ReportSlaViolations(context.Context, *ConvoReportRequest) (*ConvoReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportSlaViolations not implemented")
}
func (UnimplementedTicketMgrServer) ReportRatings(context.Context, *ConvoReportRequest) (*ConvoReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportRatings not implemented")
}
func (UnimplementedTicketMgrServer) ListRatings(context.Context, *ConvoReportRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRatings not implemented")
}
func (UnimplementedTicketMgrServer) ListSlaViolations(context.Context, *ConvoReportRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSlaViolations not implemented")
}
func (UnimplementedTicketMgrServer) GetTicketIdsByConvoId(context.Context, *Id) (*Ids, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTicketIdsByConvoId not implemented")
}
func (UnimplementedTicketMgrServer) mustEmbedUnimplementedTicketMgrServer() {}
func (UnimplementedTicketMgrServer) testEmbeddedByValue()                   {}

// UnsafeTicketMgrServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TicketMgrServer will
// result in compilation errors.
type UnsafeTicketMgrServer interface {
	mustEmbedUnimplementedTicketMgrServer()
}

func RegisterTicketMgrServer(s grpc.ServiceRegistrar, srv TicketMgrServer) {
	// If the following call pancis, it indicates UnimplementedTicketMgrServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TicketMgr_ServiceDesc, srv)
}

func _TicketMgr_CreateTicketType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TicketType)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).CreateTicketType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_CreateTicketType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).CreateTicketType(ctx, req.(*TicketType))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_UpdateTicketType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TicketType)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).UpdateTicketType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_UpdateTicketType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).UpdateTicketType(ctx, req.(*TicketType))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_ListTicketTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).ListTicketTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_ListTicketTypes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).ListTicketTypes(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_GetTicketType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).GetTicketType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_GetTicketType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).GetTicketType(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_DeleteTicketType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).DeleteTicketType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_DeleteTicketType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).DeleteTicketType(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_CreateTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ticket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).CreateTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_CreateTicket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).CreateTicket(ctx, req.(*Ticket))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_UpdateTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ticket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).UpdateTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_UpdateTicket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).UpdateTicket(ctx, req.(*Ticket))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_DeleteTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).DeleteTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_DeleteTicket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).DeleteTicket(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_RecoverTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).RecoverTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_RecoverTicket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).RecoverTicket(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_GetTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).GetTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_GetTicket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).GetTicket(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_ListTickets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTicketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).ListTickets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_ListTickets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).ListTickets(ctx, req.(*ListTicketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_MatchTickets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).MatchTickets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_MatchTickets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).MatchTickets(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_CreateTicketView_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TicketView)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).CreateTicketView(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_CreateTicketView_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).CreateTicketView(ctx, req.(*TicketView))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_UpdateTicketView_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TicketView)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).UpdateTicketView(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_UpdateTicketView_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).UpdateTicketView(ctx, req.(*TicketView))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_DeleteTicketView_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).DeleteTicketView(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_DeleteTicketView_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).DeleteTicketView(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_GetTicketView_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).GetTicketView(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_GetTicketView_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).GetTicketView(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_ListTicketViews_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).ListTicketViews(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_ListTicketViews_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).ListTicketViews(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_CreateTicketTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TicketTemplate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).CreateTicketTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_CreateTicketTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).CreateTicketTemplate(ctx, req.(*TicketTemplate))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_UpdateTicketTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TicketTemplate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).UpdateTicketTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_UpdateTicketTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).UpdateTicketTemplate(ctx, req.(*TicketTemplate))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_DeleteTicketTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).DeleteTicketTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_DeleteTicketTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).DeleteTicketTemplate(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_GetTicketTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).GetTicketTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_GetTicketTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).GetTicketTemplate(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_ListTicketTemplates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).ListTicketTemplates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_ListTicketTemplates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).ListTicketTemplates(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_PongTicketEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).PongTicketEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_PongTicketEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).PongTicketEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_TagTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).TagTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_TagTicket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).TagTicket(ctx, req.(*TagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_UntagTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).UntagTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_UntagTicket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).UntagTicket(ctx, req.(*TagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_JoinTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConversationMember)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).JoinTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_JoinTicket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).JoinTicket(ctx, req.(*ConversationMember))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_LeftTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConversationMember)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).LeftTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_LeftTicket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).LeftTicket(ctx, req.(*ConversationMember))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_ReadTickets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).ReadTickets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_ReadTickets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).ReadTickets(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_UnreadTickets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).UnreadTickets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_UnreadTickets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).UnreadTickets(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_SubscribedTickets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).SubscribedTickets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_SubscribedTickets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).SubscribedTickets(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_UnSubscribedTickets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).UnSubscribedTickets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_UnSubscribedTickets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).UnSubscribedTickets(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_SendTicketEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).SendTicketEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_SendTicketEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).SendTicketEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_ListTicketEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListConversationEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).ListTicketEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_ListTicketEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).ListTicketEvents(ctx, req.(*ListConversationEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_ListImportantTicketEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).ListImportantTicketEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_ListImportantTicketEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).ListImportantTicketEvents(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_UpdateTicketTypeMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceGroupMember)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).UpdateTicketTypeMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_UpdateTicketTypeMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).UpdateTicketTypeMember(ctx, req.(*ResourceGroupMember))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_RemoveTicketTypeMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceGroupMember)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).RemoveTicketTypeMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_RemoveTicketTypeMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).RemoveTicketTypeMember(ctx, req.(*ResourceGroupMember))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_CreateSLAPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLAPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).CreateSLAPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_CreateSLAPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).CreateSLAPolicy(ctx, req.(*SLAPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_UpdateSLAPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLAPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).UpdateSLAPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_UpdateSLAPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).UpdateSLAPolicy(ctx, req.(*SLAPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_DeleteSLAPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).DeleteSLAPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_DeleteSLAPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).DeleteSLAPolicy(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_ListSLAPolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).ListSLAPolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_ListSLAPolicies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).ListSLAPolicies(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_GetSLAPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).GetSLAPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_GetSLAPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).GetSLAPolicy(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_ListTicketSLAViolations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).ListTicketSLAViolations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_ListTicketSLAViolations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).ListTicketSLAViolations(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_RateTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Rating)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).RateTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_RateTicket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).RateTicket(ctx, req.(*Rating))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_GetTicketRating_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).GetTicketRating(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_GetTicketRating_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).GetTicketRating(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_UpdateTicketRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Rule)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).UpdateTicketRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_UpdateTicketRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).UpdateTicketRule(ctx, req.(*Rule))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_CreateTicketRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Rule)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).CreateTicketRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_CreateTicketRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).CreateTicketRule(ctx, req.(*Rule))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_DeleteTicketRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).DeleteTicketRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_DeleteTicketRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).DeleteTicketRule(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_ReadTicketRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).ReadTicketRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_ReadTicketRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).ReadTicketRule(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_ListTicketRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).ListTicketRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_ListTicketRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).ListTicketRules(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_ReportTickets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvoReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).ReportTickets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_ReportTickets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).ReportTickets(ctx, req.(*ConvoReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_ReportSlaViolations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvoReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).ReportSlaViolations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_ReportSlaViolations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).ReportSlaViolations(ctx, req.(*ConvoReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_ReportRatings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvoReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).ReportRatings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_ReportRatings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).ReportRatings(ctx, req.(*ConvoReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_ListRatings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvoReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).ListRatings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_ListRatings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).ListRatings(ctx, req.(*ConvoReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_ListSlaViolations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvoReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).ListSlaViolations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_ListSlaViolations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).ListSlaViolations(ctx, req.(*ConvoReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_GetTicketIdsByConvoId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).GetTicketIdsByConvoId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketMgr_GetTicketIdsByConvoId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).GetTicketIdsByConvoId(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

// TicketMgr_ServiceDesc is the grpc.ServiceDesc for TicketMgr service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TicketMgr_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.TicketMgr",
	HandlerType: (*TicketMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTicketType",
			Handler:    _TicketMgr_CreateTicketType_Handler,
		},
		{
			MethodName: "UpdateTicketType",
			Handler:    _TicketMgr_UpdateTicketType_Handler,
		},
		{
			MethodName: "ListTicketTypes",
			Handler:    _TicketMgr_ListTicketTypes_Handler,
		},
		{
			MethodName: "GetTicketType",
			Handler:    _TicketMgr_GetTicketType_Handler,
		},
		{
			MethodName: "DeleteTicketType",
			Handler:    _TicketMgr_DeleteTicketType_Handler,
		},
		{
			MethodName: "CreateTicket",
			Handler:    _TicketMgr_CreateTicket_Handler,
		},
		{
			MethodName: "UpdateTicket",
			Handler:    _TicketMgr_UpdateTicket_Handler,
		},
		{
			MethodName: "DeleteTicket",
			Handler:    _TicketMgr_DeleteTicket_Handler,
		},
		{
			MethodName: "RecoverTicket",
			Handler:    _TicketMgr_RecoverTicket_Handler,
		},
		{
			MethodName: "GetTicket",
			Handler:    _TicketMgr_GetTicket_Handler,
		},
		{
			MethodName: "ListTickets",
			Handler:    _TicketMgr_ListTickets_Handler,
		},
		{
			MethodName: "MatchTickets",
			Handler:    _TicketMgr_MatchTickets_Handler,
		},
		{
			MethodName: "CreateTicketView",
			Handler:    _TicketMgr_CreateTicketView_Handler,
		},
		{
			MethodName: "UpdateTicketView",
			Handler:    _TicketMgr_UpdateTicketView_Handler,
		},
		{
			MethodName: "DeleteTicketView",
			Handler:    _TicketMgr_DeleteTicketView_Handler,
		},
		{
			MethodName: "GetTicketView",
			Handler:    _TicketMgr_GetTicketView_Handler,
		},
		{
			MethodName: "ListTicketViews",
			Handler:    _TicketMgr_ListTicketViews_Handler,
		},
		{
			MethodName: "CreateTicketTemplate",
			Handler:    _TicketMgr_CreateTicketTemplate_Handler,
		},
		{
			MethodName: "UpdateTicketTemplate",
			Handler:    _TicketMgr_UpdateTicketTemplate_Handler,
		},
		{
			MethodName: "DeleteTicketTemplate",
			Handler:    _TicketMgr_DeleteTicketTemplate_Handler,
		},
		{
			MethodName: "GetTicketTemplate",
			Handler:    _TicketMgr_GetTicketTemplate_Handler,
		},
		{
			MethodName: "ListTicketTemplates",
			Handler:    _TicketMgr_ListTicketTemplates_Handler,
		},
		{
			MethodName: "PongTicketEvent",
			Handler:    _TicketMgr_PongTicketEvent_Handler,
		},
		{
			MethodName: "TagTicket",
			Handler:    _TicketMgr_TagTicket_Handler,
		},
		{
			MethodName: "UntagTicket",
			Handler:    _TicketMgr_UntagTicket_Handler,
		},
		{
			MethodName: "JoinTicket",
			Handler:    _TicketMgr_JoinTicket_Handler,
		},
		{
			MethodName: "LeftTicket",
			Handler:    _TicketMgr_LeftTicket_Handler,
		},
		{
			MethodName: "ReadTickets",
			Handler:    _TicketMgr_ReadTickets_Handler,
		},
		{
			MethodName: "UnreadTickets",
			Handler:    _TicketMgr_UnreadTickets_Handler,
		},
		{
			MethodName: "SubscribedTickets",
			Handler:    _TicketMgr_SubscribedTickets_Handler,
		},
		{
			MethodName: "UnSubscribedTickets",
			Handler:    _TicketMgr_UnSubscribedTickets_Handler,
		},
		{
			MethodName: "SendTicketEvent",
			Handler:    _TicketMgr_SendTicketEvent_Handler,
		},
		{
			MethodName: "ListTicketEvents",
			Handler:    _TicketMgr_ListTicketEvents_Handler,
		},
		{
			MethodName: "ListImportantTicketEvents",
			Handler:    _TicketMgr_ListImportantTicketEvents_Handler,
		},
		{
			MethodName: "UpdateTicketTypeMember",
			Handler:    _TicketMgr_UpdateTicketTypeMember_Handler,
		},
		{
			MethodName: "RemoveTicketTypeMember",
			Handler:    _TicketMgr_RemoveTicketTypeMember_Handler,
		},
		{
			MethodName: "CreateSLAPolicy",
			Handler:    _TicketMgr_CreateSLAPolicy_Handler,
		},
		{
			MethodName: "UpdateSLAPolicy",
			Handler:    _TicketMgr_UpdateSLAPolicy_Handler,
		},
		{
			MethodName: "DeleteSLAPolicy",
			Handler:    _TicketMgr_DeleteSLAPolicy_Handler,
		},
		{
			MethodName: "ListSLAPolicies",
			Handler:    _TicketMgr_ListSLAPolicies_Handler,
		},
		{
			MethodName: "GetSLAPolicy",
			Handler:    _TicketMgr_GetSLAPolicy_Handler,
		},
		{
			MethodName: "ListTicketSLAViolations",
			Handler:    _TicketMgr_ListTicketSLAViolations_Handler,
		},
		{
			MethodName: "RateTicket",
			Handler:    _TicketMgr_RateTicket_Handler,
		},
		{
			MethodName: "GetTicketRating",
			Handler:    _TicketMgr_GetTicketRating_Handler,
		},
		{
			MethodName: "UpdateTicketRule",
			Handler:    _TicketMgr_UpdateTicketRule_Handler,
		},
		{
			MethodName: "CreateTicketRule",
			Handler:    _TicketMgr_CreateTicketRule_Handler,
		},
		{
			MethodName: "DeleteTicketRule",
			Handler:    _TicketMgr_DeleteTicketRule_Handler,
		},
		{
			MethodName: "ReadTicketRule",
			Handler:    _TicketMgr_ReadTicketRule_Handler,
		},
		{
			MethodName: "ListTicketRules",
			Handler:    _TicketMgr_ListTicketRules_Handler,
		},
		{
			MethodName: "ReportTickets",
			Handler:    _TicketMgr_ReportTickets_Handler,
		},
		{
			MethodName: "ReportSlaViolations",
			Handler:    _TicketMgr_ReportSlaViolations_Handler,
		},
		{
			MethodName: "ReportRatings",
			Handler:    _TicketMgr_ReportRatings_Handler,
		},
		{
			MethodName: "ListRatings",
			Handler:    _TicketMgr_ListRatings_Handler,
		},
		{
			MethodName: "ListSlaViolations",
			Handler:    _TicketMgr_ListSlaViolations_Handler,
		},
		{
			MethodName: "GetTicketIdsByConvoId",
			Handler:    _TicketMgr_GetTicketIdsByConvoId_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	TemplateMgr_CreateTemplate_FullMethodName = "/header.TemplateMgr/CreateTemplate"
	TemplateMgr_UpdateTemplate_FullMethodName = "/header.TemplateMgr/UpdateTemplate"
	TemplateMgr_DeleteTemplate_FullMethodName = "/header.TemplateMgr/DeleteTemplate"
	TemplateMgr_GetTemplate_FullMethodName    = "/header.TemplateMgr/GetTemplate"
	TemplateMgr_ListTemplates_FullMethodName  = "/header.TemplateMgr/ListTemplates"
	TemplateMgr_MatchTemplates_FullMethodName = "/header.TemplateMgr/MatchTemplates"
	TemplateMgr_PickTemplate_FullMethodName   = "/header.TemplateMgr/PickTemplate"
	TemplateMgr_CreateModal_FullMethodName    = "/header.TemplateMgr/CreateModal"
	TemplateMgr_UpdateModal_FullMethodName    = "/header.TemplateMgr/UpdateModal"
	TemplateMgr_DeleteModal_FullMethodName    = "/header.TemplateMgr/DeleteModal"
	TemplateMgr_GetModal_FullMethodName       = "/header.TemplateMgr/GetModal"
	TemplateMgr_ListModals_FullMethodName     = "/header.TemplateMgr/ListModals"
	TemplateMgr_PickModal_FullMethodName      = "/header.TemplateMgr/PickModal"
)

// TemplateMgrClient is the client API for TemplateMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TemplateMgrClient interface {
	CreateTemplate(ctx context.Context, in *Template, opts ...grpc.CallOption) (*Template, error)
	UpdateTemplate(ctx context.Context, in *Template, opts ...grpc.CallOption) (*Template, error)
	DeleteTemplate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	GetTemplate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Template, error)
	ListTemplates(ctx context.Context, in *SearchTemplate, opts ...grpc.CallOption) (*Response, error)
	MatchTemplates(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
	PickTemplate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	CreateModal(ctx context.Context, in *ConversationModal, opts ...grpc.CallOption) (*ConversationModal, error)
	UpdateModal(ctx context.Context, in *ConversationModal, opts ...grpc.CallOption) (*ConversationModal, error)
	DeleteModal(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	GetModal(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ConversationModal, error)
	ListModals(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ConversationModals, error)
	PickModal(ctx context.Context, in *ConversationModalPickRequest, opts ...grpc.CallOption) (*ConversationModalPicked, error)
}

type templateMgrClient struct {
	cc grpc.ClientConnInterface
}

func NewTemplateMgrClient(cc grpc.ClientConnInterface) TemplateMgrClient {
	return &templateMgrClient{cc}
}

func (c *templateMgrClient) CreateTemplate(ctx context.Context, in *Template, opts ...grpc.CallOption) (*Template, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Template)
	err := c.cc.Invoke(ctx, TemplateMgr_CreateTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templateMgrClient) UpdateTemplate(ctx context.Context, in *Template, opts ...grpc.CallOption) (*Template, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Template)
	err := c.cc.Invoke(ctx, TemplateMgr_UpdateTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templateMgrClient) DeleteTemplate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TemplateMgr_DeleteTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templateMgrClient) GetTemplate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Template, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Template)
	err := c.cc.Invoke(ctx, TemplateMgr_GetTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templateMgrClient) ListTemplates(ctx context.Context, in *SearchTemplate, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, TemplateMgr_ListTemplates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templateMgrClient) MatchTemplates(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, TemplateMgr_MatchTemplates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templateMgrClient) PickTemplate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TemplateMgr_PickTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templateMgrClient) CreateModal(ctx context.Context, in *ConversationModal, opts ...grpc.CallOption) (*ConversationModal, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConversationModal)
	err := c.cc.Invoke(ctx, TemplateMgr_CreateModal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templateMgrClient) UpdateModal(ctx context.Context, in *ConversationModal, opts ...grpc.CallOption) (*ConversationModal, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConversationModal)
	err := c.cc.Invoke(ctx, TemplateMgr_UpdateModal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templateMgrClient) DeleteModal(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TemplateMgr_DeleteModal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templateMgrClient) GetModal(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ConversationModal, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConversationModal)
	err := c.cc.Invoke(ctx, TemplateMgr_GetModal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templateMgrClient) ListModals(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ConversationModals, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConversationModals)
	err := c.cc.Invoke(ctx, TemplateMgr_ListModals_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templateMgrClient) PickModal(ctx context.Context, in *ConversationModalPickRequest, opts ...grpc.CallOption) (*ConversationModalPicked, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConversationModalPicked)
	err := c.cc.Invoke(ctx, TemplateMgr_PickModal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TemplateMgrServer is the server API for TemplateMgr service.
// All implementations must embed UnimplementedTemplateMgrServer
// for forward compatibility.
type TemplateMgrServer interface {
	CreateTemplate(context.Context, *Template) (*Template, error)
	UpdateTemplate(context.Context, *Template) (*Template, error)
	DeleteTemplate(context.Context, *Id) (*Empty, error)
	GetTemplate(context.Context, *Id) (*Template, error)
	ListTemplates(context.Context, *SearchTemplate) (*Response, error)
	MatchTemplates(context.Context, *Ids) (*Response, error)
	PickTemplate(context.Context, *Id) (*Empty, error)
	CreateModal(context.Context, *ConversationModal) (*ConversationModal, error)
	UpdateModal(context.Context, *ConversationModal) (*ConversationModal, error)
	DeleteModal(context.Context, *Id) (*Empty, error)
	GetModal(context.Context, *Id) (*ConversationModal, error)
	ListModals(context.Context, *Id) (*ConversationModals, error)
	PickModal(context.Context, *ConversationModalPickRequest) (*ConversationModalPicked, error)
	mustEmbedUnimplementedTemplateMgrServer()
}

// UnimplementedTemplateMgrServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTemplateMgrServer struct{}

func (UnimplementedTemplateMgrServer) CreateTemplate(context.Context, *Template) (*Template, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTemplate not implemented")
}
func (UnimplementedTemplateMgrServer) UpdateTemplate(context.Context, *Template) (*Template, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTemplate not implemented")
}
func (UnimplementedTemplateMgrServer) DeleteTemplate(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTemplate not implemented")
}
func (UnimplementedTemplateMgrServer) GetTemplate(context.Context, *Id) (*Template, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTemplate not implemented")
}
func (UnimplementedTemplateMgrServer) ListTemplates(context.Context, *SearchTemplate) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTemplates not implemented")
}
func (UnimplementedTemplateMgrServer) MatchTemplates(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchTemplates not implemented")
}
func (UnimplementedTemplateMgrServer) PickTemplate(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PickTemplate not implemented")
}
func (UnimplementedTemplateMgrServer) CreateModal(context.Context, *ConversationModal) (*ConversationModal, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateModal not implemented")
}
func (UnimplementedTemplateMgrServer) UpdateModal(context.Context, *ConversationModal) (*ConversationModal, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateModal not implemented")
}
func (UnimplementedTemplateMgrServer) DeleteModal(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteModal not implemented")
}
func (UnimplementedTemplateMgrServer) GetModal(context.Context, *Id) (*ConversationModal, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModal not implemented")
}
func (UnimplementedTemplateMgrServer) ListModals(context.Context, *Id) (*ConversationModals, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListModals not implemented")
}
func (UnimplementedTemplateMgrServer) PickModal(context.Context, *ConversationModalPickRequest) (*ConversationModalPicked, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PickModal not implemented")
}
func (UnimplementedTemplateMgrServer) mustEmbedUnimplementedTemplateMgrServer() {}
func (UnimplementedTemplateMgrServer) testEmbeddedByValue()                     {}

// UnsafeTemplateMgrServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TemplateMgrServer will
// result in compilation errors.
type UnsafeTemplateMgrServer interface {
	mustEmbedUnimplementedTemplateMgrServer()
}

func RegisterTemplateMgrServer(s grpc.ServiceRegistrar, srv TemplateMgrServer) {
	// If the following call pancis, it indicates UnimplementedTemplateMgrServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TemplateMgr_ServiceDesc, srv)
}

func _TemplateMgr_CreateTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Template)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplateMgrServer).CreateTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TemplateMgr_CreateTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplateMgrServer).CreateTemplate(ctx, req.(*Template))
	}
	return interceptor(ctx, in, info, handler)
}

func _TemplateMgr_UpdateTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Template)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplateMgrServer).UpdateTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TemplateMgr_UpdateTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplateMgrServer).UpdateTemplate(ctx, req.(*Template))
	}
	return interceptor(ctx, in, info, handler)
}

func _TemplateMgr_DeleteTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplateMgrServer).DeleteTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TemplateMgr_DeleteTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplateMgrServer).DeleteTemplate(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TemplateMgr_GetTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplateMgrServer).GetTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TemplateMgr_GetTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplateMgrServer).GetTemplate(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TemplateMgr_ListTemplates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchTemplate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplateMgrServer).ListTemplates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TemplateMgr_ListTemplates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplateMgrServer).ListTemplates(ctx, req.(*SearchTemplate))
	}
	return interceptor(ctx, in, info, handler)
}

func _TemplateMgr_MatchTemplates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplateMgrServer).MatchTemplates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TemplateMgr_MatchTemplates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplateMgrServer).MatchTemplates(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _TemplateMgr_PickTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplateMgrServer).PickTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TemplateMgr_PickTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplateMgrServer).PickTemplate(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TemplateMgr_CreateModal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConversationModal)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplateMgrServer).CreateModal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TemplateMgr_CreateModal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplateMgrServer).CreateModal(ctx, req.(*ConversationModal))
	}
	return interceptor(ctx, in, info, handler)
}

func _TemplateMgr_UpdateModal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConversationModal)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplateMgrServer).UpdateModal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TemplateMgr_UpdateModal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplateMgrServer).UpdateModal(ctx, req.(*ConversationModal))
	}
	return interceptor(ctx, in, info, handler)
}

func _TemplateMgr_DeleteModal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplateMgrServer).DeleteModal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TemplateMgr_DeleteModal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplateMgrServer).DeleteModal(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TemplateMgr_GetModal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplateMgrServer).GetModal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TemplateMgr_GetModal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplateMgrServer).GetModal(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TemplateMgr_ListModals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplateMgrServer).ListModals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TemplateMgr_ListModals_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplateMgrServer).ListModals(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TemplateMgr_PickModal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConversationModalPickRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplateMgrServer).PickModal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TemplateMgr_PickModal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplateMgrServer).PickModal(ctx, req.(*ConversationModalPickRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TemplateMgr_ServiceDesc is the grpc.ServiceDesc for TemplateMgr service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TemplateMgr_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.TemplateMgr",
	HandlerType: (*TemplateMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTemplate",
			Handler:    _TemplateMgr_CreateTemplate_Handler,
		},
		{
			MethodName: "UpdateTemplate",
			Handler:    _TemplateMgr_UpdateTemplate_Handler,
		},
		{
			MethodName: "DeleteTemplate",
			Handler:    _TemplateMgr_DeleteTemplate_Handler,
		},
		{
			MethodName: "GetTemplate",
			Handler:    _TemplateMgr_GetTemplate_Handler,
		},
		{
			MethodName: "ListTemplates",
			Handler:    _TemplateMgr_ListTemplates_Handler,
		},
		{
			MethodName: "MatchTemplates",
			Handler:    _TemplateMgr_MatchTemplates_Handler,
		},
		{
			MethodName: "PickTemplate",
			Handler:    _TemplateMgr_PickTemplate_Handler,
		},
		{
			MethodName: "CreateModal",
			Handler:    _TemplateMgr_CreateModal_Handler,
		},
		{
			MethodName: "UpdateModal",
			Handler:    _TemplateMgr_UpdateModal_Handler,
		},
		{
			MethodName: "DeleteModal",
			Handler:    _TemplateMgr_DeleteModal_Handler,
		},
		{
			MethodName: "GetModal",
			Handler:    _TemplateMgr_GetModal_Handler,
		},
		{
			MethodName: "ListModals",
			Handler:    _TemplateMgr_ListModals_Handler,
		},
		{
			MethodName: "PickModal",
			Handler:    _TemplateMgr_PickModal_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	TagMgr_CreateTag_FullMethodName = "/header.TagMgr/CreateTag"
	TagMgr_UpdateTag_FullMethodName = "/header.TagMgr/UpdateTag"
	TagMgr_DeleteTag_FullMethodName = "/header.TagMgr/DeleteTag"
	TagMgr_ListTags_FullMethodName  = "/header.TagMgr/ListTags"
	TagMgr_GetTag_FullMethodName    = "/header.TagMgr/GetTag"
	TagMgr_MatchTag_FullMethodName  = "/header.TagMgr/MatchTag"
)

// TagMgrClient is the client API for TagMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TagMgrClient interface {
	CreateTag(ctx context.Context, in *Tag, opts ...grpc.CallOption) (*Tag, error)
	UpdateTag(ctx context.Context, in *Tag, opts ...grpc.CallOption) (*Tag, error)
	DeleteTag(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ListTags(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	GetTag(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Tag, error)
	MatchTag(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
}

type tagMgrClient struct {
	cc grpc.ClientConnInterface
}

func NewTagMgrClient(cc grpc.ClientConnInterface) TagMgrClient {
	return &tagMgrClient{cc}
}

func (c *tagMgrClient) CreateTag(ctx context.Context, in *Tag, opts ...grpc.CallOption) (*Tag, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Tag)
	err := c.cc.Invoke(ctx, TagMgr_CreateTag_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagMgrClient) UpdateTag(ctx context.Context, in *Tag, opts ...grpc.CallOption) (*Tag, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Tag)
	err := c.cc.Invoke(ctx, TagMgr_UpdateTag_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagMgrClient) DeleteTag(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TagMgr_DeleteTag_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagMgrClient) ListTags(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, TagMgr_ListTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagMgrClient) GetTag(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Tag, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Tag)
	err := c.cc.Invoke(ctx, TagMgr_GetTag_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagMgrClient) MatchTag(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, TagMgr_MatchTag_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TagMgrServer is the server API for TagMgr service.
// All implementations must embed UnimplementedTagMgrServer
// for forward compatibility.
type TagMgrServer interface {
	CreateTag(context.Context, *Tag) (*Tag, error)
	UpdateTag(context.Context, *Tag) (*Tag, error)
	DeleteTag(context.Context, *Id) (*Empty, error)
	ListTags(context.Context, *Id) (*Response, error)
	GetTag(context.Context, *Id) (*Tag, error)
	MatchTag(context.Context, *Ids) (*Response, error)
	mustEmbedUnimplementedTagMgrServer()
}

// UnimplementedTagMgrServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTagMgrServer struct{}

func (UnimplementedTagMgrServer) CreateTag(context.Context, *Tag) (*Tag, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTag not implemented")
}
func (UnimplementedTagMgrServer) UpdateTag(context.Context, *Tag) (*Tag, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTag not implemented")
}
func (UnimplementedTagMgrServer) DeleteTag(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTag not implemented")
}
func (UnimplementedTagMgrServer) ListTags(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTags not implemented")
}
func (UnimplementedTagMgrServer) GetTag(context.Context, *Id) (*Tag, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTag not implemented")
}
func (UnimplementedTagMgrServer) MatchTag(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchTag not implemented")
}
func (UnimplementedTagMgrServer) mustEmbedUnimplementedTagMgrServer() {}
func (UnimplementedTagMgrServer) testEmbeddedByValue()                {}

// UnsafeTagMgrServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TagMgrServer will
// result in compilation errors.
type UnsafeTagMgrServer interface {
	mustEmbedUnimplementedTagMgrServer()
}

func RegisterTagMgrServer(s grpc.ServiceRegistrar, srv TagMgrServer) {
	// If the following call pancis, it indicates UnimplementedTagMgrServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TagMgr_ServiceDesc, srv)
}

func _TagMgr_CreateTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Tag)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagMgrServer).CreateTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagMgr_CreateTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagMgrServer).CreateTag(ctx, req.(*Tag))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagMgr_UpdateTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Tag)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagMgrServer).UpdateTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagMgr_UpdateTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagMgrServer).UpdateTag(ctx, req.(*Tag))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagMgr_DeleteTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagMgrServer).DeleteTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagMgr_DeleteTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagMgrServer).DeleteTag(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagMgr_ListTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagMgrServer).ListTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagMgr_ListTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagMgrServer).ListTags(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagMgr_GetTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagMgrServer).GetTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagMgr_GetTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagMgrServer).GetTag(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagMgr_MatchTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagMgrServer).MatchTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagMgr_MatchTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagMgrServer).MatchTag(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

// TagMgr_ServiceDesc is the grpc.ServiceDesc for TagMgr service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TagMgr_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.TagMgr",
	HandlerType: (*TagMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTag",
			Handler:    _TagMgr_CreateTag_Handler,
		},
		{
			MethodName: "UpdateTag",
			Handler:    _TagMgr_UpdateTag_Handler,
		},
		{
			MethodName: "DeleteTag",
			Handler:    _TagMgr_DeleteTag_Handler,
		},
		{
			MethodName: "ListTags",
			Handler:    _TagMgr_ListTags_Handler,
		},
		{
			MethodName: "GetTag",
			Handler:    _TagMgr_GetTag_Handler,
		},
		{
			MethodName: "MatchTag",
			Handler:    _TagMgr_MatchTag_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	PaymentMgr_ListPlans_FullMethodName            = "/header.PaymentMgr/ListPlans"
	PaymentMgr_SearchSub_FullMethodName            = "/header.PaymentMgr/SearchSub"
	PaymentMgr_GetSub_FullMethodName               = "/header.PaymentMgr/GetSub"
	PaymentMgr_Purchase_FullMethodName             = "/header.PaymentMgr/Purchase"
	PaymentMgr_UpdateSubscription_FullMethodName   = "/header.PaymentMgr/UpdateSubscription"
	PaymentMgr_GetSubscription_FullMethodName      = "/header.PaymentMgr/GetSubscription"
	PaymentMgr_Pay_FullMethodName                  = "/header.PaymentMgr/Pay"
	PaymentMgr_CreateInvoice_FullMethodName        = "/header.PaymentMgr/CreateInvoice"
	PaymentMgr_UpdateInvoice_FullMethodName        = "/header.PaymentMgr/UpdateInvoice"
	PaymentMgr_FilterInvoices_FullMethodName       = "/header.PaymentMgr/FilterInvoices"
	PaymentMgr_DraftInvoice_FullMethodName         = "/header.PaymentMgr/DraftInvoice"
	PaymentMgr_ListComments_FullMethodName         = "/header.PaymentMgr/ListComments"
	PaymentMgr_AddComment_FullMethodName           = "/header.PaymentMgr/AddComment"
	PaymentMgr_ExportInvoice_FullMethodName        = "/header.PaymentMgr/ExportInvoice"
	PaymentMgr_ConvertInvoiceToHtml_FullMethodName = "/header.PaymentMgr/ConvertInvoiceToHtml"
	PaymentMgr_GetExchangeRate_FullMethodName      = "/header.PaymentMgr/GetExchangeRate"
	PaymentMgr_TransferMoney_FullMethodName        = "/header.PaymentMgr/TransferMoney"
	PaymentMgr_ListPaymentLogs_FullMethodName      = "/header.PaymentMgr/ListPaymentLogs"
)

// PaymentMgrClient is the client API for PaymentMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PaymentMgrClient interface {
	ListPlans(ctx context.Context, in *Id, opts ...grpc.CallOption) (*payment.Plans, error)
	SearchSub(ctx context.Context, in *account.SearchSubRequest, opts ...grpc.CallOption) (*AccSubs, error)
	GetSub(ctx context.Context, in *Id, opts ...grpc.CallOption) (*AccSub, error)
	Purchase(ctx context.Context, in *payment.PurchaseRequest, opts ...grpc.CallOption) (*payment.Invoice, error)
	UpdateSubscription(ctx context.Context, in *payment.Subscription, opts ...grpc.CallOption) (*payment.Subscription, error)
	GetSubscription(ctx context.Context, in *Id, opts ...grpc.CallOption) (*payment.Subscription, error)
	Pay(ctx context.Context, in *payment.PayRequest, opts ...grpc.CallOption) (*payment.Bill, error)
	CreateInvoice(ctx context.Context, in *payment.Invoice, opts ...grpc.CallOption) (*payment.Invoice, error)
	UpdateInvoice(ctx context.Context, in *payment.Invoice, opts ...grpc.CallOption) (*payment.Invoice, error)
	FilterInvoices(ctx context.Context, in *payment.ListInvoiceRequest, opts ...grpc.CallOption) (*payment.Invoices, error)
	DraftInvoice(ctx context.Context, in *payment.Subscription, opts ...grpc.CallOption) (*payment.Invoice, error)
	ListComments(ctx context.Context, in *Id, opts ...grpc.CallOption) (*payment.Comments, error)
	AddComment(ctx context.Context, in *payment.Comment, opts ...grpc.CallOption) (*payment.Comment, error)
	ExportInvoice(ctx context.Context, in *Id, opts ...grpc.CallOption) (*payment.String, error)
	ConvertInvoiceToHtml(ctx context.Context, in *payment.Invoice, opts ...grpc.CallOption) (*payment.String, error)
	GetExchangeRate(ctx context.Context, in *ExchangeRate, opts ...grpc.CallOption) (*ExchangeRate, error)
	TransferMoney(ctx context.Context, in *payment.PayRequest, opts ...grpc.CallOption) (*payment.Bill, error)
	// rpc AddCredit(payment.PayRequest) returns (Empty);
	ListPaymentLogs(ctx context.Context, in *Id, opts ...grpc.CallOption) (*payment.Logs, error)
}

type paymentMgrClient struct {
	cc grpc.ClientConnInterface
}

func NewPaymentMgrClient(cc grpc.ClientConnInterface) PaymentMgrClient {
	return &paymentMgrClient{cc}
}

func (c *paymentMgrClient) ListPlans(ctx context.Context, in *Id, opts ...grpc.CallOption) (*payment.Plans, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(payment.Plans)
	err := c.cc.Invoke(ctx, PaymentMgr_ListPlans_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) SearchSub(ctx context.Context, in *account.SearchSubRequest, opts ...grpc.CallOption) (*AccSubs, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AccSubs)
	err := c.cc.Invoke(ctx, PaymentMgr_SearchSub_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) GetSub(ctx context.Context, in *Id, opts ...grpc.CallOption) (*AccSub, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AccSub)
	err := c.cc.Invoke(ctx, PaymentMgr_GetSub_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) Purchase(ctx context.Context, in *payment.PurchaseRequest, opts ...grpc.CallOption) (*payment.Invoice, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(payment.Invoice)
	err := c.cc.Invoke(ctx, PaymentMgr_Purchase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) UpdateSubscription(ctx context.Context, in *payment.Subscription, opts ...grpc.CallOption) (*payment.Subscription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(payment.Subscription)
	err := c.cc.Invoke(ctx, PaymentMgr_UpdateSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) GetSubscription(ctx context.Context, in *Id, opts ...grpc.CallOption) (*payment.Subscription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(payment.Subscription)
	err := c.cc.Invoke(ctx, PaymentMgr_GetSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) Pay(ctx context.Context, in *payment.PayRequest, opts ...grpc.CallOption) (*payment.Bill, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(payment.Bill)
	err := c.cc.Invoke(ctx, PaymentMgr_Pay_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) CreateInvoice(ctx context.Context, in *payment.Invoice, opts ...grpc.CallOption) (*payment.Invoice, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(payment.Invoice)
	err := c.cc.Invoke(ctx, PaymentMgr_CreateInvoice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) UpdateInvoice(ctx context.Context, in *payment.Invoice, opts ...grpc.CallOption) (*payment.Invoice, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(payment.Invoice)
	err := c.cc.Invoke(ctx, PaymentMgr_UpdateInvoice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) FilterInvoices(ctx context.Context, in *payment.ListInvoiceRequest, opts ...grpc.CallOption) (*payment.Invoices, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(payment.Invoices)
	err := c.cc.Invoke(ctx, PaymentMgr_FilterInvoices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) DraftInvoice(ctx context.Context, in *payment.Subscription, opts ...grpc.CallOption) (*payment.Invoice, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(payment.Invoice)
	err := c.cc.Invoke(ctx, PaymentMgr_DraftInvoice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) ListComments(ctx context.Context, in *Id, opts ...grpc.CallOption) (*payment.Comments, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(payment.Comments)
	err := c.cc.Invoke(ctx, PaymentMgr_ListComments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) AddComment(ctx context.Context, in *payment.Comment, opts ...grpc.CallOption) (*payment.Comment, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(payment.Comment)
	err := c.cc.Invoke(ctx, PaymentMgr_AddComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) ExportInvoice(ctx context.Context, in *Id, opts ...grpc.CallOption) (*payment.String, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(payment.String)
	err := c.cc.Invoke(ctx, PaymentMgr_ExportInvoice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) ConvertInvoiceToHtml(ctx context.Context, in *payment.Invoice, opts ...grpc.CallOption) (*payment.String, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(payment.String)
	err := c.cc.Invoke(ctx, PaymentMgr_ConvertInvoiceToHtml_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) GetExchangeRate(ctx context.Context, in *ExchangeRate, opts ...grpc.CallOption) (*ExchangeRate, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExchangeRate)
	err := c.cc.Invoke(ctx, PaymentMgr_GetExchangeRate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) TransferMoney(ctx context.Context, in *payment.PayRequest, opts ...grpc.CallOption) (*payment.Bill, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(payment.Bill)
	err := c.cc.Invoke(ctx, PaymentMgr_TransferMoney_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) ListPaymentLogs(ctx context.Context, in *Id, opts ...grpc.CallOption) (*payment.Logs, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(payment.Logs)
	err := c.cc.Invoke(ctx, PaymentMgr_ListPaymentLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PaymentMgrServer is the server API for PaymentMgr service.
// All implementations must embed UnimplementedPaymentMgrServer
// for forward compatibility.
type PaymentMgrServer interface {
	ListPlans(context.Context, *Id) (*payment.Plans, error)
	SearchSub(context.Context, *account.SearchSubRequest) (*AccSubs, error)
	GetSub(context.Context, *Id) (*AccSub, error)
	Purchase(context.Context, *payment.PurchaseRequest) (*payment.Invoice, error)
	UpdateSubscription(context.Context, *payment.Subscription) (*payment.Subscription, error)
	GetSubscription(context.Context, *Id) (*payment.Subscription, error)
	Pay(context.Context, *payment.PayRequest) (*payment.Bill, error)
	CreateInvoice(context.Context, *payment.Invoice) (*payment.Invoice, error)
	UpdateInvoice(context.Context, *payment.Invoice) (*payment.Invoice, error)
	FilterInvoices(context.Context, *payment.ListInvoiceRequest) (*payment.Invoices, error)
	DraftInvoice(context.Context, *payment.Subscription) (*payment.Invoice, error)
	ListComments(context.Context, *Id) (*payment.Comments, error)
	AddComment(context.Context, *payment.Comment) (*payment.Comment, error)
	ExportInvoice(context.Context, *Id) (*payment.String, error)
	ConvertInvoiceToHtml(context.Context, *payment.Invoice) (*payment.String, error)
	GetExchangeRate(context.Context, *ExchangeRate) (*ExchangeRate, error)
	TransferMoney(context.Context, *payment.PayRequest) (*payment.Bill, error)
	// rpc AddCredit(payment.PayRequest) returns (Empty);
	ListPaymentLogs(context.Context, *Id) (*payment.Logs, error)
	mustEmbedUnimplementedPaymentMgrServer()
}

// UnimplementedPaymentMgrServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPaymentMgrServer struct{}

func (UnimplementedPaymentMgrServer) ListPlans(context.Context, *Id) (*payment.Plans, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPlans not implemented")
}
func (UnimplementedPaymentMgrServer) SearchSub(context.Context, *account.SearchSubRequest) (*AccSubs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchSub not implemented")
}
func (UnimplementedPaymentMgrServer) GetSub(context.Context, *Id) (*AccSub, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSub not implemented")
}
func (UnimplementedPaymentMgrServer) Purchase(context.Context, *payment.PurchaseRequest) (*payment.Invoice, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Purchase not implemented")
}
func (UnimplementedPaymentMgrServer) UpdateSubscription(context.Context, *payment.Subscription) (*payment.Subscription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSubscription not implemented")
}
func (UnimplementedPaymentMgrServer) GetSubscription(context.Context, *Id) (*payment.Subscription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubscription not implemented")
}
func (UnimplementedPaymentMgrServer) Pay(context.Context, *payment.PayRequest) (*payment.Bill, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pay not implemented")
}
func (UnimplementedPaymentMgrServer) CreateInvoice(context.Context, *payment.Invoice) (*payment.Invoice, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateInvoice not implemented")
}
func (UnimplementedPaymentMgrServer) UpdateInvoice(context.Context, *payment.Invoice) (*payment.Invoice, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateInvoice not implemented")
}
func (UnimplementedPaymentMgrServer) FilterInvoices(context.Context, *payment.ListInvoiceRequest) (*payment.Invoices, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FilterInvoices not implemented")
}
func (UnimplementedPaymentMgrServer) DraftInvoice(context.Context, *payment.Subscription) (*payment.Invoice, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DraftInvoice not implemented")
}
func (UnimplementedPaymentMgrServer) ListComments(context.Context, *Id) (*payment.Comments, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListComments not implemented")
}
func (UnimplementedPaymentMgrServer) AddComment(context.Context, *payment.Comment) (*payment.Comment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddComment not implemented")
}
func (UnimplementedPaymentMgrServer) ExportInvoice(context.Context, *Id) (*payment.String, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportInvoice not implemented")
}
func (UnimplementedPaymentMgrServer) ConvertInvoiceToHtml(context.Context, *payment.Invoice) (*payment.String, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConvertInvoiceToHtml not implemented")
}
func (UnimplementedPaymentMgrServer) GetExchangeRate(context.Context, *ExchangeRate) (*ExchangeRate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExchangeRate not implemented")
}
func (UnimplementedPaymentMgrServer) TransferMoney(context.Context, *payment.PayRequest) (*payment.Bill, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferMoney not implemented")
}
func (UnimplementedPaymentMgrServer) ListPaymentLogs(context.Context, *Id) (*payment.Logs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPaymentLogs not implemented")
}
func (UnimplementedPaymentMgrServer) mustEmbedUnimplementedPaymentMgrServer() {}
func (UnimplementedPaymentMgrServer) testEmbeddedByValue()                    {}

// UnsafePaymentMgrServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PaymentMgrServer will
// result in compilation errors.
type UnsafePaymentMgrServer interface {
	mustEmbedUnimplementedPaymentMgrServer()
}

func RegisterPaymentMgrServer(s grpc.ServiceRegistrar, srv PaymentMgrServer) {
	// If the following call pancis, it indicates UnimplementedPaymentMgrServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PaymentMgr_ServiceDesc, srv)
}

func _PaymentMgr_ListPlans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).ListPlans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentMgr_ListPlans_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).ListPlans(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_SearchSub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.SearchSubRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).SearchSub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentMgr_SearchSub_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).SearchSub(ctx, req.(*account.SearchSubRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_GetSub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).GetSub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentMgr_GetSub_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).GetSub(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_Purchase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.PurchaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).Purchase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentMgr_Purchase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).Purchase(ctx, req.(*payment.PurchaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_UpdateSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.Subscription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).UpdateSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentMgr_UpdateSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).UpdateSubscription(ctx, req.(*payment.Subscription))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_GetSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).GetSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentMgr_GetSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).GetSubscription(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_Pay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.PayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).Pay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentMgr_Pay_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).Pay(ctx, req.(*payment.PayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_CreateInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.Invoice)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).CreateInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentMgr_CreateInvoice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).CreateInvoice(ctx, req.(*payment.Invoice))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_UpdateInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.Invoice)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).UpdateInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentMgr_UpdateInvoice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).UpdateInvoice(ctx, req.(*payment.Invoice))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_FilterInvoices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.ListInvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).FilterInvoices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentMgr_FilterInvoices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).FilterInvoices(ctx, req.(*payment.ListInvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_DraftInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.Subscription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).DraftInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentMgr_DraftInvoice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).DraftInvoice(ctx, req.(*payment.Subscription))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_ListComments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).ListComments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentMgr_ListComments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).ListComments(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_AddComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.Comment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).AddComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentMgr_AddComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).AddComment(ctx, req.(*payment.Comment))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_ExportInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).ExportInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentMgr_ExportInvoice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).ExportInvoice(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_ConvertInvoiceToHtml_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.Invoice)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).ConvertInvoiceToHtml(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentMgr_ConvertInvoiceToHtml_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).ConvertInvoiceToHtml(ctx, req.(*payment.Invoice))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_GetExchangeRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExchangeRate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).GetExchangeRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentMgr_GetExchangeRate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).GetExchangeRate(ctx, req.(*ExchangeRate))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_TransferMoney_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.PayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).TransferMoney(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentMgr_TransferMoney_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).TransferMoney(ctx, req.(*payment.PayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_ListPaymentLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).ListPaymentLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentMgr_ListPaymentLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).ListPaymentLogs(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

// PaymentMgr_ServiceDesc is the grpc.ServiceDesc for PaymentMgr service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PaymentMgr_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.PaymentMgr",
	HandlerType: (*PaymentMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListPlans",
			Handler:    _PaymentMgr_ListPlans_Handler,
		},
		{
			MethodName: "SearchSub",
			Handler:    _PaymentMgr_SearchSub_Handler,
		},
		{
			MethodName: "GetSub",
			Handler:    _PaymentMgr_GetSub_Handler,
		},
		{
			MethodName: "Purchase",
			Handler:    _PaymentMgr_Purchase_Handler,
		},
		{
			MethodName: "UpdateSubscription",
			Handler:    _PaymentMgr_UpdateSubscription_Handler,
		},
		{
			MethodName: "GetSubscription",
			Handler:    _PaymentMgr_GetSubscription_Handler,
		},
		{
			MethodName: "Pay",
			Handler:    _PaymentMgr_Pay_Handler,
		},
		{
			MethodName: "CreateInvoice",
			Handler:    _PaymentMgr_CreateInvoice_Handler,
		},
		{
			MethodName: "UpdateInvoice",
			Handler:    _PaymentMgr_UpdateInvoice_Handler,
		},
		{
			MethodName: "FilterInvoices",
			Handler:    _PaymentMgr_FilterInvoices_Handler,
		},
		{
			MethodName: "DraftInvoice",
			Handler:    _PaymentMgr_DraftInvoice_Handler,
		},
		{
			MethodName: "ListComments",
			Handler:    _PaymentMgr_ListComments_Handler,
		},
		{
			MethodName: "AddComment",
			Handler:    _PaymentMgr_AddComment_Handler,
		},
		{
			MethodName: "ExportInvoice",
			Handler:    _PaymentMgr_ExportInvoice_Handler,
		},
		{
			MethodName: "ConvertInvoiceToHtml",
			Handler:    _PaymentMgr_ConvertInvoiceToHtml_Handler,
		},
		{
			MethodName: "GetExchangeRate",
			Handler:    _PaymentMgr_GetExchangeRate_Handler,
		},
		{
			MethodName: "TransferMoney",
			Handler:    _PaymentMgr_TransferMoney_Handler,
		},
		{
			MethodName: "ListPaymentLogs",
			Handler:    _PaymentMgr_ListPaymentLogs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	Pubsub_Fire_FullMethodName         = "/header.Pubsub/Fire"
	Pubsub_IsSubscribed_FullMethodName = "/header.Pubsub/IsSubscribed"
	Pubsub_Poll_FullMethodName         = "/header.Pubsub/Poll"
	Pubsub_Subscribe_FullMethodName    = "/header.Pubsub/Subscribe"
)

// PubsubClient is the client API for Pubsub service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// pubsub services
type PubsubClient interface {
	Fire(ctx context.Context, in *PsMessage, opts ...grpc.CallOption) (*Empty, error)
	IsSubscribed(ctx context.Context, in *PsMessage, opts ...grpc.CallOption) (*Id, error)
	Poll(ctx context.Context, in *RealtimeSubscription, opts ...grpc.CallOption) (*PollResult, error)
	Subscribe(ctx context.Context, in *RealtimeSubscription, opts ...grpc.CallOption) (*RealtimeSubscription, error)
}

type pubsubClient struct {
	cc grpc.ClientConnInterface
}

func NewPubsubClient(cc grpc.ClientConnInterface) PubsubClient {
	return &pubsubClient{cc}
}

func (c *pubsubClient) Fire(ctx context.Context, in *PsMessage, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Pubsub_Fire_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pubsubClient) IsSubscribed(ctx context.Context, in *PsMessage, opts ...grpc.CallOption) (*Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Id)
	err := c.cc.Invoke(ctx, Pubsub_IsSubscribed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pubsubClient) Poll(ctx context.Context, in *RealtimeSubscription, opts ...grpc.CallOption) (*PollResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PollResult)
	err := c.cc.Invoke(ctx, Pubsub_Poll_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pubsubClient) Subscribe(ctx context.Context, in *RealtimeSubscription, opts ...grpc.CallOption) (*RealtimeSubscription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RealtimeSubscription)
	err := c.cc.Invoke(ctx, Pubsub_Subscribe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PubsubServer is the server API for Pubsub service.
// All implementations must embed UnimplementedPubsubServer
// for forward compatibility.
//
// pubsub services
type PubsubServer interface {
	Fire(context.Context, *PsMessage) (*Empty, error)
	IsSubscribed(context.Context, *PsMessage) (*Id, error)
	Poll(context.Context, *RealtimeSubscription) (*PollResult, error)
	Subscribe(context.Context, *RealtimeSubscription) (*RealtimeSubscription, error)
	mustEmbedUnimplementedPubsubServer()
}

// UnimplementedPubsubServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPubsubServer struct{}

func (UnimplementedPubsubServer) Fire(context.Context, *PsMessage) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Fire not implemented")
}
func (UnimplementedPubsubServer) IsSubscribed(context.Context, *PsMessage) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsSubscribed not implemented")
}
func (UnimplementedPubsubServer) Poll(context.Context, *RealtimeSubscription) (*PollResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Poll not implemented")
}
func (UnimplementedPubsubServer) Subscribe(context.Context, *RealtimeSubscription) (*RealtimeSubscription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedPubsubServer) mustEmbedUnimplementedPubsubServer() {}
func (UnimplementedPubsubServer) testEmbeddedByValue()                {}

// UnsafePubsubServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PubsubServer will
// result in compilation errors.
type UnsafePubsubServer interface {
	mustEmbedUnimplementedPubsubServer()
}

func RegisterPubsubServer(s grpc.ServiceRegistrar, srv PubsubServer) {
	// If the following call pancis, it indicates UnimplementedPubsubServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Pubsub_ServiceDesc, srv)
}

func _Pubsub_Fire_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PsMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PubsubServer).Fire(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Pubsub_Fire_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PubsubServer).Fire(ctx, req.(*PsMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pubsub_IsSubscribed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PsMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PubsubServer).IsSubscribed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Pubsub_IsSubscribed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PubsubServer).IsSubscribed(ctx, req.(*PsMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pubsub_Poll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RealtimeSubscription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PubsubServer).Poll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Pubsub_Poll_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PubsubServer).Poll(ctx, req.(*RealtimeSubscription))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pubsub_Subscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RealtimeSubscription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PubsubServer).Subscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Pubsub_Subscribe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PubsubServer).Subscribe(ctx, req.(*RealtimeSubscription))
	}
	return interceptor(ctx, in, info, handler)
}

// Pubsub_ServiceDesc is the grpc.ServiceDesc for Pubsub service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Pubsub_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.Pubsub",
	HandlerType: (*PubsubServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Fire",
			Handler:    _Pubsub_Fire_Handler,
		},
		{
			MethodName: "IsSubscribed",
			Handler:    _Pubsub_IsSubscribed_Handler,
		},
		{
			MethodName: "Poll",
			Handler:    _Pubsub_Poll_Handler,
		},
		{
			MethodName: "Subscribe",
			Handler:    _Pubsub_Subscribe_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	RealtimePublisher_Subscribe_FullMethodName = "/header.RealtimePublisher/Subscribe"
)

// RealtimePublisherClient is the client API for RealtimePublisher service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RealtimePublisherClient interface {
	Subscribe(ctx context.Context, in *RealtimeSubscription, opts ...grpc.CallOption) (*Empty, error)
}

type realtimePublisherClient struct {
	cc grpc.ClientConnInterface
}

func NewRealtimePublisherClient(cc grpc.ClientConnInterface) RealtimePublisherClient {
	return &realtimePublisherClient{cc}
}

func (c *realtimePublisherClient) Subscribe(ctx context.Context, in *RealtimeSubscription, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, RealtimePublisher_Subscribe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RealtimePublisherServer is the server API for RealtimePublisher service.
// All implementations must embed UnimplementedRealtimePublisherServer
// for forward compatibility.
type RealtimePublisherServer interface {
	Subscribe(context.Context, *RealtimeSubscription) (*Empty, error)
	mustEmbedUnimplementedRealtimePublisherServer()
}

// UnimplementedRealtimePublisherServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRealtimePublisherServer struct{}

func (UnimplementedRealtimePublisherServer) Subscribe(context.Context, *RealtimeSubscription) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedRealtimePublisherServer) mustEmbedUnimplementedRealtimePublisherServer() {}
func (UnimplementedRealtimePublisherServer) testEmbeddedByValue()                           {}

// UnsafeRealtimePublisherServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RealtimePublisherServer will
// result in compilation errors.
type UnsafeRealtimePublisherServer interface {
	mustEmbedUnimplementedRealtimePublisherServer()
}

func RegisterRealtimePublisherServer(s grpc.ServiceRegistrar, srv RealtimePublisherServer) {
	// If the following call pancis, it indicates UnimplementedRealtimePublisherServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RealtimePublisher_ServiceDesc, srv)
}

func _RealtimePublisher_Subscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RealtimeSubscription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RealtimePublisherServer).Subscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RealtimePublisher_Subscribe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RealtimePublisherServer).Subscribe(ctx, req.(*RealtimeSubscription))
	}
	return interceptor(ctx, in, info, handler)
}

// RealtimePublisher_ServiceDesc is the grpc.ServiceDesc for RealtimePublisher service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RealtimePublisher_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.RealtimePublisher",
	HandlerType: (*RealtimePublisherServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Subscribe",
			Handler:    _RealtimePublisher_Subscribe_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	FabikonService_ReadFbFanpageSetting_FullMethodName   = "/header.FabikonService/ReadFbFanpageSetting"
	FabikonService_UpdateFbFanpageSetting_FullMethodName = "/header.FabikonService/UpdateFbFanpageSetting"
	FabikonService_ListFbFanpageSettings_FullMethodName  = "/header.FabikonService/ListFbFanpageSettings"
	FabikonService_ListFacebookPosts_FullMethodName      = "/header.FabikonService/ListFacebookPosts"
	FabikonService_MatchFacebookPosts_FullMethodName     = "/header.FabikonService/MatchFacebookPosts"
	FabikonService_ResyncFacebookPost_FullMethodName     = "/header.FabikonService/ResyncFacebookPost"
	FabikonService_RemoveFbUserLabel_FullMethodName      = "/header.FabikonService/RemoveFbUserLabel"
	FabikonService_AddFbUserLabel_FullMethodName         = "/header.FabikonService/AddFbUserLabel"
	FabikonService_GenerateRefLink_FullMethodName        = "/header.FabikonService/GenerateRefLink"
	FabikonService_SyncAdsFlow_FullMethodName            = "/header.FabikonService/SyncAdsFlow"
	FabikonService_GetAdsAudience_FullMethodName         = "/header.FabikonService/GetAdsAudience"
	FabikonService_CreateAdsAudience_FullMethodName      = "/header.FabikonService/CreateAdsAudience"
	FabikonService_UploadAdsAudienceUsers_FullMethodName = "/header.FabikonService/UploadAdsAudienceUsers"
	FabikonService_DeleteAdsAudienceUsers_FullMethodName = "/header.FabikonService/DeleteAdsAudienceUsers"
	FabikonService_ListAdAccounts_FullMethodName         = "/header.FabikonService/ListAdAccounts"
	FabikonService_ListFbFanpageSettings2_FullMethodName = "/header.FabikonService/ListFbFanpageSettings2"
)

// FabikonServiceClient is the client API for FabikonService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FabikonServiceClient interface {
	ReadFbFanpageSetting(ctx context.Context, in *Id, opts ...grpc.CallOption) (*FbFanpageSetting, error)
	UpdateFbFanpageSetting(ctx context.Context, in *FbFanpageSetting, opts ...grpc.CallOption) (*FbFanpageSetting, error)
	ListFbFanpageSettings(ctx context.Context, in *Id, opts ...grpc.CallOption) (*FbFanpageSettings, error)
	ListFacebookPosts(ctx context.Context, in *FacebookPostRequest, opts ...grpc.CallOption) (*Response, error)
	MatchFacebookPosts(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
	ResyncFacebookPost(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	RemoveFbUserLabel(ctx context.Context, in *User, opts ...grpc.CallOption) (*Empty, error)
	AddFbUserLabel(ctx context.Context, in *User, opts ...grpc.CallOption) (*Empty, error)
	GenerateRefLink(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Id, error)
	SyncAdsFlow(ctx context.Context, in *FacebookAdsFlow, opts ...grpc.CallOption) (*Id, error)
	GetAdsAudience(ctx context.Context, in *MetaCustomAudience, opts ...grpc.CallOption) (*MetaCustomAudience, error)
	CreateAdsAudience(ctx context.Context, in *MetaCustomAudience, opts ...grpc.CallOption) (*MetaCustomAudience, error)
	// rpc DeleteAdsAudience(header.MetaCustomAudience) returns (header.MetaCustomAudience);
	UploadAdsAudienceUsers(ctx context.Context, in *CustomAudienceBatchRequest, opts ...grpc.CallOption) (*CustomAudienceBatchResponse, error)
	DeleteAdsAudienceUsers(ctx context.Context, in *CustomAudienceBatchRequest, opts ...grpc.CallOption) (*CustomAudienceBatchResponse, error)
	ListAdAccounts(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	ListFbFanpageSettings2(ctx context.Context, in *ListPageSettingRequest, opts ...grpc.CallOption) (*Response, error)
}

type fabikonServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFabikonServiceClient(cc grpc.ClientConnInterface) FabikonServiceClient {
	return &fabikonServiceClient{cc}
}

func (c *fabikonServiceClient) ReadFbFanpageSetting(ctx context.Context, in *Id, opts ...grpc.CallOption) (*FbFanpageSetting, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FbFanpageSetting)
	err := c.cc.Invoke(ctx, FabikonService_ReadFbFanpageSetting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fabikonServiceClient) UpdateFbFanpageSetting(ctx context.Context, in *FbFanpageSetting, opts ...grpc.CallOption) (*FbFanpageSetting, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FbFanpageSetting)
	err := c.cc.Invoke(ctx, FabikonService_UpdateFbFanpageSetting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fabikonServiceClient) ListFbFanpageSettings(ctx context.Context, in *Id, opts ...grpc.CallOption) (*FbFanpageSettings, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FbFanpageSettings)
	err := c.cc.Invoke(ctx, FabikonService_ListFbFanpageSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fabikonServiceClient) ListFacebookPosts(ctx context.Context, in *FacebookPostRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, FabikonService_ListFacebookPosts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fabikonServiceClient) MatchFacebookPosts(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, FabikonService_MatchFacebookPosts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fabikonServiceClient) ResyncFacebookPost(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, FabikonService_ResyncFacebookPost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fabikonServiceClient) RemoveFbUserLabel(ctx context.Context, in *User, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, FabikonService_RemoveFbUserLabel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fabikonServiceClient) AddFbUserLabel(ctx context.Context, in *User, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, FabikonService_AddFbUserLabel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fabikonServiceClient) GenerateRefLink(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Id)
	err := c.cc.Invoke(ctx, FabikonService_GenerateRefLink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fabikonServiceClient) SyncAdsFlow(ctx context.Context, in *FacebookAdsFlow, opts ...grpc.CallOption) (*Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Id)
	err := c.cc.Invoke(ctx, FabikonService_SyncAdsFlow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fabikonServiceClient) GetAdsAudience(ctx context.Context, in *MetaCustomAudience, opts ...grpc.CallOption) (*MetaCustomAudience, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MetaCustomAudience)
	err := c.cc.Invoke(ctx, FabikonService_GetAdsAudience_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fabikonServiceClient) CreateAdsAudience(ctx context.Context, in *MetaCustomAudience, opts ...grpc.CallOption) (*MetaCustomAudience, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MetaCustomAudience)
	err := c.cc.Invoke(ctx, FabikonService_CreateAdsAudience_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fabikonServiceClient) UploadAdsAudienceUsers(ctx context.Context, in *CustomAudienceBatchRequest, opts ...grpc.CallOption) (*CustomAudienceBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CustomAudienceBatchResponse)
	err := c.cc.Invoke(ctx, FabikonService_UploadAdsAudienceUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fabikonServiceClient) DeleteAdsAudienceUsers(ctx context.Context, in *CustomAudienceBatchRequest, opts ...grpc.CallOption) (*CustomAudienceBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CustomAudienceBatchResponse)
	err := c.cc.Invoke(ctx, FabikonService_DeleteAdsAudienceUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fabikonServiceClient) ListAdAccounts(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, FabikonService_ListAdAccounts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fabikonServiceClient) ListFbFanpageSettings2(ctx context.Context, in *ListPageSettingRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, FabikonService_ListFbFanpageSettings2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FabikonServiceServer is the server API for FabikonService service.
// All implementations must embed UnimplementedFabikonServiceServer
// for forward compatibility.
type FabikonServiceServer interface {
	ReadFbFanpageSetting(context.Context, *Id) (*FbFanpageSetting, error)
	UpdateFbFanpageSetting(context.Context, *FbFanpageSetting) (*FbFanpageSetting, error)
	ListFbFanpageSettings(context.Context, *Id) (*FbFanpageSettings, error)
	ListFacebookPosts(context.Context, *FacebookPostRequest) (*Response, error)
	MatchFacebookPosts(context.Context, *Ids) (*Response, error)
	ResyncFacebookPost(context.Context, *Id) (*Response, error)
	RemoveFbUserLabel(context.Context, *User) (*Empty, error)
	AddFbUserLabel(context.Context, *User) (*Empty, error)
	GenerateRefLink(context.Context, *Id) (*Id, error)
	SyncAdsFlow(context.Context, *FacebookAdsFlow) (*Id, error)
	GetAdsAudience(context.Context, *MetaCustomAudience) (*MetaCustomAudience, error)
	CreateAdsAudience(context.Context, *MetaCustomAudience) (*MetaCustomAudience, error)
	// rpc DeleteAdsAudience(header.MetaCustomAudience) returns (header.MetaCustomAudience);
	UploadAdsAudienceUsers(context.Context, *CustomAudienceBatchRequest) (*CustomAudienceBatchResponse, error)
	DeleteAdsAudienceUsers(context.Context, *CustomAudienceBatchRequest) (*CustomAudienceBatchResponse, error)
	ListAdAccounts(context.Context, *Id) (*Response, error)
	ListFbFanpageSettings2(context.Context, *ListPageSettingRequest) (*Response, error)
	mustEmbedUnimplementedFabikonServiceServer()
}

// UnimplementedFabikonServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFabikonServiceServer struct{}

func (UnimplementedFabikonServiceServer) ReadFbFanpageSetting(context.Context, *Id) (*FbFanpageSetting, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadFbFanpageSetting not implemented")
}
func (UnimplementedFabikonServiceServer) UpdateFbFanpageSetting(context.Context, *FbFanpageSetting) (*FbFanpageSetting, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateFbFanpageSetting not implemented")
}
func (UnimplementedFabikonServiceServer) ListFbFanpageSettings(context.Context, *Id) (*FbFanpageSettings, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFbFanpageSettings not implemented")
}
func (UnimplementedFabikonServiceServer) ListFacebookPosts(context.Context, *FacebookPostRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFacebookPosts not implemented")
}
func (UnimplementedFabikonServiceServer) MatchFacebookPosts(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchFacebookPosts not implemented")
}
func (UnimplementedFabikonServiceServer) ResyncFacebookPost(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResyncFacebookPost not implemented")
}
func (UnimplementedFabikonServiceServer) RemoveFbUserLabel(context.Context, *User) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveFbUserLabel not implemented")
}
func (UnimplementedFabikonServiceServer) AddFbUserLabel(context.Context, *User) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddFbUserLabel not implemented")
}
func (UnimplementedFabikonServiceServer) GenerateRefLink(context.Context, *Id) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateRefLink not implemented")
}
func (UnimplementedFabikonServiceServer) SyncAdsFlow(context.Context, *FacebookAdsFlow) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncAdsFlow not implemented")
}
func (UnimplementedFabikonServiceServer) GetAdsAudience(context.Context, *MetaCustomAudience) (*MetaCustomAudience, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAdsAudience not implemented")
}
func (UnimplementedFabikonServiceServer) CreateAdsAudience(context.Context, *MetaCustomAudience) (*MetaCustomAudience, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAdsAudience not implemented")
}
func (UnimplementedFabikonServiceServer) UploadAdsAudienceUsers(context.Context, *CustomAudienceBatchRequest) (*CustomAudienceBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadAdsAudienceUsers not implemented")
}
func (UnimplementedFabikonServiceServer) DeleteAdsAudienceUsers(context.Context, *CustomAudienceBatchRequest) (*CustomAudienceBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAdsAudienceUsers not implemented")
}
func (UnimplementedFabikonServiceServer) ListAdAccounts(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAdAccounts not implemented")
}
func (UnimplementedFabikonServiceServer) ListFbFanpageSettings2(context.Context, *ListPageSettingRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFbFanpageSettings2 not implemented")
}
func (UnimplementedFabikonServiceServer) mustEmbedUnimplementedFabikonServiceServer() {}
func (UnimplementedFabikonServiceServer) testEmbeddedByValue()                        {}

// UnsafeFabikonServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FabikonServiceServer will
// result in compilation errors.
type UnsafeFabikonServiceServer interface {
	mustEmbedUnimplementedFabikonServiceServer()
}

func RegisterFabikonServiceServer(s grpc.ServiceRegistrar, srv FabikonServiceServer) {
	// If the following call pancis, it indicates UnimplementedFabikonServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FabikonService_ServiceDesc, srv)
}

func _FabikonService_ReadFbFanpageSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FabikonServiceServer).ReadFbFanpageSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FabikonService_ReadFbFanpageSetting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FabikonServiceServer).ReadFbFanpageSetting(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _FabikonService_UpdateFbFanpageSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FbFanpageSetting)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FabikonServiceServer).UpdateFbFanpageSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FabikonService_UpdateFbFanpageSetting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FabikonServiceServer).UpdateFbFanpageSetting(ctx, req.(*FbFanpageSetting))
	}
	return interceptor(ctx, in, info, handler)
}

func _FabikonService_ListFbFanpageSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FabikonServiceServer).ListFbFanpageSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FabikonService_ListFbFanpageSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FabikonServiceServer).ListFbFanpageSettings(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _FabikonService_ListFacebookPosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FacebookPostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FabikonServiceServer).ListFacebookPosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FabikonService_ListFacebookPosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FabikonServiceServer).ListFacebookPosts(ctx, req.(*FacebookPostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FabikonService_MatchFacebookPosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FabikonServiceServer).MatchFacebookPosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FabikonService_MatchFacebookPosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FabikonServiceServer).MatchFacebookPosts(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _FabikonService_ResyncFacebookPost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FabikonServiceServer).ResyncFacebookPost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FabikonService_ResyncFacebookPost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FabikonServiceServer).ResyncFacebookPost(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _FabikonService_RemoveFbUserLabel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FabikonServiceServer).RemoveFbUserLabel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FabikonService_RemoveFbUserLabel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FabikonServiceServer).RemoveFbUserLabel(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _FabikonService_AddFbUserLabel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FabikonServiceServer).AddFbUserLabel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FabikonService_AddFbUserLabel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FabikonServiceServer).AddFbUserLabel(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _FabikonService_GenerateRefLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FabikonServiceServer).GenerateRefLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FabikonService_GenerateRefLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FabikonServiceServer).GenerateRefLink(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _FabikonService_SyncAdsFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FacebookAdsFlow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FabikonServiceServer).SyncAdsFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FabikonService_SyncAdsFlow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FabikonServiceServer).SyncAdsFlow(ctx, req.(*FacebookAdsFlow))
	}
	return interceptor(ctx, in, info, handler)
}

func _FabikonService_GetAdsAudience_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetaCustomAudience)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FabikonServiceServer).GetAdsAudience(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FabikonService_GetAdsAudience_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FabikonServiceServer).GetAdsAudience(ctx, req.(*MetaCustomAudience))
	}
	return interceptor(ctx, in, info, handler)
}

func _FabikonService_CreateAdsAudience_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetaCustomAudience)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FabikonServiceServer).CreateAdsAudience(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FabikonService_CreateAdsAudience_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FabikonServiceServer).CreateAdsAudience(ctx, req.(*MetaCustomAudience))
	}
	return interceptor(ctx, in, info, handler)
}

func _FabikonService_UploadAdsAudienceUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CustomAudienceBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FabikonServiceServer).UploadAdsAudienceUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FabikonService_UploadAdsAudienceUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FabikonServiceServer).UploadAdsAudienceUsers(ctx, req.(*CustomAudienceBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FabikonService_DeleteAdsAudienceUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CustomAudienceBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FabikonServiceServer).DeleteAdsAudienceUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FabikonService_DeleteAdsAudienceUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FabikonServiceServer).DeleteAdsAudienceUsers(ctx, req.(*CustomAudienceBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FabikonService_ListAdAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FabikonServiceServer).ListAdAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FabikonService_ListAdAccounts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FabikonServiceServer).ListAdAccounts(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _FabikonService_ListFbFanpageSettings2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPageSettingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FabikonServiceServer).ListFbFanpageSettings2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FabikonService_ListFbFanpageSettings2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FabikonServiceServer).ListFbFanpageSettings2(ctx, req.(*ListPageSettingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FabikonService_ServiceDesc is the grpc.ServiceDesc for FabikonService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FabikonService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.FabikonService",
	HandlerType: (*FabikonServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadFbFanpageSetting",
			Handler:    _FabikonService_ReadFbFanpageSetting_Handler,
		},
		{
			MethodName: "UpdateFbFanpageSetting",
			Handler:    _FabikonService_UpdateFbFanpageSetting_Handler,
		},
		{
			MethodName: "ListFbFanpageSettings",
			Handler:    _FabikonService_ListFbFanpageSettings_Handler,
		},
		{
			MethodName: "ListFacebookPosts",
			Handler:    _FabikonService_ListFacebookPosts_Handler,
		},
		{
			MethodName: "MatchFacebookPosts",
			Handler:    _FabikonService_MatchFacebookPosts_Handler,
		},
		{
			MethodName: "ResyncFacebookPost",
			Handler:    _FabikonService_ResyncFacebookPost_Handler,
		},
		{
			MethodName: "RemoveFbUserLabel",
			Handler:    _FabikonService_RemoveFbUserLabel_Handler,
		},
		{
			MethodName: "AddFbUserLabel",
			Handler:    _FabikonService_AddFbUserLabel_Handler,
		},
		{
			MethodName: "GenerateRefLink",
			Handler:    _FabikonService_GenerateRefLink_Handler,
		},
		{
			MethodName: "SyncAdsFlow",
			Handler:    _FabikonService_SyncAdsFlow_Handler,
		},
		{
			MethodName: "GetAdsAudience",
			Handler:    _FabikonService_GetAdsAudience_Handler,
		},
		{
			MethodName: "CreateAdsAudience",
			Handler:    _FabikonService_CreateAdsAudience_Handler,
		},
		{
			MethodName: "UploadAdsAudienceUsers",
			Handler:    _FabikonService_UploadAdsAudienceUsers_Handler,
		},
		{
			MethodName: "DeleteAdsAudienceUsers",
			Handler:    _FabikonService_DeleteAdsAudienceUsers_Handler,
		},
		{
			MethodName: "ListAdAccounts",
			Handler:    _FabikonService_ListAdAccounts_Handler,
		},
		{
			MethodName: "ListFbFanpageSettings2",
			Handler:    _FabikonService_ListFbFanpageSettings2_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	ChannelConnector_GetIntegration_FullMethodName = "/header.ChannelConnector/GetIntegration"
)

// ChannelConnectorClient is the client API for ChannelConnector service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChannelConnectorClient interface {
	GetIntegration(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Integration, error)
}

type channelConnectorClient struct {
	cc grpc.ClientConnInterface
}

func NewChannelConnectorClient(cc grpc.ClientConnInterface) ChannelConnectorClient {
	return &channelConnectorClient{cc}
}

func (c *channelConnectorClient) GetIntegration(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Integration, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Integration)
	err := c.cc.Invoke(ctx, ChannelConnector_GetIntegration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChannelConnectorServer is the server API for ChannelConnector service.
// All implementations must embed UnimplementedChannelConnectorServer
// for forward compatibility.
type ChannelConnectorServer interface {
	GetIntegration(context.Context, *Id) (*Integration, error)
	mustEmbedUnimplementedChannelConnectorServer()
}

// UnimplementedChannelConnectorServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedChannelConnectorServer struct{}

func (UnimplementedChannelConnectorServer) GetIntegration(context.Context, *Id) (*Integration, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIntegration not implemented")
}
func (UnimplementedChannelConnectorServer) mustEmbedUnimplementedChannelConnectorServer() {}
func (UnimplementedChannelConnectorServer) testEmbeddedByValue()                          {}

// UnsafeChannelConnectorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChannelConnectorServer will
// result in compilation errors.
type UnsafeChannelConnectorServer interface {
	mustEmbedUnimplementedChannelConnectorServer()
}

func RegisterChannelConnectorServer(s grpc.ServiceRegistrar, srv ChannelConnectorServer) {
	// If the following call pancis, it indicates UnimplementedChannelConnectorServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ChannelConnector_ServiceDesc, srv)
}

func _ChannelConnector_GetIntegration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelConnectorServer).GetIntegration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChannelConnector_GetIntegration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelConnectorServer).GetIntegration(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

// ChannelConnector_ServiceDesc is the grpc.ServiceDesc for ChannelConnector service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChannelConnector_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.ChannelConnector",
	HandlerType: (*ChannelConnectorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetIntegration",
			Handler:    _ChannelConnector_GetIntegration_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	ZalokonService_SendEventToZalo_FullMethodName           = "/header.ZalokonService/SendEventToZalo"
	ZalokonService_RequestZaloUserToMakeCall_FullMethodName = "/header.ZalokonService/RequestZaloUserToMakeCall"
	ZalokonService_MakeSureZaloUser_FullMethodName          = "/header.ZalokonService/MakeSureZaloUser"
	ZalokonService_GetZaloUserCallConsent_FullMethodName    = "/header.ZalokonService/GetZaloUserCallConsent"
	ZalokonService_SendZNS_FullMethodName                   = "/header.ZalokonService/SendZNS"
	ZalokonService_CreateZNSTemplate_FullMethodName         = "/header.ZalokonService/CreateZNSTemplate"
	ZalokonService_UpdateZNSTemplate_FullMethodName         = "/header.ZalokonService/UpdateZNSTemplate"
	ZalokonService_ListZNSTemplates_FullMethodName          = "/header.ZalokonService/ListZNSTemplates"
	ZalokonService_MatchZNSTemplates_FullMethodName         = "/header.ZalokonService/MatchZNSTemplates"
	ZalokonService_ListZNSMedias_FullMethodName             = "/header.ZalokonService/ListZNSMedias"
	ZalokonService_MatchZNSMedias_FullMethodName            = "/header.ZalokonService/MatchZNSMedias"
	ZalokonService_CreateZNSMedia_FullMethodName            = "/header.ZalokonService/CreateZNSMedia"
	ZalokonService_DeleteZNSMedia_FullMethodName            = "/header.ZalokonService/DeleteZNSMedia"
)

// ZalokonServiceClient is the client API for ZalokonService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ZalokonServiceClient interface {
	SendEventToZalo(ctx context.Context, in *Events, opts ...grpc.CallOption) (*Empty, error)
	RequestZaloUserToMakeCall(ctx context.Context, in *ZaloUserRequest, opts ...grpc.CallOption) (*Empty, error)
	MakeSureZaloUser(ctx context.Context, in *ZaloUserRequest, opts ...grpc.CallOption) (*Empty, error)
	GetZaloUserCallConsent(ctx context.Context, in *ZaloUserRequest, opts ...grpc.CallOption) (*Response, error)
	SendZNS(ctx context.Context, in *ZnsRequest, opts ...grpc.CallOption) (*Event, error)
	CreateZNSTemplate(ctx context.Context, in *ZNSTemplate, opts ...grpc.CallOption) (*Response, error)
	UpdateZNSTemplate(ctx context.Context, in *ZNSTemplate, opts ...grpc.CallOption) (*Response, error)
	ListZNSTemplates(ctx context.Context, in *ListZNSTemplateRequest, opts ...grpc.CallOption) (*Response, error)
	MatchZNSTemplates(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
	ListZNSMedias(ctx context.Context, in *ListZNSTemplateRequest, opts ...grpc.CallOption) (*Response, error)
	MatchZNSMedias(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
	CreateZNSMedia(ctx context.Context, in *ZNSMedia, opts ...grpc.CallOption) (*Response, error)
	DeleteZNSMedia(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
}

type zalokonServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewZalokonServiceClient(cc grpc.ClientConnInterface) ZalokonServiceClient {
	return &zalokonServiceClient{cc}
}

func (c *zalokonServiceClient) SendEventToZalo(ctx context.Context, in *Events, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ZalokonService_SendEventToZalo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zalokonServiceClient) RequestZaloUserToMakeCall(ctx context.Context, in *ZaloUserRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ZalokonService_RequestZaloUserToMakeCall_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zalokonServiceClient) MakeSureZaloUser(ctx context.Context, in *ZaloUserRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ZalokonService_MakeSureZaloUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zalokonServiceClient) GetZaloUserCallConsent(ctx context.Context, in *ZaloUserRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ZalokonService_GetZaloUserCallConsent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zalokonServiceClient) SendZNS(ctx context.Context, in *ZnsRequest, opts ...grpc.CallOption) (*Event, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Event)
	err := c.cc.Invoke(ctx, ZalokonService_SendZNS_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zalokonServiceClient) CreateZNSTemplate(ctx context.Context, in *ZNSTemplate, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ZalokonService_CreateZNSTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zalokonServiceClient) UpdateZNSTemplate(ctx context.Context, in *ZNSTemplate, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ZalokonService_UpdateZNSTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zalokonServiceClient) ListZNSTemplates(ctx context.Context, in *ListZNSTemplateRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ZalokonService_ListZNSTemplates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zalokonServiceClient) MatchZNSTemplates(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ZalokonService_MatchZNSTemplates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zalokonServiceClient) ListZNSMedias(ctx context.Context, in *ListZNSTemplateRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ZalokonService_ListZNSMedias_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zalokonServiceClient) MatchZNSMedias(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ZalokonService_MatchZNSMedias_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zalokonServiceClient) CreateZNSMedia(ctx context.Context, in *ZNSMedia, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, ZalokonService_CreateZNSMedia_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zalokonServiceClient) DeleteZNSMedia(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ZalokonService_DeleteZNSMedia_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ZalokonServiceServer is the server API for ZalokonService service.
// All implementations must embed UnimplementedZalokonServiceServer
// for forward compatibility.
type ZalokonServiceServer interface {
	SendEventToZalo(context.Context, *Events) (*Empty, error)
	RequestZaloUserToMakeCall(context.Context, *ZaloUserRequest) (*Empty, error)
	MakeSureZaloUser(context.Context, *ZaloUserRequest) (*Empty, error)
	GetZaloUserCallConsent(context.Context, *ZaloUserRequest) (*Response, error)
	SendZNS(context.Context, *ZnsRequest) (*Event, error)
	CreateZNSTemplate(context.Context, *ZNSTemplate) (*Response, error)
	UpdateZNSTemplate(context.Context, *ZNSTemplate) (*Response, error)
	ListZNSTemplates(context.Context, *ListZNSTemplateRequest) (*Response, error)
	MatchZNSTemplates(context.Context, *Ids) (*Response, error)
	ListZNSMedias(context.Context, *ListZNSTemplateRequest) (*Response, error)
	MatchZNSMedias(context.Context, *Ids) (*Response, error)
	CreateZNSMedia(context.Context, *ZNSMedia) (*Response, error)
	DeleteZNSMedia(context.Context, *Id) (*Empty, error)
	mustEmbedUnimplementedZalokonServiceServer()
}

// UnimplementedZalokonServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedZalokonServiceServer struct{}

func (UnimplementedZalokonServiceServer) SendEventToZalo(context.Context, *Events) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendEventToZalo not implemented")
}
func (UnimplementedZalokonServiceServer) RequestZaloUserToMakeCall(context.Context, *ZaloUserRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestZaloUserToMakeCall not implemented")
}
func (UnimplementedZalokonServiceServer) MakeSureZaloUser(context.Context, *ZaloUserRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MakeSureZaloUser not implemented")
}
func (UnimplementedZalokonServiceServer) GetZaloUserCallConsent(context.Context, *ZaloUserRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetZaloUserCallConsent not implemented")
}
func (UnimplementedZalokonServiceServer) SendZNS(context.Context, *ZnsRequest) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendZNS not implemented")
}
func (UnimplementedZalokonServiceServer) CreateZNSTemplate(context.Context, *ZNSTemplate) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateZNSTemplate not implemented")
}
func (UnimplementedZalokonServiceServer) UpdateZNSTemplate(context.Context, *ZNSTemplate) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateZNSTemplate not implemented")
}
func (UnimplementedZalokonServiceServer) ListZNSTemplates(context.Context, *ListZNSTemplateRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListZNSTemplates not implemented")
}
func (UnimplementedZalokonServiceServer) MatchZNSTemplates(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchZNSTemplates not implemented")
}
func (UnimplementedZalokonServiceServer) ListZNSMedias(context.Context, *ListZNSTemplateRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListZNSMedias not implemented")
}
func (UnimplementedZalokonServiceServer) MatchZNSMedias(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchZNSMedias not implemented")
}
func (UnimplementedZalokonServiceServer) CreateZNSMedia(context.Context, *ZNSMedia) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateZNSMedia not implemented")
}
func (UnimplementedZalokonServiceServer) DeleteZNSMedia(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteZNSMedia not implemented")
}
func (UnimplementedZalokonServiceServer) mustEmbedUnimplementedZalokonServiceServer() {}
func (UnimplementedZalokonServiceServer) testEmbeddedByValue()                        {}

// UnsafeZalokonServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ZalokonServiceServer will
// result in compilation errors.
type UnsafeZalokonServiceServer interface {
	mustEmbedUnimplementedZalokonServiceServer()
}

func RegisterZalokonServiceServer(s grpc.ServiceRegistrar, srv ZalokonServiceServer) {
	// If the following call pancis, it indicates UnimplementedZalokonServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ZalokonService_ServiceDesc, srv)
}

func _ZalokonService_SendEventToZalo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Events)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZalokonServiceServer).SendEventToZalo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZalokonService_SendEventToZalo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZalokonServiceServer).SendEventToZalo(ctx, req.(*Events))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZalokonService_RequestZaloUserToMakeCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZaloUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZalokonServiceServer).RequestZaloUserToMakeCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZalokonService_RequestZaloUserToMakeCall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZalokonServiceServer).RequestZaloUserToMakeCall(ctx, req.(*ZaloUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZalokonService_MakeSureZaloUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZaloUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZalokonServiceServer).MakeSureZaloUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZalokonService_MakeSureZaloUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZalokonServiceServer).MakeSureZaloUser(ctx, req.(*ZaloUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZalokonService_GetZaloUserCallConsent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZaloUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZalokonServiceServer).GetZaloUserCallConsent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZalokonService_GetZaloUserCallConsent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZalokonServiceServer).GetZaloUserCallConsent(ctx, req.(*ZaloUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZalokonService_SendZNS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZnsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZalokonServiceServer).SendZNS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZalokonService_SendZNS_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZalokonServiceServer).SendZNS(ctx, req.(*ZnsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZalokonService_CreateZNSTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZNSTemplate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZalokonServiceServer).CreateZNSTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZalokonService_CreateZNSTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZalokonServiceServer).CreateZNSTemplate(ctx, req.(*ZNSTemplate))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZalokonService_UpdateZNSTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZNSTemplate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZalokonServiceServer).UpdateZNSTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZalokonService_UpdateZNSTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZalokonServiceServer).UpdateZNSTemplate(ctx, req.(*ZNSTemplate))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZalokonService_ListZNSTemplates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListZNSTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZalokonServiceServer).ListZNSTemplates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZalokonService_ListZNSTemplates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZalokonServiceServer).ListZNSTemplates(ctx, req.(*ListZNSTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZalokonService_MatchZNSTemplates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZalokonServiceServer).MatchZNSTemplates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZalokonService_MatchZNSTemplates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZalokonServiceServer).MatchZNSTemplates(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZalokonService_ListZNSMedias_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListZNSTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZalokonServiceServer).ListZNSMedias(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZalokonService_ListZNSMedias_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZalokonServiceServer).ListZNSMedias(ctx, req.(*ListZNSTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZalokonService_MatchZNSMedias_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZalokonServiceServer).MatchZNSMedias(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZalokonService_MatchZNSMedias_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZalokonServiceServer).MatchZNSMedias(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZalokonService_CreateZNSMedia_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZNSMedia)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZalokonServiceServer).CreateZNSMedia(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZalokonService_CreateZNSMedia_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZalokonServiceServer).CreateZNSMedia(ctx, req.(*ZNSMedia))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZalokonService_DeleteZNSMedia_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZalokonServiceServer).DeleteZNSMedia(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZalokonService_DeleteZNSMedia_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZalokonServiceServer).DeleteZNSMedia(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

// ZalokonService_ServiceDesc is the grpc.ServiceDesc for ZalokonService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ZalokonService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.ZalokonService",
	HandlerType: (*ZalokonServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendEventToZalo",
			Handler:    _ZalokonService_SendEventToZalo_Handler,
		},
		{
			MethodName: "RequestZaloUserToMakeCall",
			Handler:    _ZalokonService_RequestZaloUserToMakeCall_Handler,
		},
		{
			MethodName: "MakeSureZaloUser",
			Handler:    _ZalokonService_MakeSureZaloUser_Handler,
		},
		{
			MethodName: "GetZaloUserCallConsent",
			Handler:    _ZalokonService_GetZaloUserCallConsent_Handler,
		},
		{
			MethodName: "SendZNS",
			Handler:    _ZalokonService_SendZNS_Handler,
		},
		{
			MethodName: "CreateZNSTemplate",
			Handler:    _ZalokonService_CreateZNSTemplate_Handler,
		},
		{
			MethodName: "UpdateZNSTemplate",
			Handler:    _ZalokonService_UpdateZNSTemplate_Handler,
		},
		{
			MethodName: "ListZNSTemplates",
			Handler:    _ZalokonService_ListZNSTemplates_Handler,
		},
		{
			MethodName: "MatchZNSTemplates",
			Handler:    _ZalokonService_MatchZNSTemplates_Handler,
		},
		{
			MethodName: "ListZNSMedias",
			Handler:    _ZalokonService_ListZNSMedias_Handler,
		},
		{
			MethodName: "MatchZNSMedias",
			Handler:    _ZalokonService_MatchZNSMedias_Handler,
		},
		{
			MethodName: "CreateZNSMedia",
			Handler:    _ZalokonService_CreateZNSMedia_Handler,
		},
		{
			MethodName: "DeleteZNSMedia",
			Handler:    _ZalokonService_DeleteZNSMedia_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	MailkonService_SendEmail_FullMethodName                     = "/header.MailkonService/SendEmail"
	MailkonService_CreateEmailIdentity_FullMethodName           = "/header.MailkonService/CreateEmailIdentity"
	MailkonService_DeleteEmailIdentity_FullMethodName           = "/header.MailkonService/DeleteEmailIdentity"
	MailkonService_ResendSenderVerificationEmail_FullMethodName = "/header.MailkonService/ResendSenderVerificationEmail"
	MailkonService_VerifySenderDomain_FullMethodName            = "/header.MailkonService/VerifySenderDomain"
	MailkonService_ListBusinessEmailAddresses_FullMethodName    = "/header.MailkonService/ListBusinessEmailAddresses"
	MailkonService_UpsertBusinessEmailAddress_FullMethodName    = "/header.MailkonService/UpsertBusinessEmailAddress"
	MailkonService_DeleteBusinessEmailAddress_FullMethodName    = "/header.MailkonService/DeleteBusinessEmailAddress"
	MailkonService_TrackLink_FullMethodName                     = "/header.MailkonService/TrackLink"
	MailkonService_ListBouncedEmails_FullMethodName             = "/header.MailkonService/ListBouncedEmails"
	MailkonService_UpsertBouncedEmail_FullMethodName            = "/header.MailkonService/UpsertBouncedEmail"
	MailkonService_DeleteBouncedEmail_FullMethodName            = "/header.MailkonService/DeleteBouncedEmail"
	MailkonService_ListEmailSignatures_FullMethodName           = "/header.MailkonService/ListEmailSignatures"
	MailkonService_MatchEmailSignatures_FullMethodName          = "/header.MailkonService/MatchEmailSignatures"
	MailkonService_CreateEmailSignature_FullMethodName          = "/header.MailkonService/CreateEmailSignature"
	MailkonService_UpdateEmailSignature_FullMethodName          = "/header.MailkonService/UpdateEmailSignature"
	MailkonService_DeleteEmailSignature_FullMethodName          = "/header.MailkonService/DeleteEmailSignature"
	MailkonService_ListBlockedEmails_FullMethodName             = "/header.MailkonService/ListBlockedEmails"
	MailkonService_BlockEmail_FullMethodName                    = "/header.MailkonService/BlockEmail"
	MailkonService_UnblockEmail_FullMethodName                  = "/header.MailkonService/UnblockEmail"
)

// MailkonServiceClient is the client API for MailkonService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MailkonServiceClient interface {
	SendEmail(ctx context.Context, in *Events, opts ...grpc.CallOption) (*Empty, error)
	CreateEmailIdentity(ctx context.Context, in *Integration, opts ...grpc.CallOption) (*Integration, error)
	DeleteEmailIdentity(ctx context.Context, in *Integration, opts ...grpc.CallOption) (*Empty, error)
	ResendSenderVerificationEmail(ctx context.Context, in *Integration, opts ...grpc.CallOption) (*Empty, error)
	VerifySenderDomain(ctx context.Context, in *Integration, opts ...grpc.CallOption) (*EmailSenderVerificationResult, error)
	ListBusinessEmailAddresses(ctx context.Context, in *Id, opts ...grpc.CallOption) (*BusinessEmailAddresses, error)
	UpsertBusinessEmailAddress(ctx context.Context, in *BusinessEmailAddress, opts ...grpc.CallOption) (*BusinessEmailAddress, error)
	DeleteBusinessEmailAddress(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	TrackLink(ctx context.Context, in *LinkData, opts ...grpc.CallOption) (*Response, error)
	ListBouncedEmails(ctx context.Context, in *BouncedEmail, opts ...grpc.CallOption) (*Response, error)
	UpsertBouncedEmail(ctx context.Context, in *BouncedEmail, opts ...grpc.CallOption) (*BouncedEmail, error)
	DeleteBouncedEmail(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	ListEmailSignatures(ctx context.Context, in *ListEmailSignatureRequest, opts ...grpc.CallOption) (*Response, error)
	MatchEmailSignatures(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
	CreateEmailSignature(ctx context.Context, in *EmailSignature, opts ...grpc.CallOption) (*Response, error)
	UpdateEmailSignature(ctx context.Context, in *EmailSignature, opts ...grpc.CallOption) (*Response, error)
	DeleteEmailSignature(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ListBlockedEmails(ctx context.Context, in *BlockedEmail, opts ...grpc.CallOption) (*Response, error)
	BlockEmail(ctx context.Context, in *BlockedEmail, opts ...grpc.CallOption) (*Response, error)
	UnblockEmail(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
}

type mailkonServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMailkonServiceClient(cc grpc.ClientConnInterface) MailkonServiceClient {
	return &mailkonServiceClient{cc}
}

func (c *mailkonServiceClient) SendEmail(ctx context.Context, in *Events, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, MailkonService_SendEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailkonServiceClient) CreateEmailIdentity(ctx context.Context, in *Integration, opts ...grpc.CallOption) (*Integration, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Integration)
	err := c.cc.Invoke(ctx, MailkonService_CreateEmailIdentity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailkonServiceClient) DeleteEmailIdentity(ctx context.Context, in *Integration, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, MailkonService_DeleteEmailIdentity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailkonServiceClient) ResendSenderVerificationEmail(ctx context.Context, in *Integration, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, MailkonService_ResendSenderVerificationEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailkonServiceClient) VerifySenderDomain(ctx context.Context, in *Integration, opts ...grpc.CallOption) (*EmailSenderVerificationResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmailSenderVerificationResult)
	err := c.cc.Invoke(ctx, MailkonService_VerifySenderDomain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailkonServiceClient) ListBusinessEmailAddresses(ctx context.Context, in *Id, opts ...grpc.CallOption) (*BusinessEmailAddresses, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BusinessEmailAddresses)
	err := c.cc.Invoke(ctx, MailkonService_ListBusinessEmailAddresses_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailkonServiceClient) UpsertBusinessEmailAddress(ctx context.Context, in *BusinessEmailAddress, opts ...grpc.CallOption) (*BusinessEmailAddress, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BusinessEmailAddress)
	err := c.cc.Invoke(ctx, MailkonService_UpsertBusinessEmailAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailkonServiceClient) DeleteBusinessEmailAddress(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, MailkonService_DeleteBusinessEmailAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailkonServiceClient) TrackLink(ctx context.Context, in *LinkData, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, MailkonService_TrackLink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailkonServiceClient) ListBouncedEmails(ctx context.Context, in *BouncedEmail, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, MailkonService_ListBouncedEmails_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailkonServiceClient) UpsertBouncedEmail(ctx context.Context, in *BouncedEmail, opts ...grpc.CallOption) (*BouncedEmail, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BouncedEmail)
	err := c.cc.Invoke(ctx, MailkonService_UpsertBouncedEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailkonServiceClient) DeleteBouncedEmail(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, MailkonService_DeleteBouncedEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailkonServiceClient) ListEmailSignatures(ctx context.Context, in *ListEmailSignatureRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, MailkonService_ListEmailSignatures_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailkonServiceClient) MatchEmailSignatures(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, MailkonService_MatchEmailSignatures_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailkonServiceClient) CreateEmailSignature(ctx context.Context, in *EmailSignature, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, MailkonService_CreateEmailSignature_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailkonServiceClient) UpdateEmailSignature(ctx context.Context, in *EmailSignature, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, MailkonService_UpdateEmailSignature_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailkonServiceClient) DeleteEmailSignature(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, MailkonService_DeleteEmailSignature_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailkonServiceClient) ListBlockedEmails(ctx context.Context, in *BlockedEmail, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, MailkonService_ListBlockedEmails_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailkonServiceClient) BlockEmail(ctx context.Context, in *BlockedEmail, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, MailkonService_BlockEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailkonServiceClient) UnblockEmail(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, MailkonService_UnblockEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MailkonServiceServer is the server API for MailkonService service.
// All implementations must embed UnimplementedMailkonServiceServer
// for forward compatibility.
type MailkonServiceServer interface {
	SendEmail(context.Context, *Events) (*Empty, error)
	CreateEmailIdentity(context.Context, *Integration) (*Integration, error)
	DeleteEmailIdentity(context.Context, *Integration) (*Empty, error)
	ResendSenderVerificationEmail(context.Context, *Integration) (*Empty, error)
	VerifySenderDomain(context.Context, *Integration) (*EmailSenderVerificationResult, error)
	ListBusinessEmailAddresses(context.Context, *Id) (*BusinessEmailAddresses, error)
	UpsertBusinessEmailAddress(context.Context, *BusinessEmailAddress) (*BusinessEmailAddress, error)
	DeleteBusinessEmailAddress(context.Context, *Id) (*Empty, error)
	TrackLink(context.Context, *LinkData) (*Response, error)
	ListBouncedEmails(context.Context, *BouncedEmail) (*Response, error)
	UpsertBouncedEmail(context.Context, *BouncedEmail) (*BouncedEmail, error)
	DeleteBouncedEmail(context.Context, *Id) (*Response, error)
	ListEmailSignatures(context.Context, *ListEmailSignatureRequest) (*Response, error)
	MatchEmailSignatures(context.Context, *Ids) (*Response, error)
	CreateEmailSignature(context.Context, *EmailSignature) (*Response, error)
	UpdateEmailSignature(context.Context, *EmailSignature) (*Response, error)
	DeleteEmailSignature(context.Context, *Id) (*Empty, error)
	ListBlockedEmails(context.Context, *BlockedEmail) (*Response, error)
	BlockEmail(context.Context, *BlockedEmail) (*Response, error)
	UnblockEmail(context.Context, *Id) (*Response, error)
	mustEmbedUnimplementedMailkonServiceServer()
}

// UnimplementedMailkonServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMailkonServiceServer struct{}

func (UnimplementedMailkonServiceServer) SendEmail(context.Context, *Events) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendEmail not implemented")
}
func (UnimplementedMailkonServiceServer) CreateEmailIdentity(context.Context, *Integration) (*Integration, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateEmailIdentity not implemented")
}
func (UnimplementedMailkonServiceServer) DeleteEmailIdentity(context.Context, *Integration) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteEmailIdentity not implemented")
}
func (UnimplementedMailkonServiceServer) ResendSenderVerificationEmail(context.Context, *Integration) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResendSenderVerificationEmail not implemented")
}
func (UnimplementedMailkonServiceServer) VerifySenderDomain(context.Context, *Integration) (*EmailSenderVerificationResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifySenderDomain not implemented")
}
func (UnimplementedMailkonServiceServer) ListBusinessEmailAddresses(context.Context, *Id) (*BusinessEmailAddresses, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBusinessEmailAddresses not implemented")
}
func (UnimplementedMailkonServiceServer) UpsertBusinessEmailAddress(context.Context, *BusinessEmailAddress) (*BusinessEmailAddress, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertBusinessEmailAddress not implemented")
}
func (UnimplementedMailkonServiceServer) DeleteBusinessEmailAddress(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBusinessEmailAddress not implemented")
}
func (UnimplementedMailkonServiceServer) TrackLink(context.Context, *LinkData) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TrackLink not implemented")
}
func (UnimplementedMailkonServiceServer) ListBouncedEmails(context.Context, *BouncedEmail) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBouncedEmails not implemented")
}
func (UnimplementedMailkonServiceServer) UpsertBouncedEmail(context.Context, *BouncedEmail) (*BouncedEmail, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertBouncedEmail not implemented")
}
func (UnimplementedMailkonServiceServer) DeleteBouncedEmail(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBouncedEmail not implemented")
}
func (UnimplementedMailkonServiceServer) ListEmailSignatures(context.Context, *ListEmailSignatureRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListEmailSignatures not implemented")
}
func (UnimplementedMailkonServiceServer) MatchEmailSignatures(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchEmailSignatures not implemented")
}
func (UnimplementedMailkonServiceServer) CreateEmailSignature(context.Context, *EmailSignature) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateEmailSignature not implemented")
}
func (UnimplementedMailkonServiceServer) UpdateEmailSignature(context.Context, *EmailSignature) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateEmailSignature not implemented")
}
func (UnimplementedMailkonServiceServer) DeleteEmailSignature(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteEmailSignature not implemented")
}
func (UnimplementedMailkonServiceServer) ListBlockedEmails(context.Context, *BlockedEmail) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBlockedEmails not implemented")
}
func (UnimplementedMailkonServiceServer) BlockEmail(context.Context, *BlockedEmail) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockEmail not implemented")
}
func (UnimplementedMailkonServiceServer) UnblockEmail(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnblockEmail not implemented")
}
func (UnimplementedMailkonServiceServer) mustEmbedUnimplementedMailkonServiceServer() {}
func (UnimplementedMailkonServiceServer) testEmbeddedByValue()                        {}

// UnsafeMailkonServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MailkonServiceServer will
// result in compilation errors.
type UnsafeMailkonServiceServer interface {
	mustEmbedUnimplementedMailkonServiceServer()
}

func RegisterMailkonServiceServer(s grpc.ServiceRegistrar, srv MailkonServiceServer) {
	// If the following call pancis, it indicates UnimplementedMailkonServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MailkonService_ServiceDesc, srv)
}

func _MailkonService_SendEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Events)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailkonServiceServer).SendEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailkonService_SendEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailkonServiceServer).SendEmail(ctx, req.(*Events))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailkonService_CreateEmailIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Integration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailkonServiceServer).CreateEmailIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailkonService_CreateEmailIdentity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailkonServiceServer).CreateEmailIdentity(ctx, req.(*Integration))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailkonService_DeleteEmailIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Integration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailkonServiceServer).DeleteEmailIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailkonService_DeleteEmailIdentity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailkonServiceServer).DeleteEmailIdentity(ctx, req.(*Integration))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailkonService_ResendSenderVerificationEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Integration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailkonServiceServer).ResendSenderVerificationEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailkonService_ResendSenderVerificationEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailkonServiceServer).ResendSenderVerificationEmail(ctx, req.(*Integration))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailkonService_VerifySenderDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Integration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailkonServiceServer).VerifySenderDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailkonService_VerifySenderDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailkonServiceServer).VerifySenderDomain(ctx, req.(*Integration))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailkonService_ListBusinessEmailAddresses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailkonServiceServer).ListBusinessEmailAddresses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailkonService_ListBusinessEmailAddresses_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailkonServiceServer).ListBusinessEmailAddresses(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailkonService_UpsertBusinessEmailAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BusinessEmailAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailkonServiceServer).UpsertBusinessEmailAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailkonService_UpsertBusinessEmailAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailkonServiceServer).UpsertBusinessEmailAddress(ctx, req.(*BusinessEmailAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailkonService_DeleteBusinessEmailAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailkonServiceServer).DeleteBusinessEmailAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailkonService_DeleteBusinessEmailAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailkonServiceServer).DeleteBusinessEmailAddress(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailkonService_TrackLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LinkData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailkonServiceServer).TrackLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailkonService_TrackLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailkonServiceServer).TrackLink(ctx, req.(*LinkData))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailkonService_ListBouncedEmails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BouncedEmail)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailkonServiceServer).ListBouncedEmails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailkonService_ListBouncedEmails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailkonServiceServer).ListBouncedEmails(ctx, req.(*BouncedEmail))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailkonService_UpsertBouncedEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BouncedEmail)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailkonServiceServer).UpsertBouncedEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailkonService_UpsertBouncedEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailkonServiceServer).UpsertBouncedEmail(ctx, req.(*BouncedEmail))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailkonService_DeleteBouncedEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailkonServiceServer).DeleteBouncedEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailkonService_DeleteBouncedEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailkonServiceServer).DeleteBouncedEmail(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailkonService_ListEmailSignatures_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListEmailSignatureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailkonServiceServer).ListEmailSignatures(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailkonService_ListEmailSignatures_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailkonServiceServer).ListEmailSignatures(ctx, req.(*ListEmailSignatureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailkonService_MatchEmailSignatures_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailkonServiceServer).MatchEmailSignatures(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailkonService_MatchEmailSignatures_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailkonServiceServer).MatchEmailSignatures(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailkonService_CreateEmailSignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmailSignature)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailkonServiceServer).CreateEmailSignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailkonService_CreateEmailSignature_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailkonServiceServer).CreateEmailSignature(ctx, req.(*EmailSignature))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailkonService_UpdateEmailSignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmailSignature)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailkonServiceServer).UpdateEmailSignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailkonService_UpdateEmailSignature_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailkonServiceServer).UpdateEmailSignature(ctx, req.(*EmailSignature))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailkonService_DeleteEmailSignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailkonServiceServer).DeleteEmailSignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailkonService_DeleteEmailSignature_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailkonServiceServer).DeleteEmailSignature(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailkonService_ListBlockedEmails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockedEmail)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailkonServiceServer).ListBlockedEmails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailkonService_ListBlockedEmails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailkonServiceServer).ListBlockedEmails(ctx, req.(*BlockedEmail))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailkonService_BlockEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockedEmail)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailkonServiceServer).BlockEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailkonService_BlockEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailkonServiceServer).BlockEmail(ctx, req.(*BlockedEmail))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailkonService_UnblockEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailkonServiceServer).UnblockEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailkonService_UnblockEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailkonServiceServer).UnblockEmail(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

// MailkonService_ServiceDesc is the grpc.ServiceDesc for MailkonService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MailkonService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.MailkonService",
	HandlerType: (*MailkonServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendEmail",
			Handler:    _MailkonService_SendEmail_Handler,
		},
		{
			MethodName: "CreateEmailIdentity",
			Handler:    _MailkonService_CreateEmailIdentity_Handler,
		},
		{
			MethodName: "DeleteEmailIdentity",
			Handler:    _MailkonService_DeleteEmailIdentity_Handler,
		},
		{
			MethodName: "ResendSenderVerificationEmail",
			Handler:    _MailkonService_ResendSenderVerificationEmail_Handler,
		},
		{
			MethodName: "VerifySenderDomain",
			Handler:    _MailkonService_VerifySenderDomain_Handler,
		},
		{
			MethodName: "ListBusinessEmailAddresses",
			Handler:    _MailkonService_ListBusinessEmailAddresses_Handler,
		},
		{
			MethodName: "UpsertBusinessEmailAddress",
			Handler:    _MailkonService_UpsertBusinessEmailAddress_Handler,
		},
		{
			MethodName: "DeleteBusinessEmailAddress",
			Handler:    _MailkonService_DeleteBusinessEmailAddress_Handler,
		},
		{
			MethodName: "TrackLink",
			Handler:    _MailkonService_TrackLink_Handler,
		},
		{
			MethodName: "ListBouncedEmails",
			Handler:    _MailkonService_ListBouncedEmails_Handler,
		},
		{
			MethodName: "UpsertBouncedEmail",
			Handler:    _MailkonService_UpsertBouncedEmail_Handler,
		},
		{
			MethodName: "DeleteBouncedEmail",
			Handler:    _MailkonService_DeleteBouncedEmail_Handler,
		},
		{
			MethodName: "ListEmailSignatures",
			Handler:    _MailkonService_ListEmailSignatures_Handler,
		},
		{
			MethodName: "MatchEmailSignatures",
			Handler:    _MailkonService_MatchEmailSignatures_Handler,
		},
		{
			MethodName: "CreateEmailSignature",
			Handler:    _MailkonService_CreateEmailSignature_Handler,
		},
		{
			MethodName: "UpdateEmailSignature",
			Handler:    _MailkonService_UpdateEmailSignature_Handler,
		},
		{
			MethodName: "DeleteEmailSignature",
			Handler:    _MailkonService_DeleteEmailSignature_Handler,
		},
		{
			MethodName: "ListBlockedEmails",
			Handler:    _MailkonService_ListBlockedEmails_Handler,
		},
		{
			MethodName: "BlockEmail",
			Handler:    _MailkonService_BlockEmail_Handler,
		},
		{
			MethodName: "UnblockEmail",
			Handler:    _MailkonService_UnblockEmail_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	WidgetService_Read_FullMethodName                     = "/header.WidgetService/Read"
	WidgetService_Update_FullMethodName                   = "/header.WidgetService/Update"
	WidgetService_ReadUserSetting_FullMethodName          = "/header.WidgetService/ReadUserSetting"
	WidgetService_ReadAccountSetting_FullMethodName       = "/header.WidgetService/ReadAccountSetting"
	WidgetService_ReadAccountSetting2_FullMethodName      = "/header.WidgetService/ReadAccountSetting2"
	WidgetService_SubmitImpression_FullMethodName         = "/header.WidgetService/SubmitImpression"
	WidgetService_SubmitConversion_FullMethodName         = "/header.WidgetService/SubmitConversion"
	WidgetService_SubmitUserCampaignStatus_FullMethodName = "/header.WidgetService/SubmitUserCampaignStatus"
	WidgetService_ReportCampaign_FullMethodName           = "/header.WidgetService/ReportCampaign"
	WidgetService_ListConversions_FullMethodName          = "/header.WidgetService/ListConversions"
	WidgetService_ExportConversions_FullMethodName        = "/header.WidgetService/ExportConversions"
	WidgetService_UploadImage_FullMethodName              = "/header.WidgetService/UploadImage"
	WidgetService_ListUploadedImage_FullMethodName        = "/header.WidgetService/ListUploadedImage"
	WidgetService_DeleteUploadedImage_FullMethodName      = "/header.WidgetService/DeleteUploadedImage"
	WidgetService_ListWebPlugins_FullMethodName           = "/header.WidgetService/ListWebPlugins"
	WidgetService_UpdateWebPlugin_FullMethodName          = "/header.WidgetService/UpdateWebPlugin"
	WidgetService_UpdateWebPluginEnabled_FullMethodName   = "/header.WidgetService/UpdateWebPluginEnabled"
	WidgetService_CreateWebPlugin_FullMethodName          = "/header.WidgetService/CreateWebPlugin"
	WidgetService_DeleteWebPlugin_FullMethodName          = "/header.WidgetService/DeleteWebPlugin"
	WidgetService_UpdateWebPluginTemplate_FullMethodName  = "/header.WidgetService/UpdateWebPluginTemplate"
	WidgetService_ListWebPluginTemplates_FullMethodName   = "/header.WidgetService/ListWebPluginTemplates"
	WidgetService_DeleteWebPluginTemplate_FullMethodName  = "/header.WidgetService/DeleteWebPluginTemplate"
	WidgetService_ReportWebPlugin_FullMethodName          = "/header.WidgetService/ReportWebPlugin"
	WidgetService_SearchImages_FullMethodName             = "/header.WidgetService/SearchImages"
	WidgetService_ListNotifProfiles_FullMethodName        = "/header.WidgetService/ListNotifProfiles"
	WidgetService_ListNotifBackgrounds_FullMethodName     = "/header.WidgetService/ListNotifBackgrounds"
	WidgetService_ListSites_FullMethodName                = "/header.WidgetService/ListSites"
	WidgetService_DeleteSite_FullMethodName               = "/header.WidgetService/DeleteSite"
	WidgetService_CreateSite_FullMethodName               = "/header.WidgetService/CreateSite"
	WidgetService_VerifySite_FullMethodName               = "/header.WidgetService/VerifySite"
)

// WidgetServiceClient is the client API for WidgetService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// widget services
type WidgetServiceClient interface {
	Read(ctx context.Context, in *Id, opts ...grpc.CallOption) (*WidgetSetting, error)
	Update(ctx context.Context, in *WidgetSetting, opts ...grpc.CallOption) (*WidgetSetting, error)
	ReadUserSetting(ctx context.Context, in *Id, opts ...grpc.CallOption) (*WidgetUserSetting, error)
	ReadAccountSetting(ctx context.Context, in *Id, opts ...grpc.CallOption) (*AccountWeb, error)
	ReadAccountSetting2(ctx context.Context, in *WidgetSettingRequest, opts ...grpc.CallOption) (*AccountWeb, error)
	SubmitImpression(ctx context.Context, in *Impression, opts ...grpc.CallOption) (*Impression, error)
	SubmitConversion(ctx context.Context, in *Conversion, opts ...grpc.CallOption) (*Conversion, error)
	SubmitUserCampaignStatus(ctx context.Context, in *UserCampaignStatus, opts ...grpc.CallOption) (*UserCampaignStatus, error)
	ReportCampaign(ctx context.Context, in *ReportCampaignRequest, opts ...grpc.CallOption) (*ReportCampaignResponse, error)
	ListConversions(ctx context.Context, in *ConversionRequest, opts ...grpc.CallOption) (*Conversions, error)
	ExportConversions(ctx context.Context, in *ConversionRequest, opts ...grpc.CallOption) (*ConversionsExported, error)
	UploadImage(ctx context.Context, in *UploadedImage, opts ...grpc.CallOption) (*UploadedImage, error)
	ListUploadedImage(ctx context.Context, in *Id, opts ...grpc.CallOption) (*UploadedImages, error)
	DeleteUploadedImage(ctx context.Context, in *UploadedImage, opts ...grpc.CallOption) (*Empty, error)
	ListWebPlugins(ctx context.Context, in *Id, opts ...grpc.CallOption) (*WebPlugins, error)
	UpdateWebPlugin(ctx context.Context, in *WebPlugin, opts ...grpc.CallOption) (*WebPlugin, error)
	UpdateWebPluginEnabled(ctx context.Context, in *WebPlugin, opts ...grpc.CallOption) (*WebPlugin, error)
	CreateWebPlugin(ctx context.Context, in *WebPlugin, opts ...grpc.CallOption) (*WebPlugin, error)
	DeleteWebPlugin(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	UpdateWebPluginTemplate(ctx context.Context, in *WebPlugin, opts ...grpc.CallOption) (*WebPlugin, error)
	ListWebPluginTemplates(ctx context.Context, in *Id, opts ...grpc.CallOption) (*WebPlugins, error)
	DeleteWebPluginTemplate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ReportWebPlugin(ctx context.Context, in *ReportWebPluginRequest, opts ...grpc.CallOption) (*ReportWebPluginResponse, error)
	SearchImages(ctx context.Context, in *Id, opts ...grpc.CallOption) (*UploadedImages, error)
	ListNotifProfiles(ctx context.Context, in *Id, opts ...grpc.CallOption) (*NotifProfiles, error)
	ListNotifBackgrounds(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Urls, error)
	ListSites(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	DeleteSite(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	CreateSite(ctx context.Context, in *Site, opts ...grpc.CallOption) (*Response, error)
	VerifySite(ctx context.Context, in *Site, opts ...grpc.CallOption) (*Response, error)
}

type widgetServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWidgetServiceClient(cc grpc.ClientConnInterface) WidgetServiceClient {
	return &widgetServiceClient{cc}
}

func (c *widgetServiceClient) Read(ctx context.Context, in *Id, opts ...grpc.CallOption) (*WidgetSetting, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WidgetSetting)
	err := c.cc.Invoke(ctx, WidgetService_Read_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) Update(ctx context.Context, in *WidgetSetting, opts ...grpc.CallOption) (*WidgetSetting, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WidgetSetting)
	err := c.cc.Invoke(ctx, WidgetService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) ReadUserSetting(ctx context.Context, in *Id, opts ...grpc.CallOption) (*WidgetUserSetting, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WidgetUserSetting)
	err := c.cc.Invoke(ctx, WidgetService_ReadUserSetting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) ReadAccountSetting(ctx context.Context, in *Id, opts ...grpc.CallOption) (*AccountWeb, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AccountWeb)
	err := c.cc.Invoke(ctx, WidgetService_ReadAccountSetting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) ReadAccountSetting2(ctx context.Context, in *WidgetSettingRequest, opts ...grpc.CallOption) (*AccountWeb, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AccountWeb)
	err := c.cc.Invoke(ctx, WidgetService_ReadAccountSetting2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) SubmitImpression(ctx context.Context, in *Impression, opts ...grpc.CallOption) (*Impression, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Impression)
	err := c.cc.Invoke(ctx, WidgetService_SubmitImpression_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) SubmitConversion(ctx context.Context, in *Conversion, opts ...grpc.CallOption) (*Conversion, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Conversion)
	err := c.cc.Invoke(ctx, WidgetService_SubmitConversion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) SubmitUserCampaignStatus(ctx context.Context, in *UserCampaignStatus, opts ...grpc.CallOption) (*UserCampaignStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserCampaignStatus)
	err := c.cc.Invoke(ctx, WidgetService_SubmitUserCampaignStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) ReportCampaign(ctx context.Context, in *ReportCampaignRequest, opts ...grpc.CallOption) (*ReportCampaignResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportCampaignResponse)
	err := c.cc.Invoke(ctx, WidgetService_ReportCampaign_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) ListConversions(ctx context.Context, in *ConversionRequest, opts ...grpc.CallOption) (*Conversions, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Conversions)
	err := c.cc.Invoke(ctx, WidgetService_ListConversions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) ExportConversions(ctx context.Context, in *ConversionRequest, opts ...grpc.CallOption) (*ConversionsExported, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConversionsExported)
	err := c.cc.Invoke(ctx, WidgetService_ExportConversions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) UploadImage(ctx context.Context, in *UploadedImage, opts ...grpc.CallOption) (*UploadedImage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadedImage)
	err := c.cc.Invoke(ctx, WidgetService_UploadImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) ListUploadedImage(ctx context.Context, in *Id, opts ...grpc.CallOption) (*UploadedImages, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadedImages)
	err := c.cc.Invoke(ctx, WidgetService_ListUploadedImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) DeleteUploadedImage(ctx context.Context, in *UploadedImage, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, WidgetService_DeleteUploadedImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) ListWebPlugins(ctx context.Context, in *Id, opts ...grpc.CallOption) (*WebPlugins, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WebPlugins)
	err := c.cc.Invoke(ctx, WidgetService_ListWebPlugins_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) UpdateWebPlugin(ctx context.Context, in *WebPlugin, opts ...grpc.CallOption) (*WebPlugin, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WebPlugin)
	err := c.cc.Invoke(ctx, WidgetService_UpdateWebPlugin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) UpdateWebPluginEnabled(ctx context.Context, in *WebPlugin, opts ...grpc.CallOption) (*WebPlugin, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WebPlugin)
	err := c.cc.Invoke(ctx, WidgetService_UpdateWebPluginEnabled_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) CreateWebPlugin(ctx context.Context, in *WebPlugin, opts ...grpc.CallOption) (*WebPlugin, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WebPlugin)
	err := c.cc.Invoke(ctx, WidgetService_CreateWebPlugin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) DeleteWebPlugin(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, WidgetService_DeleteWebPlugin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) UpdateWebPluginTemplate(ctx context.Context, in *WebPlugin, opts ...grpc.CallOption) (*WebPlugin, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WebPlugin)
	err := c.cc.Invoke(ctx, WidgetService_UpdateWebPluginTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) ListWebPluginTemplates(ctx context.Context, in *Id, opts ...grpc.CallOption) (*WebPlugins, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WebPlugins)
	err := c.cc.Invoke(ctx, WidgetService_ListWebPluginTemplates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) DeleteWebPluginTemplate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, WidgetService_DeleteWebPluginTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) ReportWebPlugin(ctx context.Context, in *ReportWebPluginRequest, opts ...grpc.CallOption) (*ReportWebPluginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportWebPluginResponse)
	err := c.cc.Invoke(ctx, WidgetService_ReportWebPlugin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) SearchImages(ctx context.Context, in *Id, opts ...grpc.CallOption) (*UploadedImages, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadedImages)
	err := c.cc.Invoke(ctx, WidgetService_SearchImages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) ListNotifProfiles(ctx context.Context, in *Id, opts ...grpc.CallOption) (*NotifProfiles, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NotifProfiles)
	err := c.cc.Invoke(ctx, WidgetService_ListNotifProfiles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) ListNotifBackgrounds(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Urls, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Urls)
	err := c.cc.Invoke(ctx, WidgetService_ListNotifBackgrounds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) ListSites(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WidgetService_ListSites_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) DeleteSite(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, WidgetService_DeleteSite_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) CreateSite(ctx context.Context, in *Site, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WidgetService_CreateSite_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) VerifySite(ctx context.Context, in *Site, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, WidgetService_VerifySite_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WidgetServiceServer is the server API for WidgetService service.
// All implementations must embed UnimplementedWidgetServiceServer
// for forward compatibility.
//
// widget services
type WidgetServiceServer interface {
	Read(context.Context, *Id) (*WidgetSetting, error)
	Update(context.Context, *WidgetSetting) (*WidgetSetting, error)
	ReadUserSetting(context.Context, *Id) (*WidgetUserSetting, error)
	ReadAccountSetting(context.Context, *Id) (*AccountWeb, error)
	ReadAccountSetting2(context.Context, *WidgetSettingRequest) (*AccountWeb, error)
	SubmitImpression(context.Context, *Impression) (*Impression, error)
	SubmitConversion(context.Context, *Conversion) (*Conversion, error)
	SubmitUserCampaignStatus(context.Context, *UserCampaignStatus) (*UserCampaignStatus, error)
	ReportCampaign(context.Context, *ReportCampaignRequest) (*ReportCampaignResponse, error)
	ListConversions(context.Context, *ConversionRequest) (*Conversions, error)
	ExportConversions(context.Context, *ConversionRequest) (*ConversionsExported, error)
	UploadImage(context.Context, *UploadedImage) (*UploadedImage, error)
	ListUploadedImage(context.Context, *Id) (*UploadedImages, error)
	DeleteUploadedImage(context.Context, *UploadedImage) (*Empty, error)
	ListWebPlugins(context.Context, *Id) (*WebPlugins, error)
	UpdateWebPlugin(context.Context, *WebPlugin) (*WebPlugin, error)
	UpdateWebPluginEnabled(context.Context, *WebPlugin) (*WebPlugin, error)
	CreateWebPlugin(context.Context, *WebPlugin) (*WebPlugin, error)
	DeleteWebPlugin(context.Context, *Id) (*Empty, error)
	UpdateWebPluginTemplate(context.Context, *WebPlugin) (*WebPlugin, error)
	ListWebPluginTemplates(context.Context, *Id) (*WebPlugins, error)
	DeleteWebPluginTemplate(context.Context, *Id) (*Empty, error)
	ReportWebPlugin(context.Context, *ReportWebPluginRequest) (*ReportWebPluginResponse, error)
	SearchImages(context.Context, *Id) (*UploadedImages, error)
	ListNotifProfiles(context.Context, *Id) (*NotifProfiles, error)
	ListNotifBackgrounds(context.Context, *Id) (*Urls, error)
	ListSites(context.Context, *Id) (*Response, error)
	DeleteSite(context.Context, *Id) (*Empty, error)
	CreateSite(context.Context, *Site) (*Response, error)
	VerifySite(context.Context, *Site) (*Response, error)
	mustEmbedUnimplementedWidgetServiceServer()
}

// UnimplementedWidgetServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedWidgetServiceServer struct{}

func (UnimplementedWidgetServiceServer) Read(context.Context, *Id) (*WidgetSetting, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (UnimplementedWidgetServiceServer) Update(context.Context, *WidgetSetting) (*WidgetSetting, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedWidgetServiceServer) ReadUserSetting(context.Context, *Id) (*WidgetUserSetting, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadUserSetting not implemented")
}
func (UnimplementedWidgetServiceServer) ReadAccountSetting(context.Context, *Id) (*AccountWeb, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadAccountSetting not implemented")
}
func (UnimplementedWidgetServiceServer) ReadAccountSetting2(context.Context, *WidgetSettingRequest) (*AccountWeb, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadAccountSetting2 not implemented")
}
func (UnimplementedWidgetServiceServer) SubmitImpression(context.Context, *Impression) (*Impression, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitImpression not implemented")
}
func (UnimplementedWidgetServiceServer) SubmitConversion(context.Context, *Conversion) (*Conversion, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitConversion not implemented")
}
func (UnimplementedWidgetServiceServer) SubmitUserCampaignStatus(context.Context, *UserCampaignStatus) (*UserCampaignStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitUserCampaignStatus not implemented")
}
func (UnimplementedWidgetServiceServer) ReportCampaign(context.Context, *ReportCampaignRequest) (*ReportCampaignResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportCampaign not implemented")
}
func (UnimplementedWidgetServiceServer) ListConversions(context.Context, *ConversionRequest) (*Conversions, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListConversions not implemented")
}
func (UnimplementedWidgetServiceServer) ExportConversions(context.Context, *ConversionRequest) (*ConversionsExported, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportConversions not implemented")
}
func (UnimplementedWidgetServiceServer) UploadImage(context.Context, *UploadedImage) (*UploadedImage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadImage not implemented")
}
func (UnimplementedWidgetServiceServer) ListUploadedImage(context.Context, *Id) (*UploadedImages, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUploadedImage not implemented")
}
func (UnimplementedWidgetServiceServer) DeleteUploadedImage(context.Context, *UploadedImage) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUploadedImage not implemented")
}
func (UnimplementedWidgetServiceServer) ListWebPlugins(context.Context, *Id) (*WebPlugins, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWebPlugins not implemented")
}
func (UnimplementedWidgetServiceServer) UpdateWebPlugin(context.Context, *WebPlugin) (*WebPlugin, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWebPlugin not implemented")
}
func (UnimplementedWidgetServiceServer) UpdateWebPluginEnabled(context.Context, *WebPlugin) (*WebPlugin, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWebPluginEnabled not implemented")
}
func (UnimplementedWidgetServiceServer) CreateWebPlugin(context.Context, *WebPlugin) (*WebPlugin, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateWebPlugin not implemented")
}
func (UnimplementedWidgetServiceServer) DeleteWebPlugin(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWebPlugin not implemented")
}
func (UnimplementedWidgetServiceServer) UpdateWebPluginTemplate(context.Context, *WebPlugin) (*WebPlugin, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWebPluginTemplate not implemented")
}
func (UnimplementedWidgetServiceServer) ListWebPluginTemplates(context.Context, *Id) (*WebPlugins, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWebPluginTemplates not implemented")
}
func (UnimplementedWidgetServiceServer) DeleteWebPluginTemplate(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWebPluginTemplate not implemented")
}
func (UnimplementedWidgetServiceServer) ReportWebPlugin(context.Context, *ReportWebPluginRequest) (*ReportWebPluginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportWebPlugin not implemented")
}
func (UnimplementedWidgetServiceServer) SearchImages(context.Context, *Id) (*UploadedImages, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchImages not implemented")
}
func (UnimplementedWidgetServiceServer) ListNotifProfiles(context.Context, *Id) (*NotifProfiles, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNotifProfiles not implemented")
}
func (UnimplementedWidgetServiceServer) ListNotifBackgrounds(context.Context, *Id) (*Urls, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNotifBackgrounds not implemented")
}
func (UnimplementedWidgetServiceServer) ListSites(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSites not implemented")
}
func (UnimplementedWidgetServiceServer) DeleteSite(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSite not implemented")
}
func (UnimplementedWidgetServiceServer) CreateSite(context.Context, *Site) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSite not implemented")
}
func (UnimplementedWidgetServiceServer) VerifySite(context.Context, *Site) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifySite not implemented")
}
func (UnimplementedWidgetServiceServer) mustEmbedUnimplementedWidgetServiceServer() {}
func (UnimplementedWidgetServiceServer) testEmbeddedByValue()                       {}

// UnsafeWidgetServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WidgetServiceServer will
// result in compilation errors.
type UnsafeWidgetServiceServer interface {
	mustEmbedUnimplementedWidgetServiceServer()
}

func RegisterWidgetServiceServer(s grpc.ServiceRegistrar, srv WidgetServiceServer) {
	// If the following call pancis, it indicates UnimplementedWidgetServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&WidgetService_ServiceDesc, srv)
}

func _WidgetService_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_Read_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).Read(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WidgetSetting)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).Update(ctx, req.(*WidgetSetting))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_ReadUserSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).ReadUserSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_ReadUserSetting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).ReadUserSetting(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_ReadAccountSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).ReadAccountSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_ReadAccountSetting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).ReadAccountSetting(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_ReadAccountSetting2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WidgetSettingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).ReadAccountSetting2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_ReadAccountSetting2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).ReadAccountSetting2(ctx, req.(*WidgetSettingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_SubmitImpression_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Impression)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).SubmitImpression(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_SubmitImpression_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).SubmitImpression(ctx, req.(*Impression))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_SubmitConversion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Conversion)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).SubmitConversion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_SubmitConversion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).SubmitConversion(ctx, req.(*Conversion))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_SubmitUserCampaignStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCampaignStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).SubmitUserCampaignStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_SubmitUserCampaignStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).SubmitUserCampaignStatus(ctx, req.(*UserCampaignStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_ReportCampaign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportCampaignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).ReportCampaign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_ReportCampaign_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).ReportCampaign(ctx, req.(*ReportCampaignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_ListConversions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConversionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).ListConversions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_ListConversions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).ListConversions(ctx, req.(*ConversionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_ExportConversions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConversionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).ExportConversions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_ExportConversions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).ExportConversions(ctx, req.(*ConversionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_UploadImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadedImage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).UploadImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_UploadImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).UploadImage(ctx, req.(*UploadedImage))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_ListUploadedImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).ListUploadedImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_ListUploadedImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).ListUploadedImage(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_DeleteUploadedImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadedImage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).DeleteUploadedImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_DeleteUploadedImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).DeleteUploadedImage(ctx, req.(*UploadedImage))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_ListWebPlugins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).ListWebPlugins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_ListWebPlugins_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).ListWebPlugins(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_UpdateWebPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WebPlugin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).UpdateWebPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_UpdateWebPlugin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).UpdateWebPlugin(ctx, req.(*WebPlugin))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_UpdateWebPluginEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WebPlugin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).UpdateWebPluginEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_UpdateWebPluginEnabled_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).UpdateWebPluginEnabled(ctx, req.(*WebPlugin))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_CreateWebPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WebPlugin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).CreateWebPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_CreateWebPlugin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).CreateWebPlugin(ctx, req.(*WebPlugin))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_DeleteWebPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).DeleteWebPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_DeleteWebPlugin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).DeleteWebPlugin(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_UpdateWebPluginTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WebPlugin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).UpdateWebPluginTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_UpdateWebPluginTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).UpdateWebPluginTemplate(ctx, req.(*WebPlugin))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_ListWebPluginTemplates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).ListWebPluginTemplates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_ListWebPluginTemplates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).ListWebPluginTemplates(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_DeleteWebPluginTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).DeleteWebPluginTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_DeleteWebPluginTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).DeleteWebPluginTemplate(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_ReportWebPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportWebPluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).ReportWebPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_ReportWebPlugin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).ReportWebPlugin(ctx, req.(*ReportWebPluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_SearchImages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).SearchImages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_SearchImages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).SearchImages(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_ListNotifProfiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).ListNotifProfiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_ListNotifProfiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).ListNotifProfiles(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_ListNotifBackgrounds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).ListNotifBackgrounds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_ListNotifBackgrounds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).ListNotifBackgrounds(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_ListSites_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).ListSites(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_ListSites_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).ListSites(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_DeleteSite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).DeleteSite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_DeleteSite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).DeleteSite(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_CreateSite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Site)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).CreateSite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_CreateSite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).CreateSite(ctx, req.(*Site))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_VerifySite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Site)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).VerifySite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WidgetService_VerifySite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).VerifySite(ctx, req.(*Site))
	}
	return interceptor(ctx, in, info, handler)
}

// WidgetService_ServiceDesc is the grpc.ServiceDesc for WidgetService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WidgetService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.WidgetService",
	HandlerType: (*WidgetServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Read",
			Handler:    _WidgetService_Read_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _WidgetService_Update_Handler,
		},
		{
			MethodName: "ReadUserSetting",
			Handler:    _WidgetService_ReadUserSetting_Handler,
		},
		{
			MethodName: "ReadAccountSetting",
			Handler:    _WidgetService_ReadAccountSetting_Handler,
		},
		{
			MethodName: "ReadAccountSetting2",
			Handler:    _WidgetService_ReadAccountSetting2_Handler,
		},
		{
			MethodName: "SubmitImpression",
			Handler:    _WidgetService_SubmitImpression_Handler,
		},
		{
			MethodName: "SubmitConversion",
			Handler:    _WidgetService_SubmitConversion_Handler,
		},
		{
			MethodName: "SubmitUserCampaignStatus",
			Handler:    _WidgetService_SubmitUserCampaignStatus_Handler,
		},
		{
			MethodName: "ReportCampaign",
			Handler:    _WidgetService_ReportCampaign_Handler,
		},
		{
			MethodName: "ListConversions",
			Handler:    _WidgetService_ListConversions_Handler,
		},
		{
			MethodName: "ExportConversions",
			Handler:    _WidgetService_ExportConversions_Handler,
		},
		{
			MethodName: "UploadImage",
			Handler:    _WidgetService_UploadImage_Handler,
		},
		{
			MethodName: "ListUploadedImage",
			Handler:    _WidgetService_ListUploadedImage_Handler,
		},
		{
			MethodName: "DeleteUploadedImage",
			Handler:    _WidgetService_DeleteUploadedImage_Handler,
		},
		{
			MethodName: "ListWebPlugins",
			Handler:    _WidgetService_ListWebPlugins_Handler,
		},
		{
			MethodName: "UpdateWebPlugin",
			Handler:    _WidgetService_UpdateWebPlugin_Handler,
		},
		{
			MethodName: "UpdateWebPluginEnabled",
			Handler:    _WidgetService_UpdateWebPluginEnabled_Handler,
		},
		{
			MethodName: "CreateWebPlugin",
			Handler:    _WidgetService_CreateWebPlugin_Handler,
		},
		{
			MethodName: "DeleteWebPlugin",
			Handler:    _WidgetService_DeleteWebPlugin_Handler,
		},
		{
			MethodName: "UpdateWebPluginTemplate",
			Handler:    _WidgetService_UpdateWebPluginTemplate_Handler,
		},
		{
			MethodName: "ListWebPluginTemplates",
			Handler:    _WidgetService_ListWebPluginTemplates_Handler,
		},
		{
			MethodName: "DeleteWebPluginTemplate",
			Handler:    _WidgetService_DeleteWebPluginTemplate_Handler,
		},
		{
			MethodName: "ReportWebPlugin",
			Handler:    _WidgetService_ReportWebPlugin_Handler,
		},
		{
			MethodName: "SearchImages",
			Handler:    _WidgetService_SearchImages_Handler,
		},
		{
			MethodName: "ListNotifProfiles",
			Handler:    _WidgetService_ListNotifProfiles_Handler,
		},
		{
			MethodName: "ListNotifBackgrounds",
			Handler:    _WidgetService_ListNotifBackgrounds_Handler,
		},
		{
			MethodName: "ListSites",
			Handler:    _WidgetService_ListSites_Handler,
		},
		{
			MethodName: "DeleteSite",
			Handler:    _WidgetService_DeleteSite_Handler,
		},
		{
			MethodName: "CreateSite",
			Handler:    _WidgetService_CreateSite_Handler,
		},
		{
			MethodName: "VerifySite",
			Handler:    _WidgetService_VerifySite_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	Bizbot_ListBots_FullMethodName          = "/header.Bizbot/ListBots"
	Bizbot_GetBot_FullMethodName            = "/header.Bizbot/GetBot"
	Bizbot_UpdateBotRunState_FullMethodName = "/header.Bizbot/UpdateBotRunState"
	Bizbot_CreateBot_FullMethodName         = "/header.Bizbot/CreateBot"
	Bizbot_UpdateBot_FullMethodName         = "/header.Bizbot/UpdateBot"
	Bizbot_DeleteBot_FullMethodName         = "/header.Bizbot/DeleteBot"
	Bizbot_OnEvent_FullMethodName           = "/header.Bizbot/OnEvent"
	Bizbot_StartBot_FullMethodName          = "/header.Bizbot/StartBot"
	Bizbot_StopBot_FullMethodName           = "/header.Bizbot/StopBot"
	Bizbot_TryAction_FullMethodName         = "/header.Bizbot/TryAction"
	Bizbot_ReportBot2_FullMethodName        = "/header.Bizbot/ReportBot2"
	Bizbot_ReportAction_FullMethodName      = "/header.Bizbot/ReportAction"
	Bizbot_ListObjects_FullMethodName       = "/header.Bizbot/ListObjects"
	Bizbot_ReportBot_FullMethodName         = "/header.Bizbot/ReportBot"
)

// BizbotClient is the client API for Bizbot service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// bizbot services
type BizbotClient interface {
	ListBots(ctx context.Context, in *BotsRequest, opts ...grpc.CallOption) (*Bots, error)
	GetBot(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Bot, error)
	UpdateBotRunState(ctx context.Context, in *Bot, opts ...grpc.CallOption) (*Bot, error)
	CreateBot(ctx context.Context, in *Bot, opts ...grpc.CallOption) (*Bot, error)
	UpdateBot(ctx context.Context, in *Bot, opts ...grpc.CallOption) (*Bot, error)
	DeleteBot(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	OnEvent(ctx context.Context, in *BotRunRequest, opts ...grpc.CallOption) (*Empty, error)
	StartBot(ctx context.Context, in *BotRunRequest, opts ...grpc.CallOption) (*Empty, error)
	StopBot(ctx context.Context, in *BotRunRequest, opts ...grpc.CallOption) (*Empty, error)
	TryAction(ctx context.Context, in *BotRunRequest, opts ...grpc.CallOption) (*Empty, error)
	ReportBot2(ctx context.Context, in *BotrunMetricsRequest, opts ...grpc.CallOption) (*BotrunMetrics, error)
	ReportAction(ctx context.Context, in *ActionrunMetricsRequest, opts ...grpc.CallOption) (*ActionrunMetrics, error)
	ListObjects(ctx context.Context, in *ListObjectsRequest, opts ...grpc.CallOption) (*ListObjectsResponse, error)
	ReportBot(ctx context.Context, in *ReportBotRequest, opts ...grpc.CallOption) (*ReportBotResponse, error)
}

type bizbotClient struct {
	cc grpc.ClientConnInterface
}

func NewBizbotClient(cc grpc.ClientConnInterface) BizbotClient {
	return &bizbotClient{cc}
}

func (c *bizbotClient) ListBots(ctx context.Context, in *BotsRequest, opts ...grpc.CallOption) (*Bots, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Bots)
	err := c.cc.Invoke(ctx, Bizbot_ListBots_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bizbotClient) GetBot(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Bot, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Bot)
	err := c.cc.Invoke(ctx, Bizbot_GetBot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bizbotClient) UpdateBotRunState(ctx context.Context, in *Bot, opts ...grpc.CallOption) (*Bot, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Bot)
	err := c.cc.Invoke(ctx, Bizbot_UpdateBotRunState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bizbotClient) CreateBot(ctx context.Context, in *Bot, opts ...grpc.CallOption) (*Bot, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Bot)
	err := c.cc.Invoke(ctx, Bizbot_CreateBot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bizbotClient) UpdateBot(ctx context.Context, in *Bot, opts ...grpc.CallOption) (*Bot, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Bot)
	err := c.cc.Invoke(ctx, Bizbot_UpdateBot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bizbotClient) DeleteBot(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Bizbot_DeleteBot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bizbotClient) OnEvent(ctx context.Context, in *BotRunRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Bizbot_OnEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bizbotClient) StartBot(ctx context.Context, in *BotRunRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Bizbot_StartBot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bizbotClient) StopBot(ctx context.Context, in *BotRunRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Bizbot_StopBot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bizbotClient) TryAction(ctx context.Context, in *BotRunRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Bizbot_TryAction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bizbotClient) ReportBot2(ctx context.Context, in *BotrunMetricsRequest, opts ...grpc.CallOption) (*BotrunMetrics, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BotrunMetrics)
	err := c.cc.Invoke(ctx, Bizbot_ReportBot2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bizbotClient) ReportAction(ctx context.Context, in *ActionrunMetricsRequest, opts ...grpc.CallOption) (*ActionrunMetrics, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActionrunMetrics)
	err := c.cc.Invoke(ctx, Bizbot_ReportAction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bizbotClient) ListObjects(ctx context.Context, in *ListObjectsRequest, opts ...grpc.CallOption) (*ListObjectsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListObjectsResponse)
	err := c.cc.Invoke(ctx, Bizbot_ListObjects_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bizbotClient) ReportBot(ctx context.Context, in *ReportBotRequest, opts ...grpc.CallOption) (*ReportBotResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportBotResponse)
	err := c.cc.Invoke(ctx, Bizbot_ReportBot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BizbotServer is the server API for Bizbot service.
// All implementations must embed UnimplementedBizbotServer
// for forward compatibility.
//
// bizbot services
type BizbotServer interface {
	ListBots(context.Context, *BotsRequest) (*Bots, error)
	GetBot(context.Context, *Id) (*Bot, error)
	UpdateBotRunState(context.Context, *Bot) (*Bot, error)
	CreateBot(context.Context, *Bot) (*Bot, error)
	UpdateBot(context.Context, *Bot) (*Bot, error)
	DeleteBot(context.Context, *Id) (*Empty, error)
	OnEvent(context.Context, *BotRunRequest) (*Empty, error)
	StartBot(context.Context, *BotRunRequest) (*Empty, error)
	StopBot(context.Context, *BotRunRequest) (*Empty, error)
	TryAction(context.Context, *BotRunRequest) (*Empty, error)
	ReportBot2(context.Context, *BotrunMetricsRequest) (*BotrunMetrics, error)
	ReportAction(context.Context, *ActionrunMetricsRequest) (*ActionrunMetrics, error)
	ListObjects(context.Context, *ListObjectsRequest) (*ListObjectsResponse, error)
	ReportBot(context.Context, *ReportBotRequest) (*ReportBotResponse, error)
	mustEmbedUnimplementedBizbotServer()
}

// UnimplementedBizbotServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBizbotServer struct{}

func (UnimplementedBizbotServer) ListBots(context.Context, *BotsRequest) (*Bots, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBots not implemented")
}
func (UnimplementedBizbotServer) GetBot(context.Context, *Id) (*Bot, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBot not implemented")
}
func (UnimplementedBizbotServer) UpdateBotRunState(context.Context, *Bot) (*Bot, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBotRunState not implemented")
}
func (UnimplementedBizbotServer) CreateBot(context.Context, *Bot) (*Bot, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBot not implemented")
}
func (UnimplementedBizbotServer) UpdateBot(context.Context, *Bot) (*Bot, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBot not implemented")
}
func (UnimplementedBizbotServer) DeleteBot(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBot not implemented")
}
func (UnimplementedBizbotServer) OnEvent(context.Context, *BotRunRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnEvent not implemented")
}
func (UnimplementedBizbotServer) StartBot(context.Context, *BotRunRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartBot not implemented")
}
func (UnimplementedBizbotServer) StopBot(context.Context, *BotRunRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopBot not implemented")
}
func (UnimplementedBizbotServer) TryAction(context.Context, *BotRunRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TryAction not implemented")
}
func (UnimplementedBizbotServer) ReportBot2(context.Context, *BotrunMetricsRequest) (*BotrunMetrics, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportBot2 not implemented")
}
func (UnimplementedBizbotServer) ReportAction(context.Context, *ActionrunMetricsRequest) (*ActionrunMetrics, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportAction not implemented")
}
func (UnimplementedBizbotServer) ListObjects(context.Context, *ListObjectsRequest) (*ListObjectsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListObjects not implemented")
}
func (UnimplementedBizbotServer) ReportBot(context.Context, *ReportBotRequest) (*ReportBotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportBot not implemented")
}
func (UnimplementedBizbotServer) mustEmbedUnimplementedBizbotServer() {}
func (UnimplementedBizbotServer) testEmbeddedByValue()                {}

// UnsafeBizbotServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BizbotServer will
// result in compilation errors.
type UnsafeBizbotServer interface {
	mustEmbedUnimplementedBizbotServer()
}

func RegisterBizbotServer(s grpc.ServiceRegistrar, srv BizbotServer) {
	// If the following call pancis, it indicates UnimplementedBizbotServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Bizbot_ServiceDesc, srv)
}

func _Bizbot_ListBots_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BotsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BizbotServer).ListBots(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Bizbot_ListBots_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BizbotServer).ListBots(ctx, req.(*BotsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bizbot_GetBot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BizbotServer).GetBot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Bizbot_GetBot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BizbotServer).GetBot(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bizbot_UpdateBotRunState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Bot)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BizbotServer).UpdateBotRunState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Bizbot_UpdateBotRunState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BizbotServer).UpdateBotRunState(ctx, req.(*Bot))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bizbot_CreateBot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Bot)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BizbotServer).CreateBot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Bizbot_CreateBot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BizbotServer).CreateBot(ctx, req.(*Bot))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bizbot_UpdateBot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Bot)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BizbotServer).UpdateBot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Bizbot_UpdateBot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BizbotServer).UpdateBot(ctx, req.(*Bot))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bizbot_DeleteBot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BizbotServer).DeleteBot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Bizbot_DeleteBot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BizbotServer).DeleteBot(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bizbot_OnEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BotRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BizbotServer).OnEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Bizbot_OnEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BizbotServer).OnEvent(ctx, req.(*BotRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bizbot_StartBot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BotRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BizbotServer).StartBot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Bizbot_StartBot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BizbotServer).StartBot(ctx, req.(*BotRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bizbot_StopBot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BotRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BizbotServer).StopBot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Bizbot_StopBot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BizbotServer).StopBot(ctx, req.(*BotRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bizbot_TryAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BotRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BizbotServer).TryAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Bizbot_TryAction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BizbotServer).TryAction(ctx, req.(*BotRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bizbot_ReportBot2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BotrunMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BizbotServer).ReportBot2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Bizbot_ReportBot2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BizbotServer).ReportBot2(ctx, req.(*BotrunMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bizbot_ReportAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionrunMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BizbotServer).ReportAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Bizbot_ReportAction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BizbotServer).ReportAction(ctx, req.(*ActionrunMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bizbot_ListObjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListObjectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BizbotServer).ListObjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Bizbot_ListObjects_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BizbotServer).ListObjects(ctx, req.(*ListObjectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bizbot_ReportBot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportBotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BizbotServer).ReportBot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Bizbot_ReportBot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BizbotServer).ReportBot(ctx, req.(*ReportBotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Bizbot_ServiceDesc is the grpc.ServiceDesc for Bizbot service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Bizbot_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.Bizbot",
	HandlerType: (*BizbotServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListBots",
			Handler:    _Bizbot_ListBots_Handler,
		},
		{
			MethodName: "GetBot",
			Handler:    _Bizbot_GetBot_Handler,
		},
		{
			MethodName: "UpdateBotRunState",
			Handler:    _Bizbot_UpdateBotRunState_Handler,
		},
		{
			MethodName: "CreateBot",
			Handler:    _Bizbot_CreateBot_Handler,
		},
		{
			MethodName: "UpdateBot",
			Handler:    _Bizbot_UpdateBot_Handler,
		},
		{
			MethodName: "DeleteBot",
			Handler:    _Bizbot_DeleteBot_Handler,
		},
		{
			MethodName: "OnEvent",
			Handler:    _Bizbot_OnEvent_Handler,
		},
		{
			MethodName: "StartBot",
			Handler:    _Bizbot_StartBot_Handler,
		},
		{
			MethodName: "StopBot",
			Handler:    _Bizbot_StopBot_Handler,
		},
		{
			MethodName: "TryAction",
			Handler:    _Bizbot_TryAction_Handler,
		},
		{
			MethodName: "ReportBot2",
			Handler:    _Bizbot_ReportBot2_Handler,
		},
		{
			MethodName: "ReportAction",
			Handler:    _Bizbot_ReportAction_Handler,
		},
		{
			MethodName: "ListObjects",
			Handler:    _Bizbot_ListObjects_Handler,
		},
		{
			MethodName: "ReportBot",
			Handler:    _Bizbot_ReportBot_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	Sendback_CreateWebhook_FullMethodName             = "/header.Sendback/CreateWebhook"
	Sendback_PingWebhook_FullMethodName               = "/header.Sendback/PingWebhook"
	Sendback_DeleteWebhook_FullMethodName             = "/header.Sendback/DeleteWebhook"
	Sendback_ListWebhooks_FullMethodName              = "/header.Sendback/ListWebhooks"
	Sendback_MatchWebhook_FullMethodName              = "/header.Sendback/MatchWebhook"
	Sendback_ReadWebhook_FullMethodName               = "/header.Sendback/ReadWebhook"
	Sendback_UpdateWebhook_FullMethodName             = "/header.Sendback/UpdateWebhook"
	Sendback_UpdateWebhookSecret_FullMethodName       = "/header.Sendback/UpdateWebhookSecret"
	Sendback_ListRecentIndexDeliveries_FullMethodName = "/header.Sendback/ListRecentIndexDeliveries"
	Sendback_GetDelivery_FullMethodName               = "/header.Sendback/GetDelivery"
	Sendback_SendWebhookEvent_FullMethodName          = "/header.Sendback/SendWebhookEvent"
)

// SendbackClient is the client API for Sendback service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// sendback services
type SendbackClient interface {
	CreateWebhook(ctx context.Context, in *Webhook, opts ...grpc.CallOption) (*Webhook, error)
	PingWebhook(ctx context.Context, in *Id, opts ...grpc.CallOption) (*WebhookTestResult, error)
	DeleteWebhook(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ListWebhooks(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	MatchWebhook(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
	ReadWebhook(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Webhook, error)
	UpdateWebhook(ctx context.Context, in *Webhook, opts ...grpc.CallOption) (*Webhook, error)
	UpdateWebhookSecret(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Webhook, error)
	ListRecentIndexDeliveries(ctx context.Context, in *RecentIndexDeliveryRequest, opts ...grpc.CallOption) (*WebhookDeliveries, error)
	GetDelivery(ctx context.Context, in *DeliveryRequest, opts ...grpc.CallOption) (*WebhookDelivery, error)
	SendWebhookEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Empty, error)
}

type sendbackClient struct {
	cc grpc.ClientConnInterface
}

func NewSendbackClient(cc grpc.ClientConnInterface) SendbackClient {
	return &sendbackClient{cc}
}

func (c *sendbackClient) CreateWebhook(ctx context.Context, in *Webhook, opts ...grpc.CallOption) (*Webhook, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Webhook)
	err := c.cc.Invoke(ctx, Sendback_CreateWebhook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sendbackClient) PingWebhook(ctx context.Context, in *Id, opts ...grpc.CallOption) (*WebhookTestResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WebhookTestResult)
	err := c.cc.Invoke(ctx, Sendback_PingWebhook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sendbackClient) DeleteWebhook(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Sendback_DeleteWebhook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sendbackClient) ListWebhooks(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Sendback_ListWebhooks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sendbackClient) MatchWebhook(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Sendback_MatchWebhook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sendbackClient) ReadWebhook(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Webhook, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Webhook)
	err := c.cc.Invoke(ctx, Sendback_ReadWebhook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sendbackClient) UpdateWebhook(ctx context.Context, in *Webhook, opts ...grpc.CallOption) (*Webhook, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Webhook)
	err := c.cc.Invoke(ctx, Sendback_UpdateWebhook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sendbackClient) UpdateWebhookSecret(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Webhook, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Webhook)
	err := c.cc.Invoke(ctx, Sendback_UpdateWebhookSecret_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sendbackClient) ListRecentIndexDeliveries(ctx context.Context, in *RecentIndexDeliveryRequest, opts ...grpc.CallOption) (*WebhookDeliveries, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WebhookDeliveries)
	err := c.cc.Invoke(ctx, Sendback_ListRecentIndexDeliveries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sendbackClient) GetDelivery(ctx context.Context, in *DeliveryRequest, opts ...grpc.CallOption) (*WebhookDelivery, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WebhookDelivery)
	err := c.cc.Invoke(ctx, Sendback_GetDelivery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sendbackClient) SendWebhookEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Sendback_SendWebhookEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SendbackServer is the server API for Sendback service.
// All implementations must embed UnimplementedSendbackServer
// for forward compatibility.
//
// sendback services
type SendbackServer interface {
	CreateWebhook(context.Context, *Webhook) (*Webhook, error)
	PingWebhook(context.Context, *Id) (*WebhookTestResult, error)
	DeleteWebhook(context.Context, *Id) (*Empty, error)
	ListWebhooks(context.Context, *Id) (*Response, error)
	MatchWebhook(context.Context, *Ids) (*Response, error)
	ReadWebhook(context.Context, *Id) (*Webhook, error)
	UpdateWebhook(context.Context, *Webhook) (*Webhook, error)
	UpdateWebhookSecret(context.Context, *Id) (*Webhook, error)
	ListRecentIndexDeliveries(context.Context, *RecentIndexDeliveryRequest) (*WebhookDeliveries, error)
	GetDelivery(context.Context, *DeliveryRequest) (*WebhookDelivery, error)
	SendWebhookEvent(context.Context, *Event) (*Empty, error)
	mustEmbedUnimplementedSendbackServer()
}

// UnimplementedSendbackServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSendbackServer struct{}

func (UnimplementedSendbackServer) CreateWebhook(context.Context, *Webhook) (*Webhook, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateWebhook not implemented")
}
func (UnimplementedSendbackServer) PingWebhook(context.Context, *Id) (*WebhookTestResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PingWebhook not implemented")
}
func (UnimplementedSendbackServer) DeleteWebhook(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWebhook not implemented")
}
func (UnimplementedSendbackServer) ListWebhooks(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWebhooks not implemented")
}
func (UnimplementedSendbackServer) MatchWebhook(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchWebhook not implemented")
}
func (UnimplementedSendbackServer) ReadWebhook(context.Context, *Id) (*Webhook, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadWebhook not implemented")
}
func (UnimplementedSendbackServer) UpdateWebhook(context.Context, *Webhook) (*Webhook, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWebhook not implemented")
}
func (UnimplementedSendbackServer) UpdateWebhookSecret(context.Context, *Id) (*Webhook, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWebhookSecret not implemented")
}
func (UnimplementedSendbackServer) ListRecentIndexDeliveries(context.Context, *RecentIndexDeliveryRequest) (*WebhookDeliveries, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRecentIndexDeliveries not implemented")
}
func (UnimplementedSendbackServer) GetDelivery(context.Context, *DeliveryRequest) (*WebhookDelivery, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDelivery not implemented")
}
func (UnimplementedSendbackServer) SendWebhookEvent(context.Context, *Event) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendWebhookEvent not implemented")
}
func (UnimplementedSendbackServer) mustEmbedUnimplementedSendbackServer() {}
func (UnimplementedSendbackServer) testEmbeddedByValue()                  {}

// UnsafeSendbackServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SendbackServer will
// result in compilation errors.
type UnsafeSendbackServer interface {
	mustEmbedUnimplementedSendbackServer()
}

func RegisterSendbackServer(s grpc.ServiceRegistrar, srv SendbackServer) {
	// If the following call pancis, it indicates UnimplementedSendbackServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Sendback_ServiceDesc, srv)
}

func _Sendback_CreateWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Webhook)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendbackServer).CreateWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Sendback_CreateWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendbackServer).CreateWebhook(ctx, req.(*Webhook))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sendback_PingWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendbackServer).PingWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Sendback_PingWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendbackServer).PingWebhook(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sendback_DeleteWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendbackServer).DeleteWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Sendback_DeleteWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendbackServer).DeleteWebhook(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sendback_ListWebhooks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendbackServer).ListWebhooks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Sendback_ListWebhooks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendbackServer).ListWebhooks(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sendback_MatchWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendbackServer).MatchWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Sendback_MatchWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendbackServer).MatchWebhook(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sendback_ReadWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendbackServer).ReadWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Sendback_ReadWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendbackServer).ReadWebhook(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sendback_UpdateWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Webhook)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendbackServer).UpdateWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Sendback_UpdateWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendbackServer).UpdateWebhook(ctx, req.(*Webhook))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sendback_UpdateWebhookSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendbackServer).UpdateWebhookSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Sendback_UpdateWebhookSecret_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendbackServer).UpdateWebhookSecret(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sendback_ListRecentIndexDeliveries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecentIndexDeliveryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendbackServer).ListRecentIndexDeliveries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Sendback_ListRecentIndexDeliveries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendbackServer).ListRecentIndexDeliveries(ctx, req.(*RecentIndexDeliveryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sendback_GetDelivery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeliveryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendbackServer).GetDelivery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Sendback_GetDelivery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendbackServer).GetDelivery(ctx, req.(*DeliveryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sendback_SendWebhookEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendbackServer).SendWebhookEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Sendback_SendWebhookEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendbackServer).SendWebhookEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

// Sendback_ServiceDesc is the grpc.ServiceDesc for Sendback service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Sendback_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.Sendback",
	HandlerType: (*SendbackServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateWebhook",
			Handler:    _Sendback_CreateWebhook_Handler,
		},
		{
			MethodName: "PingWebhook",
			Handler:    _Sendback_PingWebhook_Handler,
		},
		{
			MethodName: "DeleteWebhook",
			Handler:    _Sendback_DeleteWebhook_Handler,
		},
		{
			MethodName: "ListWebhooks",
			Handler:    _Sendback_ListWebhooks_Handler,
		},
		{
			MethodName: "MatchWebhook",
			Handler:    _Sendback_MatchWebhook_Handler,
		},
		{
			MethodName: "ReadWebhook",
			Handler:    _Sendback_ReadWebhook_Handler,
		},
		{
			MethodName: "UpdateWebhook",
			Handler:    _Sendback_UpdateWebhook_Handler,
		},
		{
			MethodName: "UpdateWebhookSecret",
			Handler:    _Sendback_UpdateWebhookSecret_Handler,
		},
		{
			MethodName: "ListRecentIndexDeliveries",
			Handler:    _Sendback_ListRecentIndexDeliveries_Handler,
		},
		{
			MethodName: "GetDelivery",
			Handler:    _Sendback_GetDelivery_Handler,
		},
		{
			MethodName: "SendWebhookEvent",
			Handler:    _Sendback_SendWebhookEvent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	Emitter_CreateEventDestination_FullMethodName = "/header.Emitter/CreateEventDestination"
	Emitter_UpdateEventDestination_FullMethodName = "/header.Emitter/UpdateEventDestination"
	Emitter_DeleteEventDestination_FullMethodName = "/header.Emitter/DeleteEventDestination"
	Emitter_ListEventDestinations_FullMethodName  = "/header.Emitter/ListEventDestinations"
	Emitter_GetEventDestination_FullMethodName    = "/header.Emitter/GetEventDestination"
	Emitter_EmitEvent_FullMethodName              = "/header.Emitter/EmitEvent"
)

// EmitterClient is the client API for Emitter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EmitterClient interface {
	CreateEventDestination(ctx context.Context, in *EventDestination, opts ...grpc.CallOption) (*Response, error)
	UpdateEventDestination(ctx context.Context, in *EventDestination, opts ...grpc.CallOption) (*Response, error)
	DeleteEventDestination(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	ListEventDestinations(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	GetEventDestination(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	EmitEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Empty, error)
}

type emitterClient struct {
	cc grpc.ClientConnInterface
}

func NewEmitterClient(cc grpc.ClientConnInterface) EmitterClient {
	return &emitterClient{cc}
}

func (c *emitterClient) CreateEventDestination(ctx context.Context, in *EventDestination, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Emitter_CreateEventDestination_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emitterClient) UpdateEventDestination(ctx context.Context, in *EventDestination, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Emitter_UpdateEventDestination_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emitterClient) DeleteEventDestination(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Emitter_DeleteEventDestination_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emitterClient) ListEventDestinations(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Emitter_ListEventDestinations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emitterClient) GetEventDestination(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Emitter_GetEventDestination_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emitterClient) EmitEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Emitter_EmitEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EmitterServer is the server API for Emitter service.
// All implementations must embed UnimplementedEmitterServer
// for forward compatibility.
type EmitterServer interface {
	CreateEventDestination(context.Context, *EventDestination) (*Response, error)
	UpdateEventDestination(context.Context, *EventDestination) (*Response, error)
	DeleteEventDestination(context.Context, *Id) (*Response, error)
	ListEventDestinations(context.Context, *Id) (*Response, error)
	GetEventDestination(context.Context, *Id) (*Response, error)
	EmitEvent(context.Context, *Event) (*Empty, error)
	mustEmbedUnimplementedEmitterServer()
}

// UnimplementedEmitterServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEmitterServer struct{}

func (UnimplementedEmitterServer) CreateEventDestination(context.Context, *EventDestination) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateEventDestination not implemented")
}
func (UnimplementedEmitterServer) UpdateEventDestination(context.Context, *EventDestination) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateEventDestination not implemented")
}
func (UnimplementedEmitterServer) DeleteEventDestination(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteEventDestination not implemented")
}
func (UnimplementedEmitterServer) ListEventDestinations(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListEventDestinations not implemented")
}
func (UnimplementedEmitterServer) GetEventDestination(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEventDestination not implemented")
}
func (UnimplementedEmitterServer) EmitEvent(context.Context, *Event) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmitEvent not implemented")
}
func (UnimplementedEmitterServer) mustEmbedUnimplementedEmitterServer() {}
func (UnimplementedEmitterServer) testEmbeddedByValue()                 {}

// UnsafeEmitterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EmitterServer will
// result in compilation errors.
type UnsafeEmitterServer interface {
	mustEmbedUnimplementedEmitterServer()
}

func RegisterEmitterServer(s grpc.ServiceRegistrar, srv EmitterServer) {
	// If the following call pancis, it indicates UnimplementedEmitterServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Emitter_ServiceDesc, srv)
}

func _Emitter_CreateEventDestination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventDestination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmitterServer).CreateEventDestination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Emitter_CreateEventDestination_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmitterServer).CreateEventDestination(ctx, req.(*EventDestination))
	}
	return interceptor(ctx, in, info, handler)
}

func _Emitter_UpdateEventDestination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventDestination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmitterServer).UpdateEventDestination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Emitter_UpdateEventDestination_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmitterServer).UpdateEventDestination(ctx, req.(*EventDestination))
	}
	return interceptor(ctx, in, info, handler)
}

func _Emitter_DeleteEventDestination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmitterServer).DeleteEventDestination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Emitter_DeleteEventDestination_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmitterServer).DeleteEventDestination(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Emitter_ListEventDestinations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmitterServer).ListEventDestinations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Emitter_ListEventDestinations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmitterServer).ListEventDestinations(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Emitter_GetEventDestination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmitterServer).GetEventDestination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Emitter_GetEventDestination_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmitterServer).GetEventDestination(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Emitter_EmitEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmitterServer).EmitEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Emitter_EmitEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmitterServer).EmitEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

// Emitter_ServiceDesc is the grpc.ServiceDesc for Emitter service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Emitter_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.Emitter",
	HandlerType: (*EmitterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateEventDestination",
			Handler:    _Emitter_CreateEventDestination_Handler,
		},
		{
			MethodName: "UpdateEventDestination",
			Handler:    _Emitter_UpdateEventDestination_Handler,
		},
		{
			MethodName: "DeleteEventDestination",
			Handler:    _Emitter_DeleteEventDestination_Handler,
		},
		{
			MethodName: "ListEventDestinations",
			Handler:    _Emitter_ListEventDestinations_Handler,
		},
		{
			MethodName: "GetEventDestination",
			Handler:    _Emitter_GetEventDestination_Handler,
		},
		{
			MethodName: "EmitEvent",
			Handler:    _Emitter_EmitEvent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	NotiMgr_GetNotificationSetting_FullMethodName    = "/header.NotiMgr/GetNotificationSetting"
	NotiMgr_UpdateNotificationSetting_FullMethodName = "/header.NotiMgr/UpdateNotificationSetting"
	NotiMgr_PushNoti_FullMethodName                  = "/header.NotiMgr/PushNoti"
	NotiMgr_AddToken_FullMethodName                  = "/header.NotiMgr/AddToken"
	NotiMgr_RemoveToken_FullMethodName               = "/header.NotiMgr/RemoveToken"
	NotiMgr_CheckTokenExists_FullMethodName          = "/header.NotiMgr/CheckTokenExists"
	NotiMgr_MarkReadNoti_FullMethodName              = "/header.NotiMgr/MarkReadNoti"
	NotiMgr_ListNotifications_FullMethodName         = "/header.NotiMgr/ListNotifications"
	NotiMgr_MarkUnreadNoti_FullMethodName            = "/header.NotiMgr/MarkUnreadNoti"
	NotiMgr_MarkOpenNoti_FullMethodName              = "/header.NotiMgr/MarkOpenNoti"
	NotiMgr_DeleteNotification_FullMethodName        = "/header.NotiMgr/DeleteNotification"
)

// NotiMgrClient is the client API for NotiMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NotiMgrClient interface {
	GetNotificationSetting(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	UpdateNotificationSetting(ctx context.Context, in *NotiSetting, opts ...grpc.CallOption) (*Response, error)
	PushNoti(ctx context.Context, in *Noti, opts ...grpc.CallOption) (*Empty, error)
	AddToken(ctx context.Context, in *PushToken, opts ...grpc.CallOption) (*Empty, error)
	RemoveToken(ctx context.Context, in *PushToken, opts ...grpc.CallOption) (*Empty, error)
	CheckTokenExists(ctx context.Context, in *PushToken, opts ...grpc.CallOption) (*Empty, error)
	MarkReadNoti(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ListNotifications(ctx context.Context, in *ListNotiRequest, opts ...grpc.CallOption) (*Response, error)
	MarkUnreadNoti(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	MarkOpenNoti(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	DeleteNotification(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
}

type notiMgrClient struct {
	cc grpc.ClientConnInterface
}

func NewNotiMgrClient(cc grpc.ClientConnInterface) NotiMgrClient {
	return &notiMgrClient{cc}
}

func (c *notiMgrClient) GetNotificationSetting(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, NotiMgr_GetNotificationSetting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notiMgrClient) UpdateNotificationSetting(ctx context.Context, in *NotiSetting, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, NotiMgr_UpdateNotificationSetting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notiMgrClient) PushNoti(ctx context.Context, in *Noti, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, NotiMgr_PushNoti_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notiMgrClient) AddToken(ctx context.Context, in *PushToken, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, NotiMgr_AddToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notiMgrClient) RemoveToken(ctx context.Context, in *PushToken, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, NotiMgr_RemoveToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notiMgrClient) CheckTokenExists(ctx context.Context, in *PushToken, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, NotiMgr_CheckTokenExists_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notiMgrClient) MarkReadNoti(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, NotiMgr_MarkReadNoti_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notiMgrClient) ListNotifications(ctx context.Context, in *ListNotiRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, NotiMgr_ListNotifications_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notiMgrClient) MarkUnreadNoti(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, NotiMgr_MarkUnreadNoti_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notiMgrClient) MarkOpenNoti(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, NotiMgr_MarkOpenNoti_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notiMgrClient) DeleteNotification(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, NotiMgr_DeleteNotification_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotiMgrServer is the server API for NotiMgr service.
// All implementations must embed UnimplementedNotiMgrServer
// for forward compatibility.
type NotiMgrServer interface {
	GetNotificationSetting(context.Context, *Id) (*Response, error)
	UpdateNotificationSetting(context.Context, *NotiSetting) (*Response, error)
	PushNoti(context.Context, *Noti) (*Empty, error)
	AddToken(context.Context, *PushToken) (*Empty, error)
	RemoveToken(context.Context, *PushToken) (*Empty, error)
	CheckTokenExists(context.Context, *PushToken) (*Empty, error)
	MarkReadNoti(context.Context, *Id) (*Empty, error)
	ListNotifications(context.Context, *ListNotiRequest) (*Response, error)
	MarkUnreadNoti(context.Context, *Id) (*Empty, error)
	MarkOpenNoti(context.Context, *Id) (*Empty, error)
	DeleteNotification(context.Context, *Id) (*Empty, error)
	mustEmbedUnimplementedNotiMgrServer()
}

// UnimplementedNotiMgrServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNotiMgrServer struct{}

func (UnimplementedNotiMgrServer) GetNotificationSetting(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNotificationSetting not implemented")
}
func (UnimplementedNotiMgrServer) UpdateNotificationSetting(context.Context, *NotiSetting) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNotificationSetting not implemented")
}
func (UnimplementedNotiMgrServer) PushNoti(context.Context, *Noti) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushNoti not implemented")
}
func (UnimplementedNotiMgrServer) AddToken(context.Context, *PushToken) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddToken not implemented")
}
func (UnimplementedNotiMgrServer) RemoveToken(context.Context, *PushToken) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveToken not implemented")
}
func (UnimplementedNotiMgrServer) CheckTokenExists(context.Context, *PushToken) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckTokenExists not implemented")
}
func (UnimplementedNotiMgrServer) MarkReadNoti(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkReadNoti not implemented")
}
func (UnimplementedNotiMgrServer) ListNotifications(context.Context, *ListNotiRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNotifications not implemented")
}
func (UnimplementedNotiMgrServer) MarkUnreadNoti(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkUnreadNoti not implemented")
}
func (UnimplementedNotiMgrServer) MarkOpenNoti(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkOpenNoti not implemented")
}
func (UnimplementedNotiMgrServer) DeleteNotification(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNotification not implemented")
}
func (UnimplementedNotiMgrServer) mustEmbedUnimplementedNotiMgrServer() {}
func (UnimplementedNotiMgrServer) testEmbeddedByValue()                 {}

// UnsafeNotiMgrServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NotiMgrServer will
// result in compilation errors.
type UnsafeNotiMgrServer interface {
	mustEmbedUnimplementedNotiMgrServer()
}

func RegisterNotiMgrServer(s grpc.ServiceRegistrar, srv NotiMgrServer) {
	// If the following call pancis, it indicates UnimplementedNotiMgrServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NotiMgr_ServiceDesc, srv)
}

func _NotiMgr_GetNotificationSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotiMgrServer).GetNotificationSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotiMgr_GetNotificationSetting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotiMgrServer).GetNotificationSetting(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotiMgr_UpdateNotificationSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotiSetting)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotiMgrServer).UpdateNotificationSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotiMgr_UpdateNotificationSetting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotiMgrServer).UpdateNotificationSetting(ctx, req.(*NotiSetting))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotiMgr_PushNoti_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Noti)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotiMgrServer).PushNoti(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotiMgr_PushNoti_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotiMgrServer).PushNoti(ctx, req.(*Noti))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotiMgr_AddToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotiMgrServer).AddToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotiMgr_AddToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotiMgrServer).AddToken(ctx, req.(*PushToken))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotiMgr_RemoveToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotiMgrServer).RemoveToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotiMgr_RemoveToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotiMgrServer).RemoveToken(ctx, req.(*PushToken))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotiMgr_CheckTokenExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotiMgrServer).CheckTokenExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotiMgr_CheckTokenExists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotiMgrServer).CheckTokenExists(ctx, req.(*PushToken))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotiMgr_MarkReadNoti_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotiMgrServer).MarkReadNoti(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotiMgr_MarkReadNoti_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotiMgrServer).MarkReadNoti(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotiMgr_ListNotifications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNotiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotiMgrServer).ListNotifications(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotiMgr_ListNotifications_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotiMgrServer).ListNotifications(ctx, req.(*ListNotiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotiMgr_MarkUnreadNoti_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotiMgrServer).MarkUnreadNoti(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotiMgr_MarkUnreadNoti_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotiMgrServer).MarkUnreadNoti(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotiMgr_MarkOpenNoti_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotiMgrServer).MarkOpenNoti(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotiMgr_MarkOpenNoti_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotiMgrServer).MarkOpenNoti(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotiMgr_DeleteNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotiMgrServer).DeleteNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotiMgr_DeleteNotification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotiMgrServer).DeleteNotification(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

// NotiMgr_ServiceDesc is the grpc.ServiceDesc for NotiMgr service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NotiMgr_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.NotiMgr",
	HandlerType: (*NotiMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNotificationSetting",
			Handler:    _NotiMgr_GetNotificationSetting_Handler,
		},
		{
			MethodName: "UpdateNotificationSetting",
			Handler:    _NotiMgr_UpdateNotificationSetting_Handler,
		},
		{
			MethodName: "PushNoti",
			Handler:    _NotiMgr_PushNoti_Handler,
		},
		{
			MethodName: "AddToken",
			Handler:    _NotiMgr_AddToken_Handler,
		},
		{
			MethodName: "RemoveToken",
			Handler:    _NotiMgr_RemoveToken_Handler,
		},
		{
			MethodName: "CheckTokenExists",
			Handler:    _NotiMgr_CheckTokenExists_Handler,
		},
		{
			MethodName: "MarkReadNoti",
			Handler:    _NotiMgr_MarkReadNoti_Handler,
		},
		{
			MethodName: "ListNotifications",
			Handler:    _NotiMgr_ListNotifications_Handler,
		},
		{
			MethodName: "MarkUnreadNoti",
			Handler:    _NotiMgr_MarkUnreadNoti_Handler,
		},
		{
			MethodName: "MarkOpenNoti",
			Handler:    _NotiMgr_MarkOpenNoti_Handler,
		},
		{
			MethodName: "DeleteNotification",
			Handler:    _NotiMgr_DeleteNotification_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	Proder_ReadProduct_FullMethodName               = "/header.Proder/ReadProduct"
	Proder_CreateProduct_FullMethodName             = "/header.Proder/CreateProduct"
	Proder_UpdateProduct_FullMethodName             = "/header.Proder/UpdateProduct"
	Proder_DeleteProduct_FullMethodName             = "/header.Proder/DeleteProduct"
	Proder_ListProducts2_FullMethodName             = "/header.Proder/ListProducts2"
	Proder_ListAllProductIds_FullMethodName         = "/header.Proder/ListAllProductIds"
	Proder_ImportProduct_FullMethodName             = "/header.Proder/ImportProduct"
	Proder_GetProductOffer_FullMethodName           = "/header.Proder/GetProductOffer"
	Proder_CreateProductOffer_FullMethodName        = "/header.Proder/CreateProductOffer"
	Proder_UpdateProductOffer_FullMethodName        = "/header.Proder/UpdateProductOffer"
	Proder_DeleteProductOffer_FullMethodName        = "/header.Proder/DeleteProductOffer"
	Proder_ListProductOffers_FullMethodName         = "/header.Proder/ListProductOffers"
	Proder_CreateProductFromFile_FullMethodName     = "/header.Proder/CreateProductFromFile"
	Proder_ListDiscounts_FullMethodName             = "/header.Proder/ListDiscounts"
	Proder_CreateDiscount_FullMethodName            = "/header.Proder/CreateDiscount"
	Proder_GetDiscount_FullMethodName               = "/header.Proder/GetDiscount"
	Proder_UpdateDiscount_FullMethodName            = "/header.Proder/UpdateDiscount"
	Proder_DeleteDiscount_FullMethodName            = "/header.Proder/DeleteDiscount"
	Proder_MatchDiscounts_FullMethodName            = "/header.Proder/MatchDiscounts"
	Proder_ListAvaiableDiscounts_FullMethodName     = "/header.Proder/ListAvaiableDiscounts"
	Proder_ListAllProductDiscountIds_FullMethodName = "/header.Proder/ListAllProductDiscountIds"
	Proder_ListProductFeeds_FullMethodName          = "/header.Proder/ListProductFeeds"
	Proder_CreateProductFeed_FullMethodName         = "/header.Proder/CreateProductFeed"
	Proder_UpdateProductFeed_FullMethodName         = "/header.Proder/UpdateProductFeed"
	Proder_DeleteProductFeed_FullMethodName         = "/header.Proder/DeleteProductFeed"
	Proder_MatchProductFeeds_FullMethodName         = "/header.Proder/MatchProductFeeds"
	Proder_ListProductCategories_FullMethodName     = "/header.Proder/ListProductCategories"
	Proder_ReadOrder_FullMethodName                 = "/header.Proder/ReadOrder"
	Proder_CreateOrder_FullMethodName               = "/header.Proder/CreateOrder"
	Proder_UpdateOrder_FullMethodName               = "/header.Proder/UpdateOrder"
	Proder_DeleteOrder_FullMethodName               = "/header.Proder/DeleteOrder"
	Proder_ListOrders_FullMethodName                = "/header.Proder/ListOrders"
	Proder_CountOrders2_FullMethodName              = "/header.Proder/CountOrders2"
	Proder_ImportOrders_FullMethodName              = "/header.Proder/ImportOrders"
	Proder_MakeOrderPayment_FullMethodName          = "/header.Proder/MakeOrderPayment"
	Proder_UpdatePurchase_FullMethodName            = "/header.Proder/UpdatePurchase"
	Proder_CancelPurchase_FullMethodName            = "/header.Proder/CancelPurchase"
	Proder_AddOrderComment_FullMethodName           = "/header.Proder/AddOrderComment"
	Proder_EditOrderComment_FullMethodName          = "/header.Proder/EditOrderComment"
	Proder_DeleteOrderComment_FullMethodName        = "/header.Proder/DeleteOrderComment"
	Proder_ListOrderEvents_FullMethodName           = "/header.Proder/ListOrderEvents"
	Proder_ListOrderBills_FullMethodName            = "/header.Proder/ListOrderBills"
	Proder_DownloadOrder_FullMethodName             = "/header.Proder/DownloadOrder"
	Proder_GetShopeeAuthUrl_FullMethodName          = "/header.Proder/GetShopeeAuthUrl"
	Proder_AuthorizeShopeeShop_FullMethodName       = "/header.Proder/AuthorizeShopeeShop"
	Proder_DeauthorizeShopeeShop_FullMethodName     = "/header.Proder/DeauthorizeShopeeShop"
	Proder_SyncShopeeProducts_FullMethodName        = "/header.Proder/SyncShopeeProducts"
	Proder_GHTKShippingStatus_FullMethodName        = "/header.Proder/GHTKShippingStatus"
	Proder_GHNShippingStatus_FullMethodName         = "/header.Proder/GHNShippingStatus"
	Proder_ShippingFee_FullMethodName               = "/header.Proder/ShippingFee"
	Proder_ShipOrder_FullMethodName                 = "/header.Proder/ShipOrder"
	Proder_UpdateShippingCode_FullMethodName        = "/header.Proder/UpdateShippingCode"
	Proder_CancelShippingOrder_FullMethodName       = "/header.Proder/CancelShippingOrder"
	Proder_PrintShippingOrders_FullMethodName       = "/header.Proder/PrintShippingOrders"
	Proder_SeenOrder_FullMethodName                 = "/header.Proder/SeenOrder"
	Proder_FollowOrder_FullMethodName               = "/header.Proder/FollowOrder"
	Proder_UnfollowOrder_FullMethodName             = "/header.Proder/UnfollowOrder"
	Proder_TagOrder_FullMethodName                  = "/header.Proder/TagOrder"
	Proder_UntagOrder_FullMethodName                = "/header.Proder/UntagOrder"
	Proder_ReadPipeline_FullMethodName              = "/header.Proder/ReadPipeline"
	Proder_CreatePipeline_FullMethodName            = "/header.Proder/CreatePipeline"
	Proder_UpdatePipeline_FullMethodName            = "/header.Proder/UpdatePipeline"
	Proder_DeletePipeline_FullMethodName            = "/header.Proder/DeletePipeline"
	Proder_ListPipelines_FullMethodName             = "/header.Proder/ListPipelines"
	Proder_DeletePipelineStage_FullMethodName       = "/header.Proder/DeletePipelineStage"
	Proder_PreselectPipeline_FullMethodName         = "/header.Proder/PreselectPipeline"
	Proder_ReportOrder_FullMethodName               = "/header.Proder/ReportOrder"
	Proder_MoveOrderToPrimary_FullMethodName        = "/header.Proder/MoveOrderToPrimary"
)

// ProderClient is the client API for Proder service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// proder services
type ProderClient interface {
	ReadProduct(ctx context.Context, in *Product, opts ...grpc.CallOption) (*Product, error)
	CreateProduct(ctx context.Context, in *Product, opts ...grpc.CallOption) (*Product, error)
	UpdateProduct(ctx context.Context, in *Product, opts ...grpc.CallOption) (*Product, error)
	DeleteProduct(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ListProducts2(ctx context.Context, in *ProductsRequest, opts ...grpc.CallOption) (*Response, error)
	ListAllProductIds(ctx context.Context, in *ProductsRequest, opts ...grpc.CallOption) (*Ids, error)
	ImportProduct(ctx context.Context, in *ImportProductRequest, opts ...grpc.CallOption) (*ImportProductResponse, error)
	GetProductOffer(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	CreateProductOffer(ctx context.Context, in *ProductOffer, opts ...grpc.CallOption) (*Response, error)
	UpdateProductOffer(ctx context.Context, in *ProductOffer, opts ...grpc.CallOption) (*Response, error)
	DeleteProductOffer(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ListProductOffers(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	CreateProductFromFile(ctx context.Context, in *ConvertProductRequest, opts ...grpc.CallOption) (*Response, error)
	ListDiscounts(ctx context.Context, in *ListDiscountRequest, opts ...grpc.CallOption) (*Response, error)
	CreateDiscount(ctx context.Context, in *Discount, opts ...grpc.CallOption) (*Response, error)
	GetDiscount(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	UpdateDiscount(ctx context.Context, in *Discount, opts ...grpc.CallOption) (*Response, error)
	DeleteDiscount(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	MatchDiscounts(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
	ListAvaiableDiscounts(ctx context.Context, in *ListAvaiableDiscountsRequest, opts ...grpc.CallOption) (*Response, error)
	ListAllProductDiscountIds(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Ids, error)
	ListProductFeeds(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	CreateProductFeed(ctx context.Context, in *ProductFeed, opts ...grpc.CallOption) (*Response, error)
	UpdateProductFeed(ctx context.Context, in *ProductFeed, opts ...grpc.CallOption) (*Response, error)
	DeleteProductFeed(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	MatchProductFeeds(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
	ListProductCategories(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*ProductCategories, error)
	ReadOrder(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Order, error)
	CreateOrder(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error)
	UpdateOrder(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error)
	DeleteOrder(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ListOrders(ctx context.Context, in *OrdersRequest, opts ...grpc.CallOption) (*Orders, error)
	CountOrders2(ctx context.Context, in *CountOrdersRequest, opts ...grpc.CallOption) (*CountOrdersResponse, error)
	ImportOrders(ctx context.Context, in *Orders, opts ...grpc.CallOption) (*Orders, error)
	// fire order_updated, order_event_updated
	MakeOrderPayment(ctx context.Context, in *Bill, opts ...grpc.CallOption) (*Response, error)
	UpdatePurchase(ctx context.Context, in *Bill, opts ...grpc.CallOption) (*Response, error)
	CancelPurchase(ctx context.Context, in *Bill, opts ...grpc.CallOption) (*Response, error)
	AddOrderComment(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error)
	EditOrderComment(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error)
	DeleteOrderComment(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Event, error)
	ListOrderEvents(ctx context.Context, in *Id, opts ...grpc.CallOption) (*OrderHistoryEntries, error)
	ListOrderBills(ctx context.Context, in *BillsRequest, opts ...grpc.CallOption) (*Response, error)
	DownloadOrder(ctx context.Context, in *DownloadOrderRequest, opts ...grpc.CallOption) (*File, error)
	GetShopeeAuthUrl(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Id, error)
	AuthorizeShopeeShop(ctx context.Context, in *AuthorizeShopeeRequest, opts ...grpc.CallOption) (*ShopeeShop, error)
	DeauthorizeShopeeShop(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	SyncShopeeProducts(ctx context.Context, in *ShopeeSyncProductRequest, opts ...grpc.CallOption) (*ShopeeSyncProductResponse, error)
	GHTKShippingStatus(ctx context.Context, in *GHTKOrder, opts ...grpc.CallOption) (*Empty, error)
	GHNShippingStatus(ctx context.Context, in *GHNOrder2, opts ...grpc.CallOption) (*Empty, error)
	ShippingFee(ctx context.Context, in *ShippingInfo, opts ...grpc.CallOption) (*ShippingInfo, error)
	ShipOrder(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Order, error)
	UpdateShippingCode(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error)
	CancelShippingOrder(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Order, error)
	PrintShippingOrders(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*File, error)
	SeenOrder(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	FollowOrder(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	UnfollowOrder(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	TagOrder(ctx context.Context, in *TagRequest, opts ...grpc.CallOption) (*Empty, error)
	UntagOrder(ctx context.Context, in *TagRequest, opts ...grpc.CallOption) (*Empty, error)
	ReadPipeline(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Pipeline, error)
	CreatePipeline(ctx context.Context, in *Pipeline, opts ...grpc.CallOption) (*Pipeline, error)
	UpdatePipeline(ctx context.Context, in *Pipeline, opts ...grpc.CallOption) (*Pipeline, error)
	DeletePipeline(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ListPipelines(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Pipelines, error)
	DeletePipelineStage(ctx context.Context, in *PipelineStage, opts ...grpc.CallOption) (*Empty, error)
	PreselectPipeline(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Pipeline, error)
	ReportOrder(ctx context.Context, in *OrderMetricsRequest, opts ...grpc.CallOption) (*Orders, error)
	MoveOrderToPrimary(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Empty, error)
}

type proderClient struct {
	cc grpc.ClientConnInterface
}

func NewProderClient(cc grpc.ClientConnInterface) ProderClient {
	return &proderClient{cc}
}

func (c *proderClient) ReadProduct(ctx context.Context, in *Product, opts ...grpc.CallOption) (*Product, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Product)
	err := c.cc.Invoke(ctx, Proder_ReadProduct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) CreateProduct(ctx context.Context, in *Product, opts ...grpc.CallOption) (*Product, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Product)
	err := c.cc.Invoke(ctx, Proder_CreateProduct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) UpdateProduct(ctx context.Context, in *Product, opts ...grpc.CallOption) (*Product, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Product)
	err := c.cc.Invoke(ctx, Proder_UpdateProduct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) DeleteProduct(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Proder_DeleteProduct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) ListProducts2(ctx context.Context, in *ProductsRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Proder_ListProducts2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) ListAllProductIds(ctx context.Context, in *ProductsRequest, opts ...grpc.CallOption) (*Ids, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Ids)
	err := c.cc.Invoke(ctx, Proder_ListAllProductIds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) ImportProduct(ctx context.Context, in *ImportProductRequest, opts ...grpc.CallOption) (*ImportProductResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportProductResponse)
	err := c.cc.Invoke(ctx, Proder_ImportProduct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) GetProductOffer(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Proder_GetProductOffer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) CreateProductOffer(ctx context.Context, in *ProductOffer, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Proder_CreateProductOffer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) UpdateProductOffer(ctx context.Context, in *ProductOffer, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Proder_UpdateProductOffer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) DeleteProductOffer(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Proder_DeleteProductOffer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) ListProductOffers(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Proder_ListProductOffers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) CreateProductFromFile(ctx context.Context, in *ConvertProductRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Proder_CreateProductFromFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) ListDiscounts(ctx context.Context, in *ListDiscountRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Proder_ListDiscounts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) CreateDiscount(ctx context.Context, in *Discount, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Proder_CreateDiscount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) GetDiscount(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Proder_GetDiscount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) UpdateDiscount(ctx context.Context, in *Discount, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Proder_UpdateDiscount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) DeleteDiscount(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Proder_DeleteDiscount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) MatchDiscounts(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Proder_MatchDiscounts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) ListAvaiableDiscounts(ctx context.Context, in *ListAvaiableDiscountsRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Proder_ListAvaiableDiscounts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) ListAllProductDiscountIds(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Ids, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Ids)
	err := c.cc.Invoke(ctx, Proder_ListAllProductDiscountIds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) ListProductFeeds(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Proder_ListProductFeeds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) CreateProductFeed(ctx context.Context, in *ProductFeed, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Proder_CreateProductFeed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) UpdateProductFeed(ctx context.Context, in *ProductFeed, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Proder_UpdateProductFeed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) DeleteProductFeed(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Proder_DeleteProductFeed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) MatchProductFeeds(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Proder_MatchProductFeeds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) ListProductCategories(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*ProductCategories, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProductCategories)
	err := c.cc.Invoke(ctx, Proder_ListProductCategories_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) ReadOrder(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Order, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Order)
	err := c.cc.Invoke(ctx, Proder_ReadOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) CreateOrder(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Order)
	err := c.cc.Invoke(ctx, Proder_CreateOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) UpdateOrder(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Order)
	err := c.cc.Invoke(ctx, Proder_UpdateOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) DeleteOrder(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Proder_DeleteOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) ListOrders(ctx context.Context, in *OrdersRequest, opts ...grpc.CallOption) (*Orders, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Orders)
	err := c.cc.Invoke(ctx, Proder_ListOrders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) CountOrders2(ctx context.Context, in *CountOrdersRequest, opts ...grpc.CallOption) (*CountOrdersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CountOrdersResponse)
	err := c.cc.Invoke(ctx, Proder_CountOrders2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) ImportOrders(ctx context.Context, in *Orders, opts ...grpc.CallOption) (*Orders, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Orders)
	err := c.cc.Invoke(ctx, Proder_ImportOrders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) MakeOrderPayment(ctx context.Context, in *Bill, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Proder_MakeOrderPayment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) UpdatePurchase(ctx context.Context, in *Bill, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Proder_UpdatePurchase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) CancelPurchase(ctx context.Context, in *Bill, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Proder_CancelPurchase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) AddOrderComment(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Event)
	err := c.cc.Invoke(ctx, Proder_AddOrderComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) EditOrderComment(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Event)
	err := c.cc.Invoke(ctx, Proder_EditOrderComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) DeleteOrderComment(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Event, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Event)
	err := c.cc.Invoke(ctx, Proder_DeleteOrderComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) ListOrderEvents(ctx context.Context, in *Id, opts ...grpc.CallOption) (*OrderHistoryEntries, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OrderHistoryEntries)
	err := c.cc.Invoke(ctx, Proder_ListOrderEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) ListOrderBills(ctx context.Context, in *BillsRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Proder_ListOrderBills_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) DownloadOrder(ctx context.Context, in *DownloadOrderRequest, opts ...grpc.CallOption) (*File, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(File)
	err := c.cc.Invoke(ctx, Proder_DownloadOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) GetShopeeAuthUrl(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Id)
	err := c.cc.Invoke(ctx, Proder_GetShopeeAuthUrl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) AuthorizeShopeeShop(ctx context.Context, in *AuthorizeShopeeRequest, opts ...grpc.CallOption) (*ShopeeShop, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShopeeShop)
	err := c.cc.Invoke(ctx, Proder_AuthorizeShopeeShop_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) DeauthorizeShopeeShop(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Proder_DeauthorizeShopeeShop_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) SyncShopeeProducts(ctx context.Context, in *ShopeeSyncProductRequest, opts ...grpc.CallOption) (*ShopeeSyncProductResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShopeeSyncProductResponse)
	err := c.cc.Invoke(ctx, Proder_SyncShopeeProducts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) GHTKShippingStatus(ctx context.Context, in *GHTKOrder, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Proder_GHTKShippingStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) GHNShippingStatus(ctx context.Context, in *GHNOrder2, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Proder_GHNShippingStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) ShippingFee(ctx context.Context, in *ShippingInfo, opts ...grpc.CallOption) (*ShippingInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShippingInfo)
	err := c.cc.Invoke(ctx, Proder_ShippingFee_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) ShipOrder(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Order, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Order)
	err := c.cc.Invoke(ctx, Proder_ShipOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) UpdateShippingCode(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Order)
	err := c.cc.Invoke(ctx, Proder_UpdateShippingCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) CancelShippingOrder(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Order, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Order)
	err := c.cc.Invoke(ctx, Proder_CancelShippingOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) PrintShippingOrders(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*File, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(File)
	err := c.cc.Invoke(ctx, Proder_PrintShippingOrders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) SeenOrder(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Proder_SeenOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) FollowOrder(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Proder_FollowOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) UnfollowOrder(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Proder_UnfollowOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) TagOrder(ctx context.Context, in *TagRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Proder_TagOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) UntagOrder(ctx context.Context, in *TagRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Proder_UntagOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) ReadPipeline(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Pipeline, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Pipeline)
	err := c.cc.Invoke(ctx, Proder_ReadPipeline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) CreatePipeline(ctx context.Context, in *Pipeline, opts ...grpc.CallOption) (*Pipeline, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Pipeline)
	err := c.cc.Invoke(ctx, Proder_CreatePipeline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) UpdatePipeline(ctx context.Context, in *Pipeline, opts ...grpc.CallOption) (*Pipeline, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Pipeline)
	err := c.cc.Invoke(ctx, Proder_UpdatePipeline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) DeletePipeline(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Proder_DeletePipeline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) ListPipelines(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Pipelines, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Pipelines)
	err := c.cc.Invoke(ctx, Proder_ListPipelines_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) DeletePipelineStage(ctx context.Context, in *PipelineStage, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Proder_DeletePipelineStage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) PreselectPipeline(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Pipeline, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Pipeline)
	err := c.cc.Invoke(ctx, Proder_PreselectPipeline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) ReportOrder(ctx context.Context, in *OrderMetricsRequest, opts ...grpc.CallOption) (*Orders, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Orders)
	err := c.cc.Invoke(ctx, Proder_ReportOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proderClient) MoveOrderToPrimary(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Proder_MoveOrderToPrimary_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProderServer is the server API for Proder service.
// All implementations must embed UnimplementedProderServer
// for forward compatibility.
//
// proder services
type ProderServer interface {
	ReadProduct(context.Context, *Product) (*Product, error)
	CreateProduct(context.Context, *Product) (*Product, error)
	UpdateProduct(context.Context, *Product) (*Product, error)
	DeleteProduct(context.Context, *Id) (*Empty, error)
	ListProducts2(context.Context, *ProductsRequest) (*Response, error)
	ListAllProductIds(context.Context, *ProductsRequest) (*Ids, error)
	ImportProduct(context.Context, *ImportProductRequest) (*ImportProductResponse, error)
	GetProductOffer(context.Context, *Id) (*Response, error)
	CreateProductOffer(context.Context, *ProductOffer) (*Response, error)
	UpdateProductOffer(context.Context, *ProductOffer) (*Response, error)
	DeleteProductOffer(context.Context, *Id) (*Empty, error)
	ListProductOffers(context.Context, *Id) (*Response, error)
	CreateProductFromFile(context.Context, *ConvertProductRequest) (*Response, error)
	ListDiscounts(context.Context, *ListDiscountRequest) (*Response, error)
	CreateDiscount(context.Context, *Discount) (*Response, error)
	GetDiscount(context.Context, *Id) (*Response, error)
	UpdateDiscount(context.Context, *Discount) (*Response, error)
	DeleteDiscount(context.Context, *Id) (*Empty, error)
	MatchDiscounts(context.Context, *Ids) (*Response, error)
	ListAvaiableDiscounts(context.Context, *ListAvaiableDiscountsRequest) (*Response, error)
	ListAllProductDiscountIds(context.Context, *Id) (*Ids, error)
	ListProductFeeds(context.Context, *Id) (*Response, error)
	CreateProductFeed(context.Context, *ProductFeed) (*Response, error)
	UpdateProductFeed(context.Context, *ProductFeed) (*Response, error)
	DeleteProductFeed(context.Context, *Id) (*Empty, error)
	MatchProductFeeds(context.Context, *Ids) (*Response, error)
	ListProductCategories(context.Context, *Ids) (*ProductCategories, error)
	ReadOrder(context.Context, *Id) (*Order, error)
	CreateOrder(context.Context, *Order) (*Order, error)
	UpdateOrder(context.Context, *Order) (*Order, error)
	DeleteOrder(context.Context, *Id) (*Empty, error)
	ListOrders(context.Context, *OrdersRequest) (*Orders, error)
	CountOrders2(context.Context, *CountOrdersRequest) (*CountOrdersResponse, error)
	ImportOrders(context.Context, *Orders) (*Orders, error)
	// fire order_updated, order_event_updated
	MakeOrderPayment(context.Context, *Bill) (*Response, error)
	UpdatePurchase(context.Context, *Bill) (*Response, error)
	CancelPurchase(context.Context, *Bill) (*Response, error)
	AddOrderComment(context.Context, *Event) (*Event, error)
	EditOrderComment(context.Context, *Event) (*Event, error)
	DeleteOrderComment(context.Context, *Key) (*Event, error)
	ListOrderEvents(context.Context, *Id) (*OrderHistoryEntries, error)
	ListOrderBills(context.Context, *BillsRequest) (*Response, error)
	DownloadOrder(context.Context, *DownloadOrderRequest) (*File, error)
	GetShopeeAuthUrl(context.Context, *Id) (*Id, error)
	AuthorizeShopeeShop(context.Context, *AuthorizeShopeeRequest) (*ShopeeShop, error)
	DeauthorizeShopeeShop(context.Context, *Id) (*Empty, error)
	SyncShopeeProducts(context.Context, *ShopeeSyncProductRequest) (*ShopeeSyncProductResponse, error)
	GHTKShippingStatus(context.Context, *GHTKOrder) (*Empty, error)
	GHNShippingStatus(context.Context, *GHNOrder2) (*Empty, error)
	ShippingFee(context.Context, *ShippingInfo) (*ShippingInfo, error)
	ShipOrder(context.Context, *Id) (*Order, error)
	UpdateShippingCode(context.Context, *Order) (*Order, error)
	CancelShippingOrder(context.Context, *Id) (*Order, error)
	PrintShippingOrders(context.Context, *Ids) (*File, error)
	SeenOrder(context.Context, *Id) (*Empty, error)
	FollowOrder(context.Context, *Id) (*Empty, error)
	UnfollowOrder(context.Context, *Id) (*Empty, error)
	TagOrder(context.Context, *TagRequest) (*Empty, error)
	UntagOrder(context.Context, *TagRequest) (*Empty, error)
	ReadPipeline(context.Context, *Id) (*Pipeline, error)
	CreatePipeline(context.Context, *Pipeline) (*Pipeline, error)
	UpdatePipeline(context.Context, *Pipeline) (*Pipeline, error)
	DeletePipeline(context.Context, *Id) (*Empty, error)
	ListPipelines(context.Context, *Ids) (*Pipelines, error)
	DeletePipelineStage(context.Context, *PipelineStage) (*Empty, error)
	PreselectPipeline(context.Context, *Id) (*Pipeline, error)
	ReportOrder(context.Context, *OrderMetricsRequest) (*Orders, error)
	MoveOrderToPrimary(context.Context, *Ids) (*Empty, error)
	mustEmbedUnimplementedProderServer()
}

// UnimplementedProderServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProderServer struct{}

func (UnimplementedProderServer) ReadProduct(context.Context, *Product) (*Product, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadProduct not implemented")
}
func (UnimplementedProderServer) CreateProduct(context.Context, *Product) (*Product, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProduct not implemented")
}
func (UnimplementedProderServer) UpdateProduct(context.Context, *Product) (*Product, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProduct not implemented")
}
func (UnimplementedProderServer) DeleteProduct(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProduct not implemented")
}
func (UnimplementedProderServer) ListProducts2(context.Context, *ProductsRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProducts2 not implemented")
}
func (UnimplementedProderServer) ListAllProductIds(context.Context, *ProductsRequest) (*Ids, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAllProductIds not implemented")
}
func (UnimplementedProderServer) ImportProduct(context.Context, *ImportProductRequest) (*ImportProductResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportProduct not implemented")
}
func (UnimplementedProderServer) GetProductOffer(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProductOffer not implemented")
}
func (UnimplementedProderServer) CreateProductOffer(context.Context, *ProductOffer) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProductOffer not implemented")
}
func (UnimplementedProderServer) UpdateProductOffer(context.Context, *ProductOffer) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProductOffer not implemented")
}
func (UnimplementedProderServer) DeleteProductOffer(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProductOffer not implemented")
}
func (UnimplementedProderServer) ListProductOffers(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProductOffers not implemented")
}
func (UnimplementedProderServer) CreateProductFromFile(context.Context, *ConvertProductRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProductFromFile not implemented")
}
func (UnimplementedProderServer) ListDiscounts(context.Context, *ListDiscountRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDiscounts not implemented")
}
func (UnimplementedProderServer) CreateDiscount(context.Context, *Discount) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDiscount not implemented")
}
func (UnimplementedProderServer) GetDiscount(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDiscount not implemented")
}
func (UnimplementedProderServer) UpdateDiscount(context.Context, *Discount) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDiscount not implemented")
}
func (UnimplementedProderServer) DeleteDiscount(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDiscount not implemented")
}
func (UnimplementedProderServer) MatchDiscounts(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchDiscounts not implemented")
}
func (UnimplementedProderServer) ListAvaiableDiscounts(context.Context, *ListAvaiableDiscountsRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAvaiableDiscounts not implemented")
}
func (UnimplementedProderServer) ListAllProductDiscountIds(context.Context, *Id) (*Ids, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAllProductDiscountIds not implemented")
}
func (UnimplementedProderServer) ListProductFeeds(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProductFeeds not implemented")
}
func (UnimplementedProderServer) CreateProductFeed(context.Context, *ProductFeed) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProductFeed not implemented")
}
func (UnimplementedProderServer) UpdateProductFeed(context.Context, *ProductFeed) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProductFeed not implemented")
}
func (UnimplementedProderServer) DeleteProductFeed(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProductFeed not implemented")
}
func (UnimplementedProderServer) MatchProductFeeds(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchProductFeeds not implemented")
}
func (UnimplementedProderServer) ListProductCategories(context.Context, *Ids) (*ProductCategories, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProductCategories not implemented")
}
func (UnimplementedProderServer) ReadOrder(context.Context, *Id) (*Order, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadOrder not implemented")
}
func (UnimplementedProderServer) CreateOrder(context.Context, *Order) (*Order, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrder not implemented")
}
func (UnimplementedProderServer) UpdateOrder(context.Context, *Order) (*Order, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateOrder not implemented")
}
func (UnimplementedProderServer) DeleteOrder(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteOrder not implemented")
}
func (UnimplementedProderServer) ListOrders(context.Context, *OrdersRequest) (*Orders, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOrders not implemented")
}
func (UnimplementedProderServer) CountOrders2(context.Context, *CountOrdersRequest) (*CountOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountOrders2 not implemented")
}
func (UnimplementedProderServer) ImportOrders(context.Context, *Orders) (*Orders, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportOrders not implemented")
}
func (UnimplementedProderServer) MakeOrderPayment(context.Context, *Bill) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MakeOrderPayment not implemented")
}
func (UnimplementedProderServer) UpdatePurchase(context.Context, *Bill) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePurchase not implemented")
}
func (UnimplementedProderServer) CancelPurchase(context.Context, *Bill) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelPurchase not implemented")
}
func (UnimplementedProderServer) AddOrderComment(context.Context, *Event) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddOrderComment not implemented")
}
func (UnimplementedProderServer) EditOrderComment(context.Context, *Event) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EditOrderComment not implemented")
}
func (UnimplementedProderServer) DeleteOrderComment(context.Context, *Key) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteOrderComment not implemented")
}
func (UnimplementedProderServer) ListOrderEvents(context.Context, *Id) (*OrderHistoryEntries, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOrderEvents not implemented")
}
func (UnimplementedProderServer) ListOrderBills(context.Context, *BillsRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOrderBills not implemented")
}
func (UnimplementedProderServer) DownloadOrder(context.Context, *DownloadOrderRequest) (*File, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadOrder not implemented")
}
func (UnimplementedProderServer) GetShopeeAuthUrl(context.Context, *Id) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetShopeeAuthUrl not implemented")
}
func (UnimplementedProderServer) AuthorizeShopeeShop(context.Context, *AuthorizeShopeeRequest) (*ShopeeShop, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthorizeShopeeShop not implemented")
}
func (UnimplementedProderServer) DeauthorizeShopeeShop(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeauthorizeShopeeShop not implemented")
}
func (UnimplementedProderServer) SyncShopeeProducts(context.Context, *ShopeeSyncProductRequest) (*ShopeeSyncProductResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncShopeeProducts not implemented")
}
func (UnimplementedProderServer) GHTKShippingStatus(context.Context, *GHTKOrder) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GHTKShippingStatus not implemented")
}
func (UnimplementedProderServer) GHNShippingStatus(context.Context, *GHNOrder2) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GHNShippingStatus not implemented")
}
func (UnimplementedProderServer) ShippingFee(context.Context, *ShippingInfo) (*ShippingInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShippingFee not implemented")
}
func (UnimplementedProderServer) ShipOrder(context.Context, *Id) (*Order, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShipOrder not implemented")
}
func (UnimplementedProderServer) UpdateShippingCode(context.Context, *Order) (*Order, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateShippingCode not implemented")
}
func (UnimplementedProderServer) CancelShippingOrder(context.Context, *Id) (*Order, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelShippingOrder not implemented")
}
func (UnimplementedProderServer) PrintShippingOrders(context.Context, *Ids) (*File, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrintShippingOrders not implemented")
}
func (UnimplementedProderServer) SeenOrder(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SeenOrder not implemented")
}
func (UnimplementedProderServer) FollowOrder(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FollowOrder not implemented")
}
func (UnimplementedProderServer) UnfollowOrder(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnfollowOrder not implemented")
}
func (UnimplementedProderServer) TagOrder(context.Context, *TagRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TagOrder not implemented")
}
func (UnimplementedProderServer) UntagOrder(context.Context, *TagRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UntagOrder not implemented")
}
func (UnimplementedProderServer) ReadPipeline(context.Context, *Id) (*Pipeline, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadPipeline not implemented")
}
func (UnimplementedProderServer) CreatePipeline(context.Context, *Pipeline) (*Pipeline, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePipeline not implemented")
}
func (UnimplementedProderServer) UpdatePipeline(context.Context, *Pipeline) (*Pipeline, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePipeline not implemented")
}
func (UnimplementedProderServer) DeletePipeline(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePipeline not implemented")
}
func (UnimplementedProderServer) ListPipelines(context.Context, *Ids) (*Pipelines, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPipelines not implemented")
}
func (UnimplementedProderServer) DeletePipelineStage(context.Context, *PipelineStage) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePipelineStage not implemented")
}
func (UnimplementedProderServer) PreselectPipeline(context.Context, *Id) (*Pipeline, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PreselectPipeline not implemented")
}
func (UnimplementedProderServer) ReportOrder(context.Context, *OrderMetricsRequest) (*Orders, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportOrder not implemented")
}
func (UnimplementedProderServer) MoveOrderToPrimary(context.Context, *Ids) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MoveOrderToPrimary not implemented")
}
func (UnimplementedProderServer) mustEmbedUnimplementedProderServer() {}
func (UnimplementedProderServer) testEmbeddedByValue()                {}

// UnsafeProderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProderServer will
// result in compilation errors.
type UnsafeProderServer interface {
	mustEmbedUnimplementedProderServer()
}

func RegisterProderServer(s grpc.ServiceRegistrar, srv ProderServer) {
	// If the following call pancis, it indicates UnimplementedProderServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Proder_ServiceDesc, srv)
}

func _Proder_ReadProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Product)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).ReadProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_ReadProduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).ReadProduct(ctx, req.(*Product))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_CreateProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Product)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).CreateProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_CreateProduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).CreateProduct(ctx, req.(*Product))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_UpdateProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Product)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).UpdateProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_UpdateProduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).UpdateProduct(ctx, req.(*Product))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_DeleteProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).DeleteProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_DeleteProduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).DeleteProduct(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_ListProducts2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).ListProducts2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_ListProducts2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).ListProducts2(ctx, req.(*ProductsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_ListAllProductIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).ListAllProductIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_ListAllProductIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).ListAllProductIds(ctx, req.(*ProductsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_ImportProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).ImportProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_ImportProduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).ImportProduct(ctx, req.(*ImportProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_GetProductOffer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).GetProductOffer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_GetProductOffer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).GetProductOffer(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_CreateProductOffer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductOffer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).CreateProductOffer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_CreateProductOffer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).CreateProductOffer(ctx, req.(*ProductOffer))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_UpdateProductOffer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductOffer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).UpdateProductOffer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_UpdateProductOffer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).UpdateProductOffer(ctx, req.(*ProductOffer))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_DeleteProductOffer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).DeleteProductOffer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_DeleteProductOffer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).DeleteProductOffer(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_ListProductOffers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).ListProductOffers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_ListProductOffers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).ListProductOffers(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_CreateProductFromFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvertProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).CreateProductFromFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_CreateProductFromFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).CreateProductFromFile(ctx, req.(*ConvertProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_ListDiscounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDiscountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).ListDiscounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_ListDiscounts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).ListDiscounts(ctx, req.(*ListDiscountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_CreateDiscount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Discount)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).CreateDiscount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_CreateDiscount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).CreateDiscount(ctx, req.(*Discount))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_GetDiscount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).GetDiscount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_GetDiscount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).GetDiscount(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_UpdateDiscount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Discount)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).UpdateDiscount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_UpdateDiscount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).UpdateDiscount(ctx, req.(*Discount))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_DeleteDiscount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).DeleteDiscount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_DeleteDiscount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).DeleteDiscount(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_MatchDiscounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).MatchDiscounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_MatchDiscounts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).MatchDiscounts(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_ListAvaiableDiscounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAvaiableDiscountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).ListAvaiableDiscounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_ListAvaiableDiscounts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).ListAvaiableDiscounts(ctx, req.(*ListAvaiableDiscountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_ListAllProductDiscountIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).ListAllProductDiscountIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_ListAllProductDiscountIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).ListAllProductDiscountIds(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_ListProductFeeds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).ListProductFeeds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_ListProductFeeds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).ListProductFeeds(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_CreateProductFeed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductFeed)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).CreateProductFeed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_CreateProductFeed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).CreateProductFeed(ctx, req.(*ProductFeed))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_UpdateProductFeed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductFeed)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).UpdateProductFeed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_UpdateProductFeed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).UpdateProductFeed(ctx, req.(*ProductFeed))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_DeleteProductFeed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).DeleteProductFeed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_DeleteProductFeed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).DeleteProductFeed(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_MatchProductFeeds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).MatchProductFeeds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_MatchProductFeeds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).MatchProductFeeds(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_ListProductCategories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).ListProductCategories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_ListProductCategories_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).ListProductCategories(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_ReadOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).ReadOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_ReadOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).ReadOrder(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_CreateOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Order)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).CreateOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_CreateOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).CreateOrder(ctx, req.(*Order))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_UpdateOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Order)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).UpdateOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_UpdateOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).UpdateOrder(ctx, req.(*Order))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_DeleteOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).DeleteOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_DeleteOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).DeleteOrder(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_ListOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).ListOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_ListOrders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).ListOrders(ctx, req.(*OrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_CountOrders2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).CountOrders2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_CountOrders2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).CountOrders2(ctx, req.(*CountOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_ImportOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Orders)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).ImportOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_ImportOrders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).ImportOrders(ctx, req.(*Orders))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_MakeOrderPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Bill)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).MakeOrderPayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_MakeOrderPayment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).MakeOrderPayment(ctx, req.(*Bill))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_UpdatePurchase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Bill)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).UpdatePurchase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_UpdatePurchase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).UpdatePurchase(ctx, req.(*Bill))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_CancelPurchase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Bill)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).CancelPurchase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_CancelPurchase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).CancelPurchase(ctx, req.(*Bill))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_AddOrderComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).AddOrderComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_AddOrderComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).AddOrderComment(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_EditOrderComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).EditOrderComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_EditOrderComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).EditOrderComment(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_DeleteOrderComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).DeleteOrderComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_DeleteOrderComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).DeleteOrderComment(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_ListOrderEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).ListOrderEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_ListOrderEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).ListOrderEvents(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_ListOrderBills_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BillsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).ListOrderBills(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_ListOrderBills_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).ListOrderBills(ctx, req.(*BillsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_DownloadOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).DownloadOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_DownloadOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).DownloadOrder(ctx, req.(*DownloadOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_GetShopeeAuthUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).GetShopeeAuthUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_GetShopeeAuthUrl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).GetShopeeAuthUrl(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_AuthorizeShopeeShop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthorizeShopeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).AuthorizeShopeeShop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_AuthorizeShopeeShop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).AuthorizeShopeeShop(ctx, req.(*AuthorizeShopeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_DeauthorizeShopeeShop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).DeauthorizeShopeeShop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_DeauthorizeShopeeShop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).DeauthorizeShopeeShop(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_SyncShopeeProducts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShopeeSyncProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).SyncShopeeProducts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_SyncShopeeProducts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).SyncShopeeProducts(ctx, req.(*ShopeeSyncProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_GHTKShippingStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GHTKOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).GHTKShippingStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_GHTKShippingStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).GHTKShippingStatus(ctx, req.(*GHTKOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_GHNShippingStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GHNOrder2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).GHNShippingStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_GHNShippingStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).GHNShippingStatus(ctx, req.(*GHNOrder2))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_ShippingFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShippingInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).ShippingFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_ShippingFee_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).ShippingFee(ctx, req.(*ShippingInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_ShipOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).ShipOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_ShipOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).ShipOrder(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_UpdateShippingCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Order)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).UpdateShippingCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_UpdateShippingCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).UpdateShippingCode(ctx, req.(*Order))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_CancelShippingOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).CancelShippingOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_CancelShippingOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).CancelShippingOrder(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_PrintShippingOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).PrintShippingOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_PrintShippingOrders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).PrintShippingOrders(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_SeenOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).SeenOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_SeenOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).SeenOrder(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_FollowOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).FollowOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_FollowOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).FollowOrder(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_UnfollowOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).UnfollowOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_UnfollowOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).UnfollowOrder(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_TagOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).TagOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_TagOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).TagOrder(ctx, req.(*TagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_UntagOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).UntagOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_UntagOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).UntagOrder(ctx, req.(*TagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_ReadPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).ReadPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_ReadPipeline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).ReadPipeline(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_CreatePipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pipeline)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).CreatePipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_CreatePipeline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).CreatePipeline(ctx, req.(*Pipeline))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_UpdatePipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pipeline)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).UpdatePipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_UpdatePipeline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).UpdatePipeline(ctx, req.(*Pipeline))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_DeletePipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).DeletePipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_DeletePipeline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).DeletePipeline(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_ListPipelines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).ListPipelines(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_ListPipelines_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).ListPipelines(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_DeletePipelineStage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PipelineStage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).DeletePipelineStage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_DeletePipelineStage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).DeletePipelineStage(ctx, req.(*PipelineStage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_PreselectPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).PreselectPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_PreselectPipeline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).PreselectPipeline(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_ReportOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).ReportOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_ReportOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).ReportOrder(ctx, req.(*OrderMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proder_MoveOrderToPrimary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProderServer).MoveOrderToPrimary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proder_MoveOrderToPrimary_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProderServer).MoveOrderToPrimary(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

// Proder_ServiceDesc is the grpc.ServiceDesc for Proder service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Proder_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.Proder",
	HandlerType: (*ProderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadProduct",
			Handler:    _Proder_ReadProduct_Handler,
		},
		{
			MethodName: "CreateProduct",
			Handler:    _Proder_CreateProduct_Handler,
		},
		{
			MethodName: "UpdateProduct",
			Handler:    _Proder_UpdateProduct_Handler,
		},
		{
			MethodName: "DeleteProduct",
			Handler:    _Proder_DeleteProduct_Handler,
		},
		{
			MethodName: "ListProducts2",
			Handler:    _Proder_ListProducts2_Handler,
		},
		{
			MethodName: "ListAllProductIds",
			Handler:    _Proder_ListAllProductIds_Handler,
		},
		{
			MethodName: "ImportProduct",
			Handler:    _Proder_ImportProduct_Handler,
		},
		{
			MethodName: "GetProductOffer",
			Handler:    _Proder_GetProductOffer_Handler,
		},
		{
			MethodName: "CreateProductOffer",
			Handler:    _Proder_CreateProductOffer_Handler,
		},
		{
			MethodName: "UpdateProductOffer",
			Handler:    _Proder_UpdateProductOffer_Handler,
		},
		{
			MethodName: "DeleteProductOffer",
			Handler:    _Proder_DeleteProductOffer_Handler,
		},
		{
			MethodName: "ListProductOffers",
			Handler:    _Proder_ListProductOffers_Handler,
		},
		{
			MethodName: "CreateProductFromFile",
			Handler:    _Proder_CreateProductFromFile_Handler,
		},
		{
			MethodName: "ListDiscounts",
			Handler:    _Proder_ListDiscounts_Handler,
		},
		{
			MethodName: "CreateDiscount",
			Handler:    _Proder_CreateDiscount_Handler,
		},
		{
			MethodName: "GetDiscount",
			Handler:    _Proder_GetDiscount_Handler,
		},
		{
			MethodName: "UpdateDiscount",
			Handler:    _Proder_UpdateDiscount_Handler,
		},
		{
			MethodName: "DeleteDiscount",
			Handler:    _Proder_DeleteDiscount_Handler,
		},
		{
			MethodName: "MatchDiscounts",
			Handler:    _Proder_MatchDiscounts_Handler,
		},
		{
			MethodName: "ListAvaiableDiscounts",
			Handler:    _Proder_ListAvaiableDiscounts_Handler,
		},
		{
			MethodName: "ListAllProductDiscountIds",
			Handler:    _Proder_ListAllProductDiscountIds_Handler,
		},
		{
			MethodName: "ListProductFeeds",
			Handler:    _Proder_ListProductFeeds_Handler,
		},
		{
			MethodName: "CreateProductFeed",
			Handler:    _Proder_CreateProductFeed_Handler,
		},
		{
			MethodName: "UpdateProductFeed",
			Handler:    _Proder_UpdateProductFeed_Handler,
		},
		{
			MethodName: "DeleteProductFeed",
			Handler:    _Proder_DeleteProductFeed_Handler,
		},
		{
			MethodName: "MatchProductFeeds",
			Handler:    _Proder_MatchProductFeeds_Handler,
		},
		{
			MethodName: "ListProductCategories",
			Handler:    _Proder_ListProductCategories_Handler,
		},
		{
			MethodName: "ReadOrder",
			Handler:    _Proder_ReadOrder_Handler,
		},
		{
			MethodName: "CreateOrder",
			Handler:    _Proder_CreateOrder_Handler,
		},
		{
			MethodName: "UpdateOrder",
			Handler:    _Proder_UpdateOrder_Handler,
		},
		{
			MethodName: "DeleteOrder",
			Handler:    _Proder_DeleteOrder_Handler,
		},
		{
			MethodName: "ListOrders",
			Handler:    _Proder_ListOrders_Handler,
		},
		{
			MethodName: "CountOrders2",
			Handler:    _Proder_CountOrders2_Handler,
		},
		{
			MethodName: "ImportOrders",
			Handler:    _Proder_ImportOrders_Handler,
		},
		{
			MethodName: "MakeOrderPayment",
			Handler:    _Proder_MakeOrderPayment_Handler,
		},
		{
			MethodName: "UpdatePurchase",
			Handler:    _Proder_UpdatePurchase_Handler,
		},
		{
			MethodName: "CancelPurchase",
			Handler:    _Proder_CancelPurchase_Handler,
		},
		{
			MethodName: "AddOrderComment",
			Handler:    _Proder_AddOrderComment_Handler,
		},
		{
			MethodName: "EditOrderComment",
			Handler:    _Proder_EditOrderComment_Handler,
		},
		{
			MethodName: "DeleteOrderComment",
			Handler:    _Proder_DeleteOrderComment_Handler,
		},
		{
			MethodName: "ListOrderEvents",
			Handler:    _Proder_ListOrderEvents_Handler,
		},
		{
			MethodName: "ListOrderBills",
			Handler:    _Proder_ListOrderBills_Handler,
		},
		{
			MethodName: "DownloadOrder",
			Handler:    _Proder_DownloadOrder_Handler,
		},
		{
			MethodName: "GetShopeeAuthUrl",
			Handler:    _Proder_GetShopeeAuthUrl_Handler,
		},
		{
			MethodName: "AuthorizeShopeeShop",
			Handler:    _Proder_AuthorizeShopeeShop_Handler,
		},
		{
			MethodName: "DeauthorizeShopeeShop",
			Handler:    _Proder_DeauthorizeShopeeShop_Handler,
		},
		{
			MethodName: "SyncShopeeProducts",
			Handler:    _Proder_SyncShopeeProducts_Handler,
		},
		{
			MethodName: "GHTKShippingStatus",
			Handler:    _Proder_GHTKShippingStatus_Handler,
		},
		{
			MethodName: "GHNShippingStatus",
			Handler:    _Proder_GHNShippingStatus_Handler,
		},
		{
			MethodName: "ShippingFee",
			Handler:    _Proder_ShippingFee_Handler,
		},
		{
			MethodName: "ShipOrder",
			Handler:    _Proder_ShipOrder_Handler,
		},
		{
			MethodName: "UpdateShippingCode",
			Handler:    _Proder_UpdateShippingCode_Handler,
		},
		{
			MethodName: "CancelShippingOrder",
			Handler:    _Proder_CancelShippingOrder_Handler,
		},
		{
			MethodName: "PrintShippingOrders",
			Handler:    _Proder_PrintShippingOrders_Handler,
		},
		{
			MethodName: "SeenOrder",
			Handler:    _Proder_SeenOrder_Handler,
		},
		{
			MethodName: "FollowOrder",
			Handler:    _Proder_FollowOrder_Handler,
		},
		{
			MethodName: "UnfollowOrder",
			Handler:    _Proder_UnfollowOrder_Handler,
		},
		{
			MethodName: "TagOrder",
			Handler:    _Proder_TagOrder_Handler,
		},
		{
			MethodName: "UntagOrder",
			Handler:    _Proder_UntagOrder_Handler,
		},
		{
			MethodName: "ReadPipeline",
			Handler:    _Proder_ReadPipeline_Handler,
		},
		{
			MethodName: "CreatePipeline",
			Handler:    _Proder_CreatePipeline_Handler,
		},
		{
			MethodName: "UpdatePipeline",
			Handler:    _Proder_UpdatePipeline_Handler,
		},
		{
			MethodName: "DeletePipeline",
			Handler:    _Proder_DeletePipeline_Handler,
		},
		{
			MethodName: "ListPipelines",
			Handler:    _Proder_ListPipelines_Handler,
		},
		{
			MethodName: "DeletePipelineStage",
			Handler:    _Proder_DeletePipelineStage_Handler,
		},
		{
			MethodName: "PreselectPipeline",
			Handler:    _Proder_PreselectPipeline_Handler,
		},
		{
			MethodName: "ReportOrder",
			Handler:    _Proder_ReportOrder_Handler,
		},
		{
			MethodName: "MoveOrderToPrimary",
			Handler:    _Proder_MoveOrderToPrimary_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	TaskMgr_ReadTask_FullMethodName          = "/header.TaskMgr/ReadTask"
	TaskMgr_CreateTask_FullMethodName        = "/header.TaskMgr/CreateTask"
	TaskMgr_UpdateTask_FullMethodName        = "/header.TaskMgr/UpdateTask"
	TaskMgr_DeleteTask_FullMethodName        = "/header.TaskMgr/DeleteTask"
	TaskMgr_ListTasks_FullMethodName         = "/header.TaskMgr/ListTasks"
	TaskMgr_SeenTask_FullMethodName          = "/header.TaskMgr/SeenTask"
	TaskMgr_CloseTaskReminder_FullMethodName = "/header.TaskMgr/CloseTaskReminder"
	TaskMgr_MuteTask_FullMethodName          = "/header.TaskMgr/MuteTask"
	TaskMgr_UnmuteTask_FullMethodName        = "/header.TaskMgr/UnmuteTask"
	TaskMgr_AddTaskComment_FullMethodName    = "/header.TaskMgr/AddTaskComment"
	TaskMgr_EditTaskComment_FullMethodName   = "/header.TaskMgr/EditTaskComment"
	TaskMgr_DeleteTaskComment_FullMethodName = "/header.TaskMgr/DeleteTaskComment"
	TaskMgr_ListTaskComments_FullMethodName  = "/header.TaskMgr/ListTaskComments"
)

// TaskMgrClient is the client API for TaskMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TaskMgrClient interface {
	ReadTask(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Task, error)
	CreateTask(ctx context.Context, in *Task, opts ...grpc.CallOption) (*Task, error)
	UpdateTask(ctx context.Context, in *Task, opts ...grpc.CallOption) (*Task, error)
	DeleteTask(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ListTasks(ctx context.Context, in *TasksRequest, opts ...grpc.CallOption) (*Tasks, error)
	SeenTask(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	CloseTaskReminder(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	MuteTask(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	UnmuteTask(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	AddTaskComment(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error)
	EditTaskComment(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error)
	DeleteTaskComment(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Event, error)
	ListTaskComments(ctx context.Context, in *Id, opts ...grpc.CallOption) (*TaskHistoryEntries, error)
}

type taskMgrClient struct {
	cc grpc.ClientConnInterface
}

func NewTaskMgrClient(cc grpc.ClientConnInterface) TaskMgrClient {
	return &taskMgrClient{cc}
}

func (c *taskMgrClient) ReadTask(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Task, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Task)
	err := c.cc.Invoke(ctx, TaskMgr_ReadTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskMgrClient) CreateTask(ctx context.Context, in *Task, opts ...grpc.CallOption) (*Task, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Task)
	err := c.cc.Invoke(ctx, TaskMgr_CreateTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskMgrClient) UpdateTask(ctx context.Context, in *Task, opts ...grpc.CallOption) (*Task, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Task)
	err := c.cc.Invoke(ctx, TaskMgr_UpdateTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskMgrClient) DeleteTask(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TaskMgr_DeleteTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskMgrClient) ListTasks(ctx context.Context, in *TasksRequest, opts ...grpc.CallOption) (*Tasks, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Tasks)
	err := c.cc.Invoke(ctx, TaskMgr_ListTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskMgrClient) SeenTask(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TaskMgr_SeenTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskMgrClient) CloseTaskReminder(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TaskMgr_CloseTaskReminder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskMgrClient) MuteTask(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TaskMgr_MuteTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskMgrClient) UnmuteTask(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TaskMgr_UnmuteTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskMgrClient) AddTaskComment(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Event)
	err := c.cc.Invoke(ctx, TaskMgr_AddTaskComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskMgrClient) EditTaskComment(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Event)
	err := c.cc.Invoke(ctx, TaskMgr_EditTaskComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskMgrClient) DeleteTaskComment(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Event, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Event)
	err := c.cc.Invoke(ctx, TaskMgr_DeleteTaskComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskMgrClient) ListTaskComments(ctx context.Context, in *Id, opts ...grpc.CallOption) (*TaskHistoryEntries, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskHistoryEntries)
	err := c.cc.Invoke(ctx, TaskMgr_ListTaskComments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TaskMgrServer is the server API for TaskMgr service.
// All implementations must embed UnimplementedTaskMgrServer
// for forward compatibility.
type TaskMgrServer interface {
	ReadTask(context.Context, *Id) (*Task, error)
	CreateTask(context.Context, *Task) (*Task, error)
	UpdateTask(context.Context, *Task) (*Task, error)
	DeleteTask(context.Context, *Id) (*Empty, error)
	ListTasks(context.Context, *TasksRequest) (*Tasks, error)
	SeenTask(context.Context, *Id) (*Empty, error)
	CloseTaskReminder(context.Context, *Id) (*Empty, error)
	MuteTask(context.Context, *Id) (*Empty, error)
	UnmuteTask(context.Context, *Id) (*Empty, error)
	AddTaskComment(context.Context, *Event) (*Event, error)
	EditTaskComment(context.Context, *Event) (*Event, error)
	DeleteTaskComment(context.Context, *Key) (*Event, error)
	ListTaskComments(context.Context, *Id) (*TaskHistoryEntries, error)
	mustEmbedUnimplementedTaskMgrServer()
}

// UnimplementedTaskMgrServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTaskMgrServer struct{}

func (UnimplementedTaskMgrServer) ReadTask(context.Context, *Id) (*Task, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadTask not implemented")
}
func (UnimplementedTaskMgrServer) CreateTask(context.Context, *Task) (*Task, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTask not implemented")
}
func (UnimplementedTaskMgrServer) UpdateTask(context.Context, *Task) (*Task, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTask not implemented")
}
func (UnimplementedTaskMgrServer) DeleteTask(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTask not implemented")
}
func (UnimplementedTaskMgrServer) ListTasks(context.Context, *TasksRequest) (*Tasks, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTasks not implemented")
}
func (UnimplementedTaskMgrServer) SeenTask(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SeenTask not implemented")
}
func (UnimplementedTaskMgrServer) CloseTaskReminder(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseTaskReminder not implemented")
}
func (UnimplementedTaskMgrServer) MuteTask(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MuteTask not implemented")
}
func (UnimplementedTaskMgrServer) UnmuteTask(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnmuteTask not implemented")
}
func (UnimplementedTaskMgrServer) AddTaskComment(context.Context, *Event) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTaskComment not implemented")
}
func (UnimplementedTaskMgrServer) EditTaskComment(context.Context, *Event) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EditTaskComment not implemented")
}
func (UnimplementedTaskMgrServer) DeleteTaskComment(context.Context, *Key) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTaskComment not implemented")
}
func (UnimplementedTaskMgrServer) ListTaskComments(context.Context, *Id) (*TaskHistoryEntries, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTaskComments not implemented")
}
func (UnimplementedTaskMgrServer) mustEmbedUnimplementedTaskMgrServer() {}
func (UnimplementedTaskMgrServer) testEmbeddedByValue()                 {}

// UnsafeTaskMgrServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TaskMgrServer will
// result in compilation errors.
type UnsafeTaskMgrServer interface {
	mustEmbedUnimplementedTaskMgrServer()
}

func RegisterTaskMgrServer(s grpc.ServiceRegistrar, srv TaskMgrServer) {
	// If the following call pancis, it indicates UnimplementedTaskMgrServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TaskMgr_ServiceDesc, srv)
}

func _TaskMgr_ReadTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskMgrServer).ReadTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskMgr_ReadTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskMgrServer).ReadTask(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskMgr_CreateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Task)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskMgrServer).CreateTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskMgr_CreateTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskMgrServer).CreateTask(ctx, req.(*Task))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskMgr_UpdateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Task)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskMgrServer).UpdateTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskMgr_UpdateTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskMgrServer).UpdateTask(ctx, req.(*Task))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskMgr_DeleteTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskMgrServer).DeleteTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskMgr_DeleteTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskMgrServer).DeleteTask(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskMgr_ListTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskMgrServer).ListTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskMgr_ListTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskMgrServer).ListTasks(ctx, req.(*TasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskMgr_SeenTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskMgrServer).SeenTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskMgr_SeenTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskMgrServer).SeenTask(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskMgr_CloseTaskReminder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskMgrServer).CloseTaskReminder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskMgr_CloseTaskReminder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskMgrServer).CloseTaskReminder(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskMgr_MuteTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskMgrServer).MuteTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskMgr_MuteTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskMgrServer).MuteTask(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskMgr_UnmuteTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskMgrServer).UnmuteTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskMgr_UnmuteTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskMgrServer).UnmuteTask(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskMgr_AddTaskComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskMgrServer).AddTaskComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskMgr_AddTaskComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskMgrServer).AddTaskComment(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskMgr_EditTaskComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskMgrServer).EditTaskComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskMgr_EditTaskComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskMgrServer).EditTaskComment(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskMgr_DeleteTaskComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskMgrServer).DeleteTaskComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskMgr_DeleteTaskComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskMgrServer).DeleteTaskComment(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskMgr_ListTaskComments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskMgrServer).ListTaskComments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskMgr_ListTaskComments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskMgrServer).ListTaskComments(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

// TaskMgr_ServiceDesc is the grpc.ServiceDesc for TaskMgr service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TaskMgr_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.TaskMgr",
	HandlerType: (*TaskMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadTask",
			Handler:    _TaskMgr_ReadTask_Handler,
		},
		{
			MethodName: "CreateTask",
			Handler:    _TaskMgr_CreateTask_Handler,
		},
		{
			MethodName: "UpdateTask",
			Handler:    _TaskMgr_UpdateTask_Handler,
		},
		{
			MethodName: "DeleteTask",
			Handler:    _TaskMgr_DeleteTask_Handler,
		},
		{
			MethodName: "ListTasks",
			Handler:    _TaskMgr_ListTasks_Handler,
		},
		{
			MethodName: "SeenTask",
			Handler:    _TaskMgr_SeenTask_Handler,
		},
		{
			MethodName: "CloseTaskReminder",
			Handler:    _TaskMgr_CloseTaskReminder_Handler,
		},
		{
			MethodName: "MuteTask",
			Handler:    _TaskMgr_MuteTask_Handler,
		},
		{
			MethodName: "UnmuteTask",
			Handler:    _TaskMgr_UnmuteTask_Handler,
		},
		{
			MethodName: "AddTaskComment",
			Handler:    _TaskMgr_AddTaskComment_Handler,
		},
		{
			MethodName: "EditTaskComment",
			Handler:    _TaskMgr_EditTaskComment_Handler,
		},
		{
			MethodName: "DeleteTaskComment",
			Handler:    _TaskMgr_DeleteTaskComment_Handler,
		},
		{
			MethodName: "ListTaskComments",
			Handler:    _TaskMgr_ListTaskComments_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	Speex_TextToSpeech_FullMethodName = "/header.Speex/TextToSpeech"
)

// SpeexClient is the client API for Speex service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SpeexClient interface {
	TextToSpeech(ctx context.Context, in *TTSVoiceSelection, opts ...grpc.CallOption) (*TTSVoiceSelection, error)
}

type speexClient struct {
	cc grpc.ClientConnInterface
}

func NewSpeexClient(cc grpc.ClientConnInterface) SpeexClient {
	return &speexClient{cc}
}

func (c *speexClient) TextToSpeech(ctx context.Context, in *TTSVoiceSelection, opts ...grpc.CallOption) (*TTSVoiceSelection, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TTSVoiceSelection)
	err := c.cc.Invoke(ctx, Speex_TextToSpeech_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SpeexServer is the server API for Speex service.
// All implementations must embed UnimplementedSpeexServer
// for forward compatibility.
type SpeexServer interface {
	TextToSpeech(context.Context, *TTSVoiceSelection) (*TTSVoiceSelection, error)
	mustEmbedUnimplementedSpeexServer()
}

// UnimplementedSpeexServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSpeexServer struct{}

func (UnimplementedSpeexServer) TextToSpeech(context.Context, *TTSVoiceSelection) (*TTSVoiceSelection, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TextToSpeech not implemented")
}
func (UnimplementedSpeexServer) mustEmbedUnimplementedSpeexServer() {}
func (UnimplementedSpeexServer) testEmbeddedByValue()               {}

// UnsafeSpeexServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SpeexServer will
// result in compilation errors.
type UnsafeSpeexServer interface {
	mustEmbedUnimplementedSpeexServer()
}

func RegisterSpeexServer(s grpc.ServiceRegistrar, srv SpeexServer) {
	// If the following call pancis, it indicates UnimplementedSpeexServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Speex_ServiceDesc, srv)
}

func _Speex_TextToSpeech_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TTSVoiceSelection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpeexServer).TextToSpeech(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Speex_TextToSpeech_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpeexServer).TextToSpeech(ctx, req.(*TTSVoiceSelection))
	}
	return interceptor(ctx, in, info, handler)
}

// Speex_ServiceDesc is the grpc.ServiceDesc for Speex service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Speex_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.Speex",
	HandlerType: (*SpeexServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TextToSpeech",
			Handler:    _Speex_TextToSpeech_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	CampaignMgr_ListCampaigns_FullMethodName           = "/header.CampaignMgr/ListCampaigns"
	CampaignMgr_ReadCampaign_FullMethodName            = "/header.CampaignMgr/ReadCampaign"
	CampaignMgr_CreateCampaign_FullMethodName          = "/header.CampaignMgr/CreateCampaign"
	CampaignMgr_UpdateCampaign_FullMethodName          = "/header.CampaignMgr/UpdateCampaign"
	CampaignMgr_MatchCampaigns_FullMethodName          = "/header.CampaignMgr/MatchCampaigns"
	CampaignMgr_DeleteCampaign_FullMethodName          = "/header.CampaignMgr/DeleteCampaign"
	CampaignMgr_OnEvent_FullMethodName                 = "/header.CampaignMgr/OnEvent"
	CampaignMgr_ListCampaignSendLog_FullMethodName     = "/header.CampaignMgr/ListCampaignSendLog"
	CampaignMgr_ReportBroadcastCampaign_FullMethodName = "/header.CampaignMgr/ReportBroadcastCampaign"
	CampaignMgr_ListOutboundCallEntries_FullMethodName = "/header.CampaignMgr/ListOutboundCallEntries"
	CampaignMgr_UpdateOutboundCall_FullMethodName      = "/header.CampaignMgr/UpdateOutboundCall"
	CampaignMgr_ImportOutboundCall_FullMethodName      = "/header.CampaignMgr/ImportOutboundCall"
	CampaignMgr_GetOutboundCall_FullMethodName         = "/header.CampaignMgr/GetOutboundCall"
	CampaignMgr_RemoveOutboudCall_FullMethodName       = "/header.CampaignMgr/RemoveOutboudCall"
	CampaignMgr_ReportOutboundCalls_FullMethodName     = "/header.CampaignMgr/ReportOutboundCalls"
	CampaignMgr_ReassignOutboundCall_FullMethodName    = "/header.CampaignMgr/ReassignOutboundCall"
	CampaignMgr_SendTestMessage_FullMethodName         = "/header.CampaignMgr/SendTestMessage"
)

// CampaignMgrClient is the client API for CampaignMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CampaignMgrClient interface {
	ListCampaigns(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
	ReadCampaign(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	CreateCampaign(ctx context.Context, in *Campaign, opts ...grpc.CallOption) (*Response, error)
	UpdateCampaign(ctx context.Context, in *Campaign, opts ...grpc.CallOption) (*Response, error)
	MatchCampaigns(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
	DeleteCampaign(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	OnEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Empty, error)
	ListCampaignSendLog(ctx context.Context, in *CampaignSendLogRequest, opts ...grpc.CallOption) (*CampaignSendLog, error)
	ReportBroadcastCampaign(ctx context.Context, in *Id, opts ...grpc.CallOption) (*BroadcastCampaignMetrics, error)
	ListOutboundCallEntries(ctx context.Context, in *ListOutboundCallRequest, opts ...grpc.CallOption) (*OutboundCallEntries, error)
	UpdateOutboundCall(ctx context.Context, in *OutboundCallEntry, opts ...grpc.CallOption) (*OutboundCallEntry, error)
	ImportOutboundCall(ctx context.Context, in *ImportOutboundCallEntryRequest, opts ...grpc.CallOption) (*ImportOutboundCallEntryResponse, error)
	GetOutboundCall(ctx context.Context, in *OutboundCallEntry, opts ...grpc.CallOption) (*OutboundCallEntry, error)
	RemoveOutboudCall(ctx context.Context, in *OutboundCallEntry, opts ...grpc.CallOption) (*Empty, error)
	ReportOutboundCalls(ctx context.Context, in *OutboundCallReportRequest, opts ...grpc.CallOption) (*OutboundCallReportResponse, error)
	ReassignOutboundCall(ctx context.Context, in *ListOutboundCallRequest, opts ...grpc.CallOption) (*Empty, error)
	SendTestMessage(ctx context.Context, in *TestMessageRequest, opts ...grpc.CallOption) (*Response, error)
}

type campaignMgrClient struct {
	cc grpc.ClientConnInterface
}

func NewCampaignMgrClient(cc grpc.ClientConnInterface) CampaignMgrClient {
	return &campaignMgrClient{cc}
}

func (c *campaignMgrClient) ListCampaigns(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, CampaignMgr_ListCampaigns_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *campaignMgrClient) ReadCampaign(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, CampaignMgr_ReadCampaign_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *campaignMgrClient) CreateCampaign(ctx context.Context, in *Campaign, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, CampaignMgr_CreateCampaign_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *campaignMgrClient) UpdateCampaign(ctx context.Context, in *Campaign, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, CampaignMgr_UpdateCampaign_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *campaignMgrClient) MatchCampaigns(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, CampaignMgr_MatchCampaigns_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *campaignMgrClient) DeleteCampaign(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, CampaignMgr_DeleteCampaign_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *campaignMgrClient) OnEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, CampaignMgr_OnEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *campaignMgrClient) ListCampaignSendLog(ctx context.Context, in *CampaignSendLogRequest, opts ...grpc.CallOption) (*CampaignSendLog, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CampaignSendLog)
	err := c.cc.Invoke(ctx, CampaignMgr_ListCampaignSendLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *campaignMgrClient) ReportBroadcastCampaign(ctx context.Context, in *Id, opts ...grpc.CallOption) (*BroadcastCampaignMetrics, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BroadcastCampaignMetrics)
	err := c.cc.Invoke(ctx, CampaignMgr_ReportBroadcastCampaign_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *campaignMgrClient) ListOutboundCallEntries(ctx context.Context, in *ListOutboundCallRequest, opts ...grpc.CallOption) (*OutboundCallEntries, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OutboundCallEntries)
	err := c.cc.Invoke(ctx, CampaignMgr_ListOutboundCallEntries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *campaignMgrClient) UpdateOutboundCall(ctx context.Context, in *OutboundCallEntry, opts ...grpc.CallOption) (*OutboundCallEntry, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OutboundCallEntry)
	err := c.cc.Invoke(ctx, CampaignMgr_UpdateOutboundCall_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *campaignMgrClient) ImportOutboundCall(ctx context.Context, in *ImportOutboundCallEntryRequest, opts ...grpc.CallOption) (*ImportOutboundCallEntryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportOutboundCallEntryResponse)
	err := c.cc.Invoke(ctx, CampaignMgr_ImportOutboundCall_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *campaignMgrClient) GetOutboundCall(ctx context.Context, in *OutboundCallEntry, opts ...grpc.CallOption) (*OutboundCallEntry, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OutboundCallEntry)
	err := c.cc.Invoke(ctx, CampaignMgr_GetOutboundCall_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *campaignMgrClient) RemoveOutboudCall(ctx context.Context, in *OutboundCallEntry, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, CampaignMgr_RemoveOutboudCall_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *campaignMgrClient) ReportOutboundCalls(ctx context.Context, in *OutboundCallReportRequest, opts ...grpc.CallOption) (*OutboundCallReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OutboundCallReportResponse)
	err := c.cc.Invoke(ctx, CampaignMgr_ReportOutboundCalls_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *campaignMgrClient) ReassignOutboundCall(ctx context.Context, in *ListOutboundCallRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, CampaignMgr_ReassignOutboundCall_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *campaignMgrClient) SendTestMessage(ctx context.Context, in *TestMessageRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, CampaignMgr_SendTestMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CampaignMgrServer is the server API for CampaignMgr service.
// All implementations must embed UnimplementedCampaignMgrServer
// for forward compatibility.
type CampaignMgrServer interface {
	ListCampaigns(context.Context, *Ids) (*Response, error)
	ReadCampaign(context.Context, *Id) (*Response, error)
	CreateCampaign(context.Context, *Campaign) (*Response, error)
	UpdateCampaign(context.Context, *Campaign) (*Response, error)
	MatchCampaigns(context.Context, *Ids) (*Response, error)
	DeleteCampaign(context.Context, *Id) (*Empty, error)
	OnEvent(context.Context, *Event) (*Empty, error)
	ListCampaignSendLog(context.Context, *CampaignSendLogRequest) (*CampaignSendLog, error)
	ReportBroadcastCampaign(context.Context, *Id) (*BroadcastCampaignMetrics, error)
	ListOutboundCallEntries(context.Context, *ListOutboundCallRequest) (*OutboundCallEntries, error)
	UpdateOutboundCall(context.Context, *OutboundCallEntry) (*OutboundCallEntry, error)
	ImportOutboundCall(context.Context, *ImportOutboundCallEntryRequest) (*ImportOutboundCallEntryResponse, error)
	GetOutboundCall(context.Context, *OutboundCallEntry) (*OutboundCallEntry, error)
	RemoveOutboudCall(context.Context, *OutboundCallEntry) (*Empty, error)
	ReportOutboundCalls(context.Context, *OutboundCallReportRequest) (*OutboundCallReportResponse, error)
	ReassignOutboundCall(context.Context, *ListOutboundCallRequest) (*Empty, error)
	SendTestMessage(context.Context, *TestMessageRequest) (*Response, error)
	mustEmbedUnimplementedCampaignMgrServer()
}

// UnimplementedCampaignMgrServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCampaignMgrServer struct{}

func (UnimplementedCampaignMgrServer) ListCampaigns(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCampaigns not implemented")
}
func (UnimplementedCampaignMgrServer) ReadCampaign(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadCampaign not implemented")
}
func (UnimplementedCampaignMgrServer) CreateCampaign(context.Context, *Campaign) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCampaign not implemented")
}
func (UnimplementedCampaignMgrServer) UpdateCampaign(context.Context, *Campaign) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCampaign not implemented")
}
func (UnimplementedCampaignMgrServer) MatchCampaigns(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchCampaigns not implemented")
}
func (UnimplementedCampaignMgrServer) DeleteCampaign(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCampaign not implemented")
}
func (UnimplementedCampaignMgrServer) OnEvent(context.Context, *Event) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnEvent not implemented")
}
func (UnimplementedCampaignMgrServer) ListCampaignSendLog(context.Context, *CampaignSendLogRequest) (*CampaignSendLog, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCampaignSendLog not implemented")
}
func (UnimplementedCampaignMgrServer) ReportBroadcastCampaign(context.Context, *Id) (*BroadcastCampaignMetrics, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportBroadcastCampaign not implemented")
}
func (UnimplementedCampaignMgrServer) ListOutboundCallEntries(context.Context, *ListOutboundCallRequest) (*OutboundCallEntries, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOutboundCallEntries not implemented")
}
func (UnimplementedCampaignMgrServer) UpdateOutboundCall(context.Context, *OutboundCallEntry) (*OutboundCallEntry, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateOutboundCall not implemented")
}
func (UnimplementedCampaignMgrServer) ImportOutboundCall(context.Context, *ImportOutboundCallEntryRequest) (*ImportOutboundCallEntryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportOutboundCall not implemented")
}
func (UnimplementedCampaignMgrServer) GetOutboundCall(context.Context, *OutboundCallEntry) (*OutboundCallEntry, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOutboundCall not implemented")
}
func (UnimplementedCampaignMgrServer) RemoveOutboudCall(context.Context, *OutboundCallEntry) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveOutboudCall not implemented")
}
func (UnimplementedCampaignMgrServer) ReportOutboundCalls(context.Context, *OutboundCallReportRequest) (*OutboundCallReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportOutboundCalls not implemented")
}
func (UnimplementedCampaignMgrServer) ReassignOutboundCall(context.Context, *ListOutboundCallRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReassignOutboundCall not implemented")
}
func (UnimplementedCampaignMgrServer) SendTestMessage(context.Context, *TestMessageRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendTestMessage not implemented")
}
func (UnimplementedCampaignMgrServer) mustEmbedUnimplementedCampaignMgrServer() {}
func (UnimplementedCampaignMgrServer) testEmbeddedByValue()                     {}

// UnsafeCampaignMgrServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CampaignMgrServer will
// result in compilation errors.
type UnsafeCampaignMgrServer interface {
	mustEmbedUnimplementedCampaignMgrServer()
}

func RegisterCampaignMgrServer(s grpc.ServiceRegistrar, srv CampaignMgrServer) {
	// If the following call pancis, it indicates UnimplementedCampaignMgrServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CampaignMgr_ServiceDesc, srv)
}

func _CampaignMgr_ListCampaigns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CampaignMgrServer).ListCampaigns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CampaignMgr_ListCampaigns_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CampaignMgrServer).ListCampaigns(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _CampaignMgr_ReadCampaign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CampaignMgrServer).ReadCampaign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CampaignMgr_ReadCampaign_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CampaignMgrServer).ReadCampaign(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _CampaignMgr_CreateCampaign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Campaign)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CampaignMgrServer).CreateCampaign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CampaignMgr_CreateCampaign_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CampaignMgrServer).CreateCampaign(ctx, req.(*Campaign))
	}
	return interceptor(ctx, in, info, handler)
}

func _CampaignMgr_UpdateCampaign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Campaign)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CampaignMgrServer).UpdateCampaign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CampaignMgr_UpdateCampaign_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CampaignMgrServer).UpdateCampaign(ctx, req.(*Campaign))
	}
	return interceptor(ctx, in, info, handler)
}

func _CampaignMgr_MatchCampaigns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CampaignMgrServer).MatchCampaigns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CampaignMgr_MatchCampaigns_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CampaignMgrServer).MatchCampaigns(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _CampaignMgr_DeleteCampaign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CampaignMgrServer).DeleteCampaign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CampaignMgr_DeleteCampaign_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CampaignMgrServer).DeleteCampaign(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _CampaignMgr_OnEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CampaignMgrServer).OnEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CampaignMgr_OnEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CampaignMgrServer).OnEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _CampaignMgr_ListCampaignSendLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CampaignSendLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CampaignMgrServer).ListCampaignSendLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CampaignMgr_ListCampaignSendLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CampaignMgrServer).ListCampaignSendLog(ctx, req.(*CampaignSendLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CampaignMgr_ReportBroadcastCampaign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CampaignMgrServer).ReportBroadcastCampaign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CampaignMgr_ReportBroadcastCampaign_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CampaignMgrServer).ReportBroadcastCampaign(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _CampaignMgr_ListOutboundCallEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOutboundCallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CampaignMgrServer).ListOutboundCallEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CampaignMgr_ListOutboundCallEntries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CampaignMgrServer).ListOutboundCallEntries(ctx, req.(*ListOutboundCallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CampaignMgr_UpdateOutboundCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OutboundCallEntry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CampaignMgrServer).UpdateOutboundCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CampaignMgr_UpdateOutboundCall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CampaignMgrServer).UpdateOutboundCall(ctx, req.(*OutboundCallEntry))
	}
	return interceptor(ctx, in, info, handler)
}

func _CampaignMgr_ImportOutboundCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportOutboundCallEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CampaignMgrServer).ImportOutboundCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CampaignMgr_ImportOutboundCall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CampaignMgrServer).ImportOutboundCall(ctx, req.(*ImportOutboundCallEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CampaignMgr_GetOutboundCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OutboundCallEntry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CampaignMgrServer).GetOutboundCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CampaignMgr_GetOutboundCall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CampaignMgrServer).GetOutboundCall(ctx, req.(*OutboundCallEntry))
	}
	return interceptor(ctx, in, info, handler)
}

func _CampaignMgr_RemoveOutboudCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OutboundCallEntry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CampaignMgrServer).RemoveOutboudCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CampaignMgr_RemoveOutboudCall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CampaignMgrServer).RemoveOutboudCall(ctx, req.(*OutboundCallEntry))
	}
	return interceptor(ctx, in, info, handler)
}

func _CampaignMgr_ReportOutboundCalls_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OutboundCallReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CampaignMgrServer).ReportOutboundCalls(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CampaignMgr_ReportOutboundCalls_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CampaignMgrServer).ReportOutboundCalls(ctx, req.(*OutboundCallReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CampaignMgr_ReassignOutboundCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOutboundCallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CampaignMgrServer).ReassignOutboundCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CampaignMgr_ReassignOutboundCall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CampaignMgrServer).ReassignOutboundCall(ctx, req.(*ListOutboundCallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CampaignMgr_SendTestMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CampaignMgrServer).SendTestMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CampaignMgr_SendTestMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CampaignMgrServer).SendTestMessage(ctx, req.(*TestMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CampaignMgr_ServiceDesc is the grpc.ServiceDesc for CampaignMgr service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CampaignMgr_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.CampaignMgr",
	HandlerType: (*CampaignMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListCampaigns",
			Handler:    _CampaignMgr_ListCampaigns_Handler,
		},
		{
			MethodName: "ReadCampaign",
			Handler:    _CampaignMgr_ReadCampaign_Handler,
		},
		{
			MethodName: "CreateCampaign",
			Handler:    _CampaignMgr_CreateCampaign_Handler,
		},
		{
			MethodName: "UpdateCampaign",
			Handler:    _CampaignMgr_UpdateCampaign_Handler,
		},
		{
			MethodName: "MatchCampaigns",
			Handler:    _CampaignMgr_MatchCampaigns_Handler,
		},
		{
			MethodName: "DeleteCampaign",
			Handler:    _CampaignMgr_DeleteCampaign_Handler,
		},
		{
			MethodName: "OnEvent",
			Handler:    _CampaignMgr_OnEvent_Handler,
		},
		{
			MethodName: "ListCampaignSendLog",
			Handler:    _CampaignMgr_ListCampaignSendLog_Handler,
		},
		{
			MethodName: "ReportBroadcastCampaign",
			Handler:    _CampaignMgr_ReportBroadcastCampaign_Handler,
		},
		{
			MethodName: "ListOutboundCallEntries",
			Handler:    _CampaignMgr_ListOutboundCallEntries_Handler,
		},
		{
			MethodName: "UpdateOutboundCall",
			Handler:    _CampaignMgr_UpdateOutboundCall_Handler,
		},
		{
			MethodName: "ImportOutboundCall",
			Handler:    _CampaignMgr_ImportOutboundCall_Handler,
		},
		{
			MethodName: "GetOutboundCall",
			Handler:    _CampaignMgr_GetOutboundCall_Handler,
		},
		{
			MethodName: "RemoveOutboudCall",
			Handler:    _CampaignMgr_RemoveOutboudCall_Handler,
		},
		{
			MethodName: "ReportOutboundCalls",
			Handler:    _CampaignMgr_ReportOutboundCalls_Handler,
		},
		{
			MethodName: "ReassignOutboundCall",
			Handler:    _CampaignMgr_ReassignOutboundCall_Handler,
		},
		{
			MethodName: "SendTestMessage",
			Handler:    _CampaignMgr_SendTestMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	CreditMgr_TrySpendCredit_FullMethodName      = "/header.CreditMgr/TrySpendCredit"
	CreditMgr_ReportCreditSpend_FullMethodName   = "/header.CreditMgr/ReportCreditSpend"
	CreditMgr_ListCreditSpendLog_FullMethodName  = "/header.CreditMgr/ListCreditSpendLog"
	CreditMgr_ListCredits_FullMethodName         = "/header.CreditMgr/ListCredits"
	CreditMgr_UpdateCredit_FullMethodName        = "/header.CreditMgr/UpdateCredit"
	CreditMgr_MatchCredits_FullMethodName        = "/header.CreditMgr/MatchCredits"
	CreditMgr_GetTotalCreditSpend_FullMethodName = "/header.CreditMgr/GetTotalCreditSpend"
)

// CreditMgrClient is the client API for CreditMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CreditMgrClient interface {
	TrySpendCredit(ctx context.Context, in *CreditSpendEntry, opts ...grpc.CallOption) (*TrySpendCreditResponse, error)
	ReportCreditSpend(ctx context.Context, in *CreditSpendReportRequest, opts ...grpc.CallOption) (*CreditSpendReportResponse, error)
	ListCreditSpendLog(ctx context.Context, in *CreditSpendLogRequest, opts ...grpc.CallOption) (*CreditSpendEntries, error)
	ListCredits(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	// rpc AddCredit(header.Credit) returns (header.Response); // credit
	// rpc DeleteCredit(header.Id) returns (header.Response); // empty
	UpdateCredit(ctx context.Context, in *Credit, opts ...grpc.CallOption) (*Response, error)
	MatchCredits(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
	GetTotalCreditSpend(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
}

type creditMgrClient struct {
	cc grpc.ClientConnInterface
}

func NewCreditMgrClient(cc grpc.ClientConnInterface) CreditMgrClient {
	return &creditMgrClient{cc}
}

func (c *creditMgrClient) TrySpendCredit(ctx context.Context, in *CreditSpendEntry, opts ...grpc.CallOption) (*TrySpendCreditResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TrySpendCreditResponse)
	err := c.cc.Invoke(ctx, CreditMgr_TrySpendCredit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *creditMgrClient) ReportCreditSpend(ctx context.Context, in *CreditSpendReportRequest, opts ...grpc.CallOption) (*CreditSpendReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreditSpendReportResponse)
	err := c.cc.Invoke(ctx, CreditMgr_ReportCreditSpend_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *creditMgrClient) ListCreditSpendLog(ctx context.Context, in *CreditSpendLogRequest, opts ...grpc.CallOption) (*CreditSpendEntries, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreditSpendEntries)
	err := c.cc.Invoke(ctx, CreditMgr_ListCreditSpendLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *creditMgrClient) ListCredits(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, CreditMgr_ListCredits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *creditMgrClient) UpdateCredit(ctx context.Context, in *Credit, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, CreditMgr_UpdateCredit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *creditMgrClient) MatchCredits(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, CreditMgr_MatchCredits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *creditMgrClient) GetTotalCreditSpend(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, CreditMgr_GetTotalCreditSpend_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CreditMgrServer is the server API for CreditMgr service.
// All implementations must embed UnimplementedCreditMgrServer
// for forward compatibility.
type CreditMgrServer interface {
	TrySpendCredit(context.Context, *CreditSpendEntry) (*TrySpendCreditResponse, error)
	ReportCreditSpend(context.Context, *CreditSpendReportRequest) (*CreditSpendReportResponse, error)
	ListCreditSpendLog(context.Context, *CreditSpendLogRequest) (*CreditSpendEntries, error)
	ListCredits(context.Context, *Id) (*Response, error)
	// rpc AddCredit(header.Credit) returns (header.Response); // credit
	// rpc DeleteCredit(header.Id) returns (header.Response); // empty
	UpdateCredit(context.Context, *Credit) (*Response, error)
	MatchCredits(context.Context, *Ids) (*Response, error)
	GetTotalCreditSpend(context.Context, *Id) (*Response, error)
	mustEmbedUnimplementedCreditMgrServer()
}

// UnimplementedCreditMgrServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCreditMgrServer struct{}

func (UnimplementedCreditMgrServer) TrySpendCredit(context.Context, *CreditSpendEntry) (*TrySpendCreditResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TrySpendCredit not implemented")
}
func (UnimplementedCreditMgrServer) ReportCreditSpend(context.Context, *CreditSpendReportRequest) (*CreditSpendReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportCreditSpend not implemented")
}
func (UnimplementedCreditMgrServer) ListCreditSpendLog(context.Context, *CreditSpendLogRequest) (*CreditSpendEntries, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCreditSpendLog not implemented")
}
func (UnimplementedCreditMgrServer) ListCredits(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCredits not implemented")
}
func (UnimplementedCreditMgrServer) UpdateCredit(context.Context, *Credit) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCredit not implemented")
}
func (UnimplementedCreditMgrServer) MatchCredits(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchCredits not implemented")
}
func (UnimplementedCreditMgrServer) GetTotalCreditSpend(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTotalCreditSpend not implemented")
}
func (UnimplementedCreditMgrServer) mustEmbedUnimplementedCreditMgrServer() {}
func (UnimplementedCreditMgrServer) testEmbeddedByValue()                   {}

// UnsafeCreditMgrServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CreditMgrServer will
// result in compilation errors.
type UnsafeCreditMgrServer interface {
	mustEmbedUnimplementedCreditMgrServer()
}

func RegisterCreditMgrServer(s grpc.ServiceRegistrar, srv CreditMgrServer) {
	// If the following call pancis, it indicates UnimplementedCreditMgrServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CreditMgr_ServiceDesc, srv)
}

func _CreditMgr_TrySpendCredit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreditSpendEntry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditMgrServer).TrySpendCredit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditMgr_TrySpendCredit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditMgrServer).TrySpendCredit(ctx, req.(*CreditSpendEntry))
	}
	return interceptor(ctx, in, info, handler)
}

func _CreditMgr_ReportCreditSpend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreditSpendReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditMgrServer).ReportCreditSpend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditMgr_ReportCreditSpend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditMgrServer).ReportCreditSpend(ctx, req.(*CreditSpendReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CreditMgr_ListCreditSpendLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreditSpendLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditMgrServer).ListCreditSpendLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditMgr_ListCreditSpendLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditMgrServer).ListCreditSpendLog(ctx, req.(*CreditSpendLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CreditMgr_ListCredits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditMgrServer).ListCredits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditMgr_ListCredits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditMgrServer).ListCredits(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _CreditMgr_UpdateCredit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Credit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditMgrServer).UpdateCredit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditMgr_UpdateCredit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditMgrServer).UpdateCredit(ctx, req.(*Credit))
	}
	return interceptor(ctx, in, info, handler)
}

func _CreditMgr_MatchCredits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditMgrServer).MatchCredits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditMgr_MatchCredits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditMgrServer).MatchCredits(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _CreditMgr_GetTotalCreditSpend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditMgrServer).GetTotalCreditSpend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditMgr_GetTotalCreditSpend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditMgrServer).GetTotalCreditSpend(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

// CreditMgr_ServiceDesc is the grpc.ServiceDesc for CreditMgr service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CreditMgr_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.CreditMgr",
	HandlerType: (*CreditMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TrySpendCredit",
			Handler:    _CreditMgr_TrySpendCredit_Handler,
		},
		{
			MethodName: "ReportCreditSpend",
			Handler:    _CreditMgr_ReportCreditSpend_Handler,
		},
		{
			MethodName: "ListCreditSpendLog",
			Handler:    _CreditMgr_ListCreditSpendLog_Handler,
		},
		{
			MethodName: "ListCredits",
			Handler:    _CreditMgr_ListCredits_Handler,
		},
		{
			MethodName: "UpdateCredit",
			Handler:    _CreditMgr_UpdateCredit_Handler,
		},
		{
			MethodName: "MatchCredits",
			Handler:    _CreditMgr_MatchCredits_Handler,
		},
		{
			MethodName: "GetTotalCreditSpend",
			Handler:    _CreditMgr_GetTotalCreditSpend_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	FormMgr_ListForms_FullMethodName              = "/header.FormMgr/ListForms"
	FormMgr_CreateForm_FullMethodName             = "/header.FormMgr/CreateForm"
	FormMgr_GetForm_FullMethodName                = "/header.FormMgr/GetForm"
	FormMgr_UpdateForm_FullMethodName             = "/header.FormMgr/UpdateForm"
	FormMgr_MatchForm_FullMethodName              = "/header.FormMgr/MatchForm"
	FormMgr_DeleteForm_FullMethodName             = "/header.FormMgr/DeleteForm"
	FormMgr_ReportForm_FullMethodName             = "/header.FormMgr/ReportForm"
	FormMgr_ListFormSubmissions_FullMethodName    = "/header.FormMgr/ListFormSubmissions"
	FormMgr_SubmitForm_FullMethodName             = "/header.FormMgr/SubmitForm"
	FormMgr_CheckFormFromAuthToken_FullMethodName = "/header.FormMgr/CheckFormFromAuthToken"
	FormMgr_GenerateFormLink_FullMethodName       = "/header.FormMgr/GenerateFormLink"
)

// FormMgrClient is the client API for FormMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FormMgrClient interface {
	ListForms(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	CreateForm(ctx context.Context, in *Form, opts ...grpc.CallOption) (*Response, error)
	GetForm(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	UpdateForm(ctx context.Context, in *Form, opts ...grpc.CallOption) (*Response, error)
	MatchForm(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error)
	DeleteForm(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ReportForm(ctx context.Context, in *FormReportRequest, opts ...grpc.CallOption) (*FormReportResponse, error)
	ListFormSubmissions(ctx context.Context, in *ListFormSubmissionRequest, opts ...grpc.CallOption) (*Response, error)
	SubmitForm(ctx context.Context, in *FormSubmission, opts ...grpc.CallOption) (*FormSubmission, error)
	CheckFormFromAuthToken(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	GenerateFormLink(ctx context.Context, in *GenerateFormTokenRequest, opts ...grpc.CallOption) (*Id, error)
}

type formMgrClient struct {
	cc grpc.ClientConnInterface
}

func NewFormMgrClient(cc grpc.ClientConnInterface) FormMgrClient {
	return &formMgrClient{cc}
}

func (c *formMgrClient) ListForms(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, FormMgr_ListForms_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *formMgrClient) CreateForm(ctx context.Context, in *Form, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, FormMgr_CreateForm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *formMgrClient) GetForm(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, FormMgr_GetForm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *formMgrClient) UpdateForm(ctx context.Context, in *Form, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, FormMgr_UpdateForm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *formMgrClient) MatchForm(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, FormMgr_MatchForm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *formMgrClient) DeleteForm(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, FormMgr_DeleteForm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *formMgrClient) ReportForm(ctx context.Context, in *FormReportRequest, opts ...grpc.CallOption) (*FormReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FormReportResponse)
	err := c.cc.Invoke(ctx, FormMgr_ReportForm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *formMgrClient) ListFormSubmissions(ctx context.Context, in *ListFormSubmissionRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, FormMgr_ListFormSubmissions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *formMgrClient) SubmitForm(ctx context.Context, in *FormSubmission, opts ...grpc.CallOption) (*FormSubmission, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FormSubmission)
	err := c.cc.Invoke(ctx, FormMgr_SubmitForm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *formMgrClient) CheckFormFromAuthToken(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, FormMgr_CheckFormFromAuthToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *formMgrClient) GenerateFormLink(ctx context.Context, in *GenerateFormTokenRequest, opts ...grpc.CallOption) (*Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Id)
	err := c.cc.Invoke(ctx, FormMgr_GenerateFormLink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FormMgrServer is the server API for FormMgr service.
// All implementations must embed UnimplementedFormMgrServer
// for forward compatibility.
type FormMgrServer interface {
	ListForms(context.Context, *Id) (*Response, error)
	CreateForm(context.Context, *Form) (*Response, error)
	GetForm(context.Context, *Id) (*Response, error)
	UpdateForm(context.Context, *Form) (*Response, error)
	MatchForm(context.Context, *Ids) (*Response, error)
	DeleteForm(context.Context, *Id) (*Empty, error)
	ReportForm(context.Context, *FormReportRequest) (*FormReportResponse, error)
	ListFormSubmissions(context.Context, *ListFormSubmissionRequest) (*Response, error)
	SubmitForm(context.Context, *FormSubmission) (*FormSubmission, error)
	CheckFormFromAuthToken(context.Context, *Id) (*Response, error)
	GenerateFormLink(context.Context, *GenerateFormTokenRequest) (*Id, error)
	mustEmbedUnimplementedFormMgrServer()
}

// UnimplementedFormMgrServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFormMgrServer struct{}

func (UnimplementedFormMgrServer) ListForms(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListForms not implemented")
}
func (UnimplementedFormMgrServer) CreateForm(context.Context, *Form) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateForm not implemented")
}
func (UnimplementedFormMgrServer) GetForm(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetForm not implemented")
}
func (UnimplementedFormMgrServer) UpdateForm(context.Context, *Form) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateForm not implemented")
}
func (UnimplementedFormMgrServer) MatchForm(context.Context, *Ids) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchForm not implemented")
}
func (UnimplementedFormMgrServer) DeleteForm(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteForm not implemented")
}
func (UnimplementedFormMgrServer) ReportForm(context.Context, *FormReportRequest) (*FormReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportForm not implemented")
}
func (UnimplementedFormMgrServer) ListFormSubmissions(context.Context, *ListFormSubmissionRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFormSubmissions not implemented")
}
func (UnimplementedFormMgrServer) SubmitForm(context.Context, *FormSubmission) (*FormSubmission, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitForm not implemented")
}
func (UnimplementedFormMgrServer) CheckFormFromAuthToken(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckFormFromAuthToken not implemented")
}
func (UnimplementedFormMgrServer) GenerateFormLink(context.Context, *GenerateFormTokenRequest) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateFormLink not implemented")
}
func (UnimplementedFormMgrServer) mustEmbedUnimplementedFormMgrServer() {}
func (UnimplementedFormMgrServer) testEmbeddedByValue()                 {}

// UnsafeFormMgrServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FormMgrServer will
// result in compilation errors.
type UnsafeFormMgrServer interface {
	mustEmbedUnimplementedFormMgrServer()
}

func RegisterFormMgrServer(s grpc.ServiceRegistrar, srv FormMgrServer) {
	// If the following call pancis, it indicates UnimplementedFormMgrServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FormMgr_ServiceDesc, srv)
}

func _FormMgr_ListForms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FormMgrServer).ListForms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FormMgr_ListForms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FormMgrServer).ListForms(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _FormMgr_CreateForm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Form)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FormMgrServer).CreateForm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FormMgr_CreateForm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FormMgrServer).CreateForm(ctx, req.(*Form))
	}
	return interceptor(ctx, in, info, handler)
}

func _FormMgr_GetForm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FormMgrServer).GetForm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FormMgr_GetForm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FormMgrServer).GetForm(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _FormMgr_UpdateForm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Form)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FormMgrServer).UpdateForm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FormMgr_UpdateForm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FormMgrServer).UpdateForm(ctx, req.(*Form))
	}
	return interceptor(ctx, in, info, handler)
}

func _FormMgr_MatchForm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FormMgrServer).MatchForm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FormMgr_MatchForm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FormMgrServer).MatchForm(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _FormMgr_DeleteForm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FormMgrServer).DeleteForm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FormMgr_DeleteForm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FormMgrServer).DeleteForm(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _FormMgr_ReportForm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FormReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FormMgrServer).ReportForm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FormMgr_ReportForm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FormMgrServer).ReportForm(ctx, req.(*FormReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FormMgr_ListFormSubmissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFormSubmissionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FormMgrServer).ListFormSubmissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FormMgr_ListFormSubmissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FormMgrServer).ListFormSubmissions(ctx, req.(*ListFormSubmissionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FormMgr_SubmitForm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FormSubmission)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FormMgrServer).SubmitForm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FormMgr_SubmitForm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FormMgrServer).SubmitForm(ctx, req.(*FormSubmission))
	}
	return interceptor(ctx, in, info, handler)
}

func _FormMgr_CheckFormFromAuthToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FormMgrServer).CheckFormFromAuthToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FormMgr_CheckFormFromAuthToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FormMgrServer).CheckFormFromAuthToken(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _FormMgr_GenerateFormLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateFormTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FormMgrServer).GenerateFormLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FormMgr_GenerateFormLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FormMgrServer).GenerateFormLink(ctx, req.(*GenerateFormTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FormMgr_ServiceDesc is the grpc.ServiceDesc for FormMgr service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FormMgr_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.FormMgr",
	HandlerType: (*FormMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListForms",
			Handler:    _FormMgr_ListForms_Handler,
		},
		{
			MethodName: "CreateForm",
			Handler:    _FormMgr_CreateForm_Handler,
		},
		{
			MethodName: "GetForm",
			Handler:    _FormMgr_GetForm_Handler,
		},
		{
			MethodName: "UpdateForm",
			Handler:    _FormMgr_UpdateForm_Handler,
		},
		{
			MethodName: "MatchForm",
			Handler:    _FormMgr_MatchForm_Handler,
		},
		{
			MethodName: "DeleteForm",
			Handler:    _FormMgr_DeleteForm_Handler,
		},
		{
			MethodName: "ReportForm",
			Handler:    _FormMgr_ReportForm_Handler,
		},
		{
			MethodName: "ListFormSubmissions",
			Handler:    _FormMgr_ListFormSubmissions_Handler,
		},
		{
			MethodName: "SubmitForm",
			Handler:    _FormMgr_SubmitForm_Handler,
		},
		{
			MethodName: "CheckFormFromAuthToken",
			Handler:    _FormMgr_CheckFormFromAuthToken_Handler,
		},
		{
			MethodName: "GenerateFormLink",
			Handler:    _FormMgr_GenerateFormLink_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	Scheduler_RegisterTask_FullMethodName   = "/header.Scheduler/RegisterTask"
	Scheduler_UnregisterTask_FullMethodName = "/header.Scheduler/UnregisterTask"
)

// SchedulerClient is the client API for Scheduler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SchedulerClient interface {
	RegisterTask(ctx context.Context, in *SchedulerTask, opts ...grpc.CallOption) (*SchedulerTask, error)
	UnregisterTask(ctx context.Context, in *SchedulerTask, opts ...grpc.CallOption) (*Response, error)
}

type schedulerClient struct {
	cc grpc.ClientConnInterface
}

func NewSchedulerClient(cc grpc.ClientConnInterface) SchedulerClient {
	return &schedulerClient{cc}
}

func (c *schedulerClient) RegisterTask(ctx context.Context, in *SchedulerTask, opts ...grpc.CallOption) (*SchedulerTask, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SchedulerTask)
	err := c.cc.Invoke(ctx, Scheduler_RegisterTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) UnregisterTask(ctx context.Context, in *SchedulerTask, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Scheduler_UnregisterTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SchedulerServer is the server API for Scheduler service.
// All implementations must embed UnimplementedSchedulerServer
// for forward compatibility.
type SchedulerServer interface {
	RegisterTask(context.Context, *SchedulerTask) (*SchedulerTask, error)
	UnregisterTask(context.Context, *SchedulerTask) (*Response, error)
	mustEmbedUnimplementedSchedulerServer()
}

// UnimplementedSchedulerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSchedulerServer struct{}

func (UnimplementedSchedulerServer) RegisterTask(context.Context, *SchedulerTask) (*SchedulerTask, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterTask not implemented")
}
func (UnimplementedSchedulerServer) UnregisterTask(context.Context, *SchedulerTask) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterTask not implemented")
}
func (UnimplementedSchedulerServer) mustEmbedUnimplementedSchedulerServer() {}
func (UnimplementedSchedulerServer) testEmbeddedByValue()                   {}

// UnsafeSchedulerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SchedulerServer will
// result in compilation errors.
type UnsafeSchedulerServer interface {
	mustEmbedUnimplementedSchedulerServer()
}

func RegisterSchedulerServer(s grpc.ServiceRegistrar, srv SchedulerServer) {
	// If the following call pancis, it indicates UnimplementedSchedulerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Scheduler_ServiceDesc, srv)
}

func _Scheduler_RegisterTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SchedulerTask)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).RegisterTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scheduler_RegisterTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).RegisterTask(ctx, req.(*SchedulerTask))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_UnregisterTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SchedulerTask)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).UnregisterTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scheduler_UnregisterTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).UnregisterTask(ctx, req.(*SchedulerTask))
	}
	return interceptor(ctx, in, info, handler)
}

// Scheduler_ServiceDesc is the grpc.ServiceDesc for Scheduler service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Scheduler_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.Scheduler",
	HandlerType: (*SchedulerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterTask",
			Handler:    _Scheduler_RegisterTask_Handler,
		},
		{
			MethodName: "UnregisterTask",
			Handler:    _Scheduler_UnregisterTask_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	KB_CreateKnowledgeBase_FullMethodName     = "/header.KB/CreateKnowledgeBase"
	KB_UpdateKnowledgeBase_FullMethodName     = "/header.KB/UpdateKnowledgeBase"
	KB_DeleteKnowledgeBase_FullMethodName     = "/header.KB/DeleteKnowledgeBase"
	KB_GetKnowledgeBase_FullMethodName        = "/header.KB/GetKnowledgeBase"
	KB_ListKnowledgeBases_FullMethodName      = "/header.KB/ListKnowledgeBases"
	KB_ListKnowledgeBaseEvents_FullMethodName = "/header.KB/ListKnowledgeBaseEvents"
	KB_CreateArticle_FullMethodName           = "/header.KB/CreateArticle"
	KB_UpdateArticle_FullMethodName           = "/header.KB/UpdateArticle"
	KB_DeleteArticle_FullMethodName           = "/header.KB/DeleteArticle"
	KB_GetArticle_FullMethodName              = "/header.KB/GetArticle"
	KB_ListArticles_FullMethodName            = "/header.KB/ListArticles"
	KB_ListArticleVersions_FullMethodName     = "/header.KB/ListArticleVersions"
	KB_SearchArticles_FullMethodName          = "/header.KB/SearchArticles"
	KB_AddTopicToArticle_FullMethodName       = "/header.KB/AddTopicToArticle"
	KB_RemoveTopicFromArticle_FullMethodName  = "/header.KB/RemoveTopicFromArticle"
	KB_RateArticle_FullMethodName             = "/header.KB/RateArticle"
	KB_ViewArticle_FullMethodName             = "/header.KB/ViewArticle"
	KB_ReportArticle_FullMethodName           = "/header.KB/ReportArticle"
	KB_ListRelatedArticles_FullMethodName     = "/header.KB/ListRelatedArticles"
	KB_CreateArticleTopic_FullMethodName      = "/header.KB/CreateArticleTopic"
	KB_UpdateArticleTopic_FullMethodName      = "/header.KB/UpdateArticleTopic"
	KB_DeleteArticleTopic_FullMethodName      = "/header.KB/DeleteArticleTopic"
	KB_ListArticleTopics_FullMethodName       = "/header.KB/ListArticleTopics"
	KB_GetArticleTopic_FullMethodName         = "/header.KB/GetArticleTopic"
	KB_CreateArticleCategory_FullMethodName   = "/header.KB/CreateArticleCategory"
	KB_UpdateArticleCategory_FullMethodName   = "/header.KB/UpdateArticleCategory"
	KB_DeleteArticleCategory_FullMethodName   = "/header.KB/DeleteArticleCategory"
	KB_GetArticleCategory_FullMethodName      = "/header.KB/GetArticleCategory"
	KB_ListArticleCategories_FullMethodName   = "/header.KB/ListArticleCategories"
	KB_CheckKbHandle_FullMethodName           = "/header.KB/CheckKbHandle"
	KB_UpdateArticleTree_FullMethodName       = "/header.KB/UpdateArticleTree"
)

// KBClient is the client API for KB service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KBClient interface {
	CreateKnowledgeBase(ctx context.Context, in *KnowledgeBase, opts ...grpc.CallOption) (*Response, error)
	UpdateKnowledgeBase(ctx context.Context, in *KnowledgeBase, opts ...grpc.CallOption) (*Response, error)
	DeleteKnowledgeBase(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	GetKnowledgeBase(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	ListKnowledgeBases(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	ListKnowledgeBaseEvents(ctx context.Context, in *ListKnowledgeBaseEventRequest, opts ...grpc.CallOption) (*Events, error)
	CreateArticle(ctx context.Context, in *Article, opts ...grpc.CallOption) (*Response, error)
	UpdateArticle(ctx context.Context, in *Article, opts ...grpc.CallOption) (*Response, error)
	DeleteArticle(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	GetArticle(ctx context.Context, in *Article, opts ...grpc.CallOption) (*Response, error)
	ListArticles(ctx context.Context, in *ListArticleRequest, opts ...grpc.CallOption) (*Response, error)
	ListArticleVersions(ctx context.Context, in *ListVersions, opts ...grpc.CallOption) (*Response, error)
	SearchArticles(ctx context.Context, in *SearchArticleRequest, opts ...grpc.CallOption) (*ArticleSearchResponse, error)
	AddTopicToArticle(ctx context.Context, in *ArticleTopicRequest, opts ...grpc.CallOption) (*Empty, error)
	RemoveTopicFromArticle(ctx context.Context, in *ArticleTopicRequest, opts ...grpc.CallOption) (*Empty, error)
	RateArticle(ctx context.Context, in *Rating, opts ...grpc.CallOption) (*Response, error)
	ViewArticle(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	ReportArticle(ctx context.Context, in *ReportCountRequest, opts ...grpc.CallOption) (*Response, error)
	ListRelatedArticles(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	CreateArticleTopic(ctx context.Context, in *ArticleTopic, opts ...grpc.CallOption) (*ArticleTopic, error)
	UpdateArticleTopic(ctx context.Context, in *ArticleTopic, opts ...grpc.CallOption) (*ArticleTopic, error)
	DeleteArticleTopic(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ListArticleTopics(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ArticleTopics, error)
	GetArticleTopic(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ArticleTopic, error)
	CreateArticleCategory(ctx context.Context, in *ArticleCategory, opts ...grpc.CallOption) (*Response, error)
	UpdateArticleCategory(ctx context.Context, in *ArticleCategory, opts ...grpc.CallOption) (*Response, error)
	DeleteArticleCategory(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	GetArticleCategory(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	ListArticleCategories(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	CheckKbHandle(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error)
	UpdateArticleTree(ctx context.Context, in *ArticleNode, opts ...grpc.CallOption) (*Response, error)
}

type kBClient struct {
	cc grpc.ClientConnInterface
}

func NewKBClient(cc grpc.ClientConnInterface) KBClient {
	return &kBClient{cc}
}

func (c *kBClient) CreateKnowledgeBase(ctx context.Context, in *KnowledgeBase, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, KB_CreateKnowledgeBase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) UpdateKnowledgeBase(ctx context.Context, in *KnowledgeBase, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, KB_UpdateKnowledgeBase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) DeleteKnowledgeBase(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, KB_DeleteKnowledgeBase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) GetKnowledgeBase(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, KB_GetKnowledgeBase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) ListKnowledgeBases(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, KB_ListKnowledgeBases_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) ListKnowledgeBaseEvents(ctx context.Context, in *ListKnowledgeBaseEventRequest, opts ...grpc.CallOption) (*Events, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Events)
	err := c.cc.Invoke(ctx, KB_ListKnowledgeBaseEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) CreateArticle(ctx context.Context, in *Article, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, KB_CreateArticle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) UpdateArticle(ctx context.Context, in *Article, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, KB_UpdateArticle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) DeleteArticle(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, KB_DeleteArticle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) GetArticle(ctx context.Context, in *Article, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, KB_GetArticle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) ListArticles(ctx context.Context, in *ListArticleRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, KB_ListArticles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) ListArticleVersions(ctx context.Context, in *ListVersions, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, KB_ListArticleVersions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) SearchArticles(ctx context.Context, in *SearchArticleRequest, opts ...grpc.CallOption) (*ArticleSearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ArticleSearchResponse)
	err := c.cc.Invoke(ctx, KB_SearchArticles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) AddTopicToArticle(ctx context.Context, in *ArticleTopicRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, KB_AddTopicToArticle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) RemoveTopicFromArticle(ctx context.Context, in *ArticleTopicRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, KB_RemoveTopicFromArticle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) RateArticle(ctx context.Context, in *Rating, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, KB_RateArticle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) ViewArticle(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, KB_ViewArticle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) ReportArticle(ctx context.Context, in *ReportCountRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, KB_ReportArticle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) ListRelatedArticles(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, KB_ListRelatedArticles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) CreateArticleTopic(ctx context.Context, in *ArticleTopic, opts ...grpc.CallOption) (*ArticleTopic, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ArticleTopic)
	err := c.cc.Invoke(ctx, KB_CreateArticleTopic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) UpdateArticleTopic(ctx context.Context, in *ArticleTopic, opts ...grpc.CallOption) (*ArticleTopic, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ArticleTopic)
	err := c.cc.Invoke(ctx, KB_UpdateArticleTopic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) DeleteArticleTopic(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, KB_DeleteArticleTopic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) ListArticleTopics(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ArticleTopics, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ArticleTopics)
	err := c.cc.Invoke(ctx, KB_ListArticleTopics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) GetArticleTopic(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ArticleTopic, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ArticleTopic)
	err := c.cc.Invoke(ctx, KB_GetArticleTopic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) CreateArticleCategory(ctx context.Context, in *ArticleCategory, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, KB_CreateArticleCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) UpdateArticleCategory(ctx context.Context, in *ArticleCategory, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, KB_UpdateArticleCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) DeleteArticleCategory(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, KB_DeleteArticleCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) GetArticleCategory(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, KB_GetArticleCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) ListArticleCategories(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, KB_ListArticleCategories_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) CheckKbHandle(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, KB_CheckKbHandle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kBClient) UpdateArticleTree(ctx context.Context, in *ArticleNode, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, KB_UpdateArticleTree_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KBServer is the server API for KB service.
// All implementations must embed UnimplementedKBServer
// for forward compatibility.
type KBServer interface {
	CreateKnowledgeBase(context.Context, *KnowledgeBase) (*Response, error)
	UpdateKnowledgeBase(context.Context, *KnowledgeBase) (*Response, error)
	DeleteKnowledgeBase(context.Context, *Id) (*Response, error)
	GetKnowledgeBase(context.Context, *Id) (*Response, error)
	ListKnowledgeBases(context.Context, *Id) (*Response, error)
	ListKnowledgeBaseEvents(context.Context, *ListKnowledgeBaseEventRequest) (*Events, error)
	CreateArticle(context.Context, *Article) (*Response, error)
	UpdateArticle(context.Context, *Article) (*Response, error)
	DeleteArticle(context.Context, *Id) (*Response, error)
	GetArticle(context.Context, *Article) (*Response, error)
	ListArticles(context.Context, *ListArticleRequest) (*Response, error)
	ListArticleVersions(context.Context, *ListVersions) (*Response, error)
	SearchArticles(context.Context, *SearchArticleRequest) (*ArticleSearchResponse, error)
	AddTopicToArticle(context.Context, *ArticleTopicRequest) (*Empty, error)
	RemoveTopicFromArticle(context.Context, *ArticleTopicRequest) (*Empty, error)
	RateArticle(context.Context, *Rating) (*Response, error)
	ViewArticle(context.Context, *Id) (*Response, error)
	ReportArticle(context.Context, *ReportCountRequest) (*Response, error)
	ListRelatedArticles(context.Context, *Id) (*Response, error)
	CreateArticleTopic(context.Context, *ArticleTopic) (*ArticleTopic, error)
	UpdateArticleTopic(context.Context, *ArticleTopic) (*ArticleTopic, error)
	DeleteArticleTopic(context.Context, *Id) (*Empty, error)
	ListArticleTopics(context.Context, *Id) (*ArticleTopics, error)
	GetArticleTopic(context.Context, *Id) (*ArticleTopic, error)
	CreateArticleCategory(context.Context, *ArticleCategory) (*Response, error)
	UpdateArticleCategory(context.Context, *ArticleCategory) (*Response, error)
	DeleteArticleCategory(context.Context, *Id) (*Response, error)
	GetArticleCategory(context.Context, *Id) (*Response, error)
	ListArticleCategories(context.Context, *Id) (*Response, error)
	CheckKbHandle(context.Context, *Id) (*Response, error)
	UpdateArticleTree(context.Context, *ArticleNode) (*Response, error)
	mustEmbedUnimplementedKBServer()
}

// UnimplementedKBServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedKBServer struct{}

func (UnimplementedKBServer) CreateKnowledgeBase(context.Context, *KnowledgeBase) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateKnowledgeBase not implemented")
}
func (UnimplementedKBServer) UpdateKnowledgeBase(context.Context, *KnowledgeBase) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateKnowledgeBase not implemented")
}
func (UnimplementedKBServer) DeleteKnowledgeBase(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteKnowledgeBase not implemented")
}
func (UnimplementedKBServer) GetKnowledgeBase(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKnowledgeBase not implemented")
}
func (UnimplementedKBServer) ListKnowledgeBases(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListKnowledgeBases not implemented")
}
func (UnimplementedKBServer) ListKnowledgeBaseEvents(context.Context, *ListKnowledgeBaseEventRequest) (*Events, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListKnowledgeBaseEvents not implemented")
}
func (UnimplementedKBServer) CreateArticle(context.Context, *Article) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateArticle not implemented")
}
func (UnimplementedKBServer) UpdateArticle(context.Context, *Article) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateArticle not implemented")
}
func (UnimplementedKBServer) DeleteArticle(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteArticle not implemented")
}
func (UnimplementedKBServer) GetArticle(context.Context, *Article) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetArticle not implemented")
}
func (UnimplementedKBServer) ListArticles(context.Context, *ListArticleRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListArticles not implemented")
}
func (UnimplementedKBServer) ListArticleVersions(context.Context, *ListVersions) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListArticleVersions not implemented")
}
func (UnimplementedKBServer) SearchArticles(context.Context, *SearchArticleRequest) (*ArticleSearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchArticles not implemented")
}
func (UnimplementedKBServer) AddTopicToArticle(context.Context, *ArticleTopicRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTopicToArticle not implemented")
}
func (UnimplementedKBServer) RemoveTopicFromArticle(context.Context, *ArticleTopicRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveTopicFromArticle not implemented")
}
func (UnimplementedKBServer) RateArticle(context.Context, *Rating) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RateArticle not implemented")
}
func (UnimplementedKBServer) ViewArticle(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ViewArticle not implemented")
}
func (UnimplementedKBServer) ReportArticle(context.Context, *ReportCountRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportArticle not implemented")
}
func (UnimplementedKBServer) ListRelatedArticles(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRelatedArticles not implemented")
}
func (UnimplementedKBServer) CreateArticleTopic(context.Context, *ArticleTopic) (*ArticleTopic, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateArticleTopic not implemented")
}
func (UnimplementedKBServer) UpdateArticleTopic(context.Context, *ArticleTopic) (*ArticleTopic, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateArticleTopic not implemented")
}
func (UnimplementedKBServer) DeleteArticleTopic(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteArticleTopic not implemented")
}
func (UnimplementedKBServer) ListArticleTopics(context.Context, *Id) (*ArticleTopics, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListArticleTopics not implemented")
}
func (UnimplementedKBServer) GetArticleTopic(context.Context, *Id) (*ArticleTopic, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetArticleTopic not implemented")
}
func (UnimplementedKBServer) CreateArticleCategory(context.Context, *ArticleCategory) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateArticleCategory not implemented")
}
func (UnimplementedKBServer) UpdateArticleCategory(context.Context, *ArticleCategory) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateArticleCategory not implemented")
}
func (UnimplementedKBServer) DeleteArticleCategory(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteArticleCategory not implemented")
}
func (UnimplementedKBServer) GetArticleCategory(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetArticleCategory not implemented")
}
func (UnimplementedKBServer) ListArticleCategories(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListArticleCategories not implemented")
}
func (UnimplementedKBServer) CheckKbHandle(context.Context, *Id) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckKbHandle not implemented")
}
func (UnimplementedKBServer) UpdateArticleTree(context.Context, *ArticleNode) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateArticleTree not implemented")
}
func (UnimplementedKBServer) mustEmbedUnimplementedKBServer() {}
func (UnimplementedKBServer) testEmbeddedByValue()            {}

// UnsafeKBServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KBServer will
// result in compilation errors.
type UnsafeKBServer interface {
	mustEmbedUnimplementedKBServer()
}

func RegisterKBServer(s grpc.ServiceRegistrar, srv KBServer) {
	// If the following call pancis, it indicates UnimplementedKBServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&KB_ServiceDesc, srv)
}

func _KB_CreateKnowledgeBase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KnowledgeBase)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).CreateKnowledgeBase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_CreateKnowledgeBase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).CreateKnowledgeBase(ctx, req.(*KnowledgeBase))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_UpdateKnowledgeBase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KnowledgeBase)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).UpdateKnowledgeBase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_UpdateKnowledgeBase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).UpdateKnowledgeBase(ctx, req.(*KnowledgeBase))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_DeleteKnowledgeBase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).DeleteKnowledgeBase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_DeleteKnowledgeBase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).DeleteKnowledgeBase(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_GetKnowledgeBase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).GetKnowledgeBase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_GetKnowledgeBase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).GetKnowledgeBase(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_ListKnowledgeBases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).ListKnowledgeBases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_ListKnowledgeBases_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).ListKnowledgeBases(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_ListKnowledgeBaseEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListKnowledgeBaseEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).ListKnowledgeBaseEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_ListKnowledgeBaseEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).ListKnowledgeBaseEvents(ctx, req.(*ListKnowledgeBaseEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_CreateArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Article)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).CreateArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_CreateArticle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).CreateArticle(ctx, req.(*Article))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_UpdateArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Article)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).UpdateArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_UpdateArticle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).UpdateArticle(ctx, req.(*Article))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_DeleteArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).DeleteArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_DeleteArticle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).DeleteArticle(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_GetArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Article)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).GetArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_GetArticle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).GetArticle(ctx, req.(*Article))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_ListArticles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListArticleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).ListArticles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_ListArticles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).ListArticles(ctx, req.(*ListArticleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_ListArticleVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVersions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).ListArticleVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_ListArticleVersions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).ListArticleVersions(ctx, req.(*ListVersions))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_SearchArticles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchArticleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).SearchArticles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_SearchArticles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).SearchArticles(ctx, req.(*SearchArticleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_AddTopicToArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArticleTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).AddTopicToArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_AddTopicToArticle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).AddTopicToArticle(ctx, req.(*ArticleTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_RemoveTopicFromArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArticleTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).RemoveTopicFromArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_RemoveTopicFromArticle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).RemoveTopicFromArticle(ctx, req.(*ArticleTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_RateArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Rating)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).RateArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_RateArticle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).RateArticle(ctx, req.(*Rating))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_ViewArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).ViewArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_ViewArticle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).ViewArticle(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_ReportArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).ReportArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_ReportArticle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).ReportArticle(ctx, req.(*ReportCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_ListRelatedArticles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).ListRelatedArticles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_ListRelatedArticles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).ListRelatedArticles(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_CreateArticleTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArticleTopic)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).CreateArticleTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_CreateArticleTopic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).CreateArticleTopic(ctx, req.(*ArticleTopic))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_UpdateArticleTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArticleTopic)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).UpdateArticleTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_UpdateArticleTopic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).UpdateArticleTopic(ctx, req.(*ArticleTopic))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_DeleteArticleTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).DeleteArticleTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_DeleteArticleTopic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).DeleteArticleTopic(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_ListArticleTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).ListArticleTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_ListArticleTopics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).ListArticleTopics(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_GetArticleTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).GetArticleTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_GetArticleTopic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).GetArticleTopic(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_CreateArticleCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArticleCategory)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).CreateArticleCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_CreateArticleCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).CreateArticleCategory(ctx, req.(*ArticleCategory))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_UpdateArticleCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArticleCategory)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).UpdateArticleCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_UpdateArticleCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).UpdateArticleCategory(ctx, req.(*ArticleCategory))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_DeleteArticleCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).DeleteArticleCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_DeleteArticleCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).DeleteArticleCategory(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_GetArticleCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).GetArticleCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_GetArticleCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).GetArticleCategory(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_ListArticleCategories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).ListArticleCategories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_ListArticleCategories_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).ListArticleCategories(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_CheckKbHandle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).CheckKbHandle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_CheckKbHandle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).CheckKbHandle(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _KB_UpdateArticleTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArticleNode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KBServer).UpdateArticleTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KB_UpdateArticleTree_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KBServer).UpdateArticleTree(ctx, req.(*ArticleNode))
	}
	return interceptor(ctx, in, info, handler)
}

// KB_ServiceDesc is the grpc.ServiceDesc for KB service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KB_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.KB",
	HandlerType: (*KBServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateKnowledgeBase",
			Handler:    _KB_CreateKnowledgeBase_Handler,
		},
		{
			MethodName: "UpdateKnowledgeBase",
			Handler:    _KB_UpdateKnowledgeBase_Handler,
		},
		{
			MethodName: "DeleteKnowledgeBase",
			Handler:    _KB_DeleteKnowledgeBase_Handler,
		},
		{
			MethodName: "GetKnowledgeBase",
			Handler:    _KB_GetKnowledgeBase_Handler,
		},
		{
			MethodName: "ListKnowledgeBases",
			Handler:    _KB_ListKnowledgeBases_Handler,
		},
		{
			MethodName: "ListKnowledgeBaseEvents",
			Handler:    _KB_ListKnowledgeBaseEvents_Handler,
		},
		{
			MethodName: "CreateArticle",
			Handler:    _KB_CreateArticle_Handler,
		},
		{
			MethodName: "UpdateArticle",
			Handler:    _KB_UpdateArticle_Handler,
		},
		{
			MethodName: "DeleteArticle",
			Handler:    _KB_DeleteArticle_Handler,
		},
		{
			MethodName: "GetArticle",
			Handler:    _KB_GetArticle_Handler,
		},
		{
			MethodName: "ListArticles",
			Handler:    _KB_ListArticles_Handler,
		},
		{
			MethodName: "ListArticleVersions",
			Handler:    _KB_ListArticleVersions_Handler,
		},
		{
			MethodName: "SearchArticles",
			Handler:    _KB_SearchArticles_Handler,
		},
		{
			MethodName: "AddTopicToArticle",
			Handler:    _KB_AddTopicToArticle_Handler,
		},
		{
			MethodName: "RemoveTopicFromArticle",
			Handler:    _KB_RemoveTopicFromArticle_Handler,
		},
		{
			MethodName: "RateArticle",
			Handler:    _KB_RateArticle_Handler,
		},
		{
			MethodName: "ViewArticle",
			Handler:    _KB_ViewArticle_Handler,
		},
		{
			MethodName: "ReportArticle",
			Handler:    _KB_ReportArticle_Handler,
		},
		{
			MethodName: "ListRelatedArticles",
			Handler:    _KB_ListRelatedArticles_Handler,
		},
		{
			MethodName: "CreateArticleTopic",
			Handler:    _KB_CreateArticleTopic_Handler,
		},
		{
			MethodName: "UpdateArticleTopic",
			Handler:    _KB_UpdateArticleTopic_Handler,
		},
		{
			MethodName: "DeleteArticleTopic",
			Handler:    _KB_DeleteArticleTopic_Handler,
		},
		{
			MethodName: "ListArticleTopics",
			Handler:    _KB_ListArticleTopics_Handler,
		},
		{
			MethodName: "GetArticleTopic",
			Handler:    _KB_GetArticleTopic_Handler,
		},
		{
			MethodName: "CreateArticleCategory",
			Handler:    _KB_CreateArticleCategory_Handler,
		},
		{
			MethodName: "UpdateArticleCategory",
			Handler:    _KB_UpdateArticleCategory_Handler,
		},
		{
			MethodName: "DeleteArticleCategory",
			Handler:    _KB_DeleteArticleCategory_Handler,
		},
		{
			MethodName: "GetArticleCategory",
			Handler:    _KB_GetArticleCategory_Handler,
		},
		{
			MethodName: "ListArticleCategories",
			Handler:    _KB_ListArticleCategories_Handler,
		},
		{
			MethodName: "CheckKbHandle",
			Handler:    _KB_CheckKbHandle_Handler,
		},
		{
			MethodName: "UpdateArticleTree",
			Handler:    _KB_UpdateArticleTree_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	AndroidNotificationMgr_PushAndroidNotifications_FullMethodName = "/header.AndroidNotificationMgr/PushAndroidNotifications"
	AndroidNotificationMgr_PingAndroidDevice_FullMethodName        = "/header.AndroidNotificationMgr/PingAndroidDevice"
)

// AndroidNotificationMgrClient is the client API for AndroidNotificationMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AndroidNotificationMgrClient interface {
	PushAndroidNotifications(ctx context.Context, in *AndroidNotificationRequest, opts ...grpc.CallOption) (*Response, error)
	PingAndroidDevice(ctx context.Context, in *AndroidNotificationRequest, opts ...grpc.CallOption) (*Response, error)
}

type androidNotificationMgrClient struct {
	cc grpc.ClientConnInterface
}

func NewAndroidNotificationMgrClient(cc grpc.ClientConnInterface) AndroidNotificationMgrClient {
	return &androidNotificationMgrClient{cc}
}

func (c *androidNotificationMgrClient) PushAndroidNotifications(ctx context.Context, in *AndroidNotificationRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AndroidNotificationMgr_PushAndroidNotifications_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *androidNotificationMgrClient) PingAndroidDevice(ctx context.Context, in *AndroidNotificationRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AndroidNotificationMgr_PingAndroidDevice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AndroidNotificationMgrServer is the server API for AndroidNotificationMgr service.
// All implementations must embed UnimplementedAndroidNotificationMgrServer
// for forward compatibility.
type AndroidNotificationMgrServer interface {
	PushAndroidNotifications(context.Context, *AndroidNotificationRequest) (*Response, error)
	PingAndroidDevice(context.Context, *AndroidNotificationRequest) (*Response, error)
	mustEmbedUnimplementedAndroidNotificationMgrServer()
}

// UnimplementedAndroidNotificationMgrServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAndroidNotificationMgrServer struct{}

func (UnimplementedAndroidNotificationMgrServer) PushAndroidNotifications(context.Context, *AndroidNotificationRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushAndroidNotifications not implemented")
}
func (UnimplementedAndroidNotificationMgrServer) PingAndroidDevice(context.Context, *AndroidNotificationRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PingAndroidDevice not implemented")
}
func (UnimplementedAndroidNotificationMgrServer) mustEmbedUnimplementedAndroidNotificationMgrServer() {
}
func (UnimplementedAndroidNotificationMgrServer) testEmbeddedByValue() {}

// UnsafeAndroidNotificationMgrServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AndroidNotificationMgrServer will
// result in compilation errors.
type UnsafeAndroidNotificationMgrServer interface {
	mustEmbedUnimplementedAndroidNotificationMgrServer()
}

func RegisterAndroidNotificationMgrServer(s grpc.ServiceRegistrar, srv AndroidNotificationMgrServer) {
	// If the following call pancis, it indicates UnimplementedAndroidNotificationMgrServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AndroidNotificationMgr_ServiceDesc, srv)
}

func _AndroidNotificationMgr_PushAndroidNotifications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AndroidNotificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AndroidNotificationMgrServer).PushAndroidNotifications(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AndroidNotificationMgr_PushAndroidNotifications_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AndroidNotificationMgrServer).PushAndroidNotifications(ctx, req.(*AndroidNotificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AndroidNotificationMgr_PingAndroidDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AndroidNotificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AndroidNotificationMgrServer).PingAndroidDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AndroidNotificationMgr_PingAndroidDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AndroidNotificationMgrServer).PingAndroidDevice(ctx, req.(*AndroidNotificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AndroidNotificationMgr_ServiceDesc is the grpc.ServiceDesc for AndroidNotificationMgr service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AndroidNotificationMgr_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.AndroidNotificationMgr",
	HandlerType: (*AndroidNotificationMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PushAndroidNotifications",
			Handler:    _AndroidNotificationMgr_PushAndroidNotifications_Handler,
		},
		{
			MethodName: "PingAndroidDevice",
			Handler:    _AndroidNotificationMgr_PingAndroidDevice_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	Counter_Report_FullMethodName = "/header.Counter/Report"
	Counter_Count_FullMethodName  = "/header.Counter/Count"
)

// CounterClient is the client API for Counter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CounterClient interface {
	Report(ctx context.Context, in *CounterReportRequest, opts ...grpc.CallOption) (*CounterReportResponse, error)
	Count(ctx context.Context, in *CounterReportRequest, opts ...grpc.CallOption) (*CounterReportResponse, error)
}

type counterClient struct {
	cc grpc.ClientConnInterface
}

func NewCounterClient(cc grpc.ClientConnInterface) CounterClient {
	return &counterClient{cc}
}

func (c *counterClient) Report(ctx context.Context, in *CounterReportRequest, opts ...grpc.CallOption) (*CounterReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CounterReportResponse)
	err := c.cc.Invoke(ctx, Counter_Report_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *counterClient) Count(ctx context.Context, in *CounterReportRequest, opts ...grpc.CallOption) (*CounterReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CounterReportResponse)
	err := c.cc.Invoke(ctx, Counter_Count_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CounterServer is the server API for Counter service.
// All implementations must embed UnimplementedCounterServer
// for forward compatibility.
type CounterServer interface {
	Report(context.Context, *CounterReportRequest) (*CounterReportResponse, error)
	Count(context.Context, *CounterReportRequest) (*CounterReportResponse, error)
	mustEmbedUnimplementedCounterServer()
}

// UnimplementedCounterServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCounterServer struct{}

func (UnimplementedCounterServer) Report(context.Context, *CounterReportRequest) (*CounterReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Report not implemented")
}
func (UnimplementedCounterServer) Count(context.Context, *CounterReportRequest) (*CounterReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Count not implemented")
}
func (UnimplementedCounterServer) mustEmbedUnimplementedCounterServer() {}
func (UnimplementedCounterServer) testEmbeddedByValue()                 {}

// UnsafeCounterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CounterServer will
// result in compilation errors.
type UnsafeCounterServer interface {
	mustEmbedUnimplementedCounterServer()
}

func RegisterCounterServer(s grpc.ServiceRegistrar, srv CounterServer) {
	// If the following call pancis, it indicates UnimplementedCounterServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Counter_ServiceDesc, srv)
}

func _Counter_Report_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CounterReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CounterServer).Report(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Counter_Report_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CounterServer).Report(ctx, req.(*CounterReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Counter_Count_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CounterReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CounterServer).Count(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Counter_Count_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CounterServer).Count(ctx, req.(*CounterReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Counter_ServiceDesc is the grpc.ServiceDesc for Counter service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Counter_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.Counter",
	HandlerType: (*CounterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Report",
			Handler:    _Counter_Report_Handler,
		},
		{
			MethodName: "Count",
			Handler:    _Counter_Count_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	Crawler_Crawl_FullMethodName = "/header.Crawler/Crawl"
)

// CrawlerClient is the client API for Crawler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// internal
type CrawlerClient interface {
	Crawl(ctx context.Context, in *CrawlUrlRequest, opts ...grpc.CallOption) (*CrawlResponse, error)
}

type crawlerClient struct {
	cc grpc.ClientConnInterface
}

func NewCrawlerClient(cc grpc.ClientConnInterface) CrawlerClient {
	return &crawlerClient{cc}
}

func (c *crawlerClient) Crawl(ctx context.Context, in *CrawlUrlRequest, opts ...grpc.CallOption) (*CrawlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CrawlResponse)
	err := c.cc.Invoke(ctx, Crawler_Crawl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CrawlerServer is the server API for Crawler service.
// All implementations must embed UnimplementedCrawlerServer
// for forward compatibility.
//
// internal
type CrawlerServer interface {
	Crawl(context.Context, *CrawlUrlRequest) (*CrawlResponse, error)
	mustEmbedUnimplementedCrawlerServer()
}

// UnimplementedCrawlerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCrawlerServer struct{}

func (UnimplementedCrawlerServer) Crawl(context.Context, *CrawlUrlRequest) (*CrawlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Crawl not implemented")
}
func (UnimplementedCrawlerServer) mustEmbedUnimplementedCrawlerServer() {}
func (UnimplementedCrawlerServer) testEmbeddedByValue()                 {}

// UnsafeCrawlerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CrawlerServer will
// result in compilation errors.
type UnsafeCrawlerServer interface {
	mustEmbedUnimplementedCrawlerServer()
}

func RegisterCrawlerServer(s grpc.ServiceRegistrar, srv CrawlerServer) {
	// If the following call pancis, it indicates UnimplementedCrawlerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Crawler_ServiceDesc, srv)
}

func _Crawler_Crawl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CrawlUrlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CrawlerServer).Crawl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Crawler_Crawl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CrawlerServer).Crawl(ctx, req.(*CrawlUrlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Crawler_ServiceDesc is the grpc.ServiceDesc for Crawler service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Crawler_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.Crawler",
	HandlerType: (*CrawlerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Crawl",
			Handler:    _Crawler_Crawl_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	Marker_Mark_FullMethodName        = "/header.Marker/Mark"
	Marker_Commit_FullMethodName      = "/header.Marker/Commit"
	Marker_ListMarkers_FullMethodName = "/header.Marker/ListMarkers"
)

// MarkerClient is the client API for Marker service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MarkerClient interface {
	Mark(ctx context.Context, in *MarkRequest, opts ...grpc.CallOption) (*Empty, error)
	Commit(ctx context.Context, in *CommitRequest, opts ...grpc.CallOption) (*Empty, error)
	ListMarkers(ctx context.Context, in *MarkRequest, opts ...grpc.CallOption) (*Markers, error)
}

type markerClient struct {
	cc grpc.ClientConnInterface
}

func NewMarkerClient(cc grpc.ClientConnInterface) MarkerClient {
	return &markerClient{cc}
}

func (c *markerClient) Mark(ctx context.Context, in *MarkRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Marker_Mark_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *markerClient) Commit(ctx context.Context, in *CommitRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Marker_Commit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *markerClient) ListMarkers(ctx context.Context, in *MarkRequest, opts ...grpc.CallOption) (*Markers, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Markers)
	err := c.cc.Invoke(ctx, Marker_ListMarkers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MarkerServer is the server API for Marker service.
// All implementations must embed UnimplementedMarkerServer
// for forward compatibility.
type MarkerServer interface {
	Mark(context.Context, *MarkRequest) (*Empty, error)
	Commit(context.Context, *CommitRequest) (*Empty, error)
	ListMarkers(context.Context, *MarkRequest) (*Markers, error)
	mustEmbedUnimplementedMarkerServer()
}

// UnimplementedMarkerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMarkerServer struct{}

func (UnimplementedMarkerServer) Mark(context.Context, *MarkRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Mark not implemented")
}
func (UnimplementedMarkerServer) Commit(context.Context, *CommitRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Commit not implemented")
}
func (UnimplementedMarkerServer) ListMarkers(context.Context, *MarkRequest) (*Markers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMarkers not implemented")
}
func (UnimplementedMarkerServer) mustEmbedUnimplementedMarkerServer() {}
func (UnimplementedMarkerServer) testEmbeddedByValue()                {}

// UnsafeMarkerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MarkerServer will
// result in compilation errors.
type UnsafeMarkerServer interface {
	mustEmbedUnimplementedMarkerServer()
}

func RegisterMarkerServer(s grpc.ServiceRegistrar, srv MarkerServer) {
	// If the following call pancis, it indicates UnimplementedMarkerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Marker_ServiceDesc, srv)
}

func _Marker_Mark_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarkerServer).Mark(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Marker_Mark_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarkerServer).Mark(ctx, req.(*MarkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Marker_Commit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarkerServer).Commit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Marker_Commit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarkerServer).Commit(ctx, req.(*CommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Marker_ListMarkers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarkerServer).ListMarkers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Marker_ListMarkers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarkerServer).ListMarkers(ctx, req.(*MarkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Marker_ServiceDesc is the grpc.ServiceDesc for Marker service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Marker_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.Marker",
	HandlerType: (*MarkerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Mark",
			Handler:    _Marker_Mark_Handler,
		},
		{
			MethodName: "Commit",
			Handler:    _Marker_Commit_Handler,
		},
		{
			MethodName: "ListMarkers",
			Handler:    _Marker_ListMarkers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	VectorDB_UpsertVector_FullMethodName  = "/header.VectorDB/UpsertVector"
	VectorDB_DeleteVector_FullMethodName  = "/header.VectorDB/DeleteVector"
	VectorDB_SearchVectors_FullMethodName = "/header.VectorDB/SearchVectors"
	VectorDB_GetVector_FullMethodName     = "/header.VectorDB/GetVector"
	VectorDB_ListVectorIds_FullMethodName = "/header.VectorDB/ListVectorIds"
)

// VectorDBClient is the client API for VectorDB service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VectorDBClient interface {
	UpsertVector(ctx context.Context, in *VectorDoc, opts ...grpc.CallOption) (*Empty, error)
	DeleteVector(ctx context.Context, in *VectorDoc, opts ...grpc.CallOption) (*Empty, error)
	SearchVectors(ctx context.Context, in *VectorSearchReq, opts ...grpc.CallOption) (*VectorMatches, error)
	GetVector(ctx context.Context, in *VectorDoc, opts ...grpc.CallOption) (*VectorDoc, error)
	ListVectorIds(ctx context.Context, in *ListVectorRequest, opts ...grpc.CallOption) (*Response, error)
}

type vectorDBClient struct {
	cc grpc.ClientConnInterface
}

func NewVectorDBClient(cc grpc.ClientConnInterface) VectorDBClient {
	return &vectorDBClient{cc}
}

func (c *vectorDBClient) UpsertVector(ctx context.Context, in *VectorDoc, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, VectorDB_UpsertVector_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vectorDBClient) DeleteVector(ctx context.Context, in *VectorDoc, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, VectorDB_DeleteVector_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vectorDBClient) SearchVectors(ctx context.Context, in *VectorSearchReq, opts ...grpc.CallOption) (*VectorMatches, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VectorMatches)
	err := c.cc.Invoke(ctx, VectorDB_SearchVectors_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vectorDBClient) GetVector(ctx context.Context, in *VectorDoc, opts ...grpc.CallOption) (*VectorDoc, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VectorDoc)
	err := c.cc.Invoke(ctx, VectorDB_GetVector_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vectorDBClient) ListVectorIds(ctx context.Context, in *ListVectorRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, VectorDB_ListVectorIds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VectorDBServer is the server API for VectorDB service.
// All implementations must embed UnimplementedVectorDBServer
// for forward compatibility.
type VectorDBServer interface {
	UpsertVector(context.Context, *VectorDoc) (*Empty, error)
	DeleteVector(context.Context, *VectorDoc) (*Empty, error)
	SearchVectors(context.Context, *VectorSearchReq) (*VectorMatches, error)
	GetVector(context.Context, *VectorDoc) (*VectorDoc, error)
	ListVectorIds(context.Context, *ListVectorRequest) (*Response, error)
	mustEmbedUnimplementedVectorDBServer()
}

// UnimplementedVectorDBServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVectorDBServer struct{}

func (UnimplementedVectorDBServer) UpsertVector(context.Context, *VectorDoc) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertVector not implemented")
}
func (UnimplementedVectorDBServer) DeleteVector(context.Context, *VectorDoc) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteVector not implemented")
}
func (UnimplementedVectorDBServer) SearchVectors(context.Context, *VectorSearchReq) (*VectorMatches, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchVectors not implemented")
}
func (UnimplementedVectorDBServer) GetVector(context.Context, *VectorDoc) (*VectorDoc, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVector not implemented")
}
func (UnimplementedVectorDBServer) ListVectorIds(context.Context, *ListVectorRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListVectorIds not implemented")
}
func (UnimplementedVectorDBServer) mustEmbedUnimplementedVectorDBServer() {}
func (UnimplementedVectorDBServer) testEmbeddedByValue()                  {}

// UnsafeVectorDBServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VectorDBServer will
// result in compilation errors.
type UnsafeVectorDBServer interface {
	mustEmbedUnimplementedVectorDBServer()
}

func RegisterVectorDBServer(s grpc.ServiceRegistrar, srv VectorDBServer) {
	// If the following call pancis, it indicates UnimplementedVectorDBServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VectorDB_ServiceDesc, srv)
}

func _VectorDB_UpsertVector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VectorDoc)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VectorDBServer).UpsertVector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VectorDB_UpsertVector_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VectorDBServer).UpsertVector(ctx, req.(*VectorDoc))
	}
	return interceptor(ctx, in, info, handler)
}

func _VectorDB_DeleteVector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VectorDoc)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VectorDBServer).DeleteVector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VectorDB_DeleteVector_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VectorDBServer).DeleteVector(ctx, req.(*VectorDoc))
	}
	return interceptor(ctx, in, info, handler)
}

func _VectorDB_SearchVectors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VectorSearchReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VectorDBServer).SearchVectors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VectorDB_SearchVectors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VectorDBServer).SearchVectors(ctx, req.(*VectorSearchReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VectorDB_GetVector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VectorDoc)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VectorDBServer).GetVector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VectorDB_GetVector_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VectorDBServer).GetVector(ctx, req.(*VectorDoc))
	}
	return interceptor(ctx, in, info, handler)
}

func _VectorDB_ListVectorIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVectorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VectorDBServer).ListVectorIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VectorDB_ListVectorIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VectorDBServer).ListVectorIds(ctx, req.(*ListVectorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VectorDB_ServiceDesc is the grpc.ServiceDesc for VectorDB service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VectorDB_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "header.VectorDB",
	HandlerType: (*VectorDBServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpsertVector",
			Handler:    _VectorDB_UpsertVector_Handler,
		},
		{
			MethodName: "DeleteVector",
			Handler:    _VectorDB_DeleteVector_Handler,
		},
		{
			MethodName: "SearchVectors",
			Handler:    _VectorDB_SearchVectors_Handler,
		},
		{
			MethodName: "GetVector",
			Handler:    _VectorDB_GetVector_Handler,
		},
		{
			MethodName: "ListVectorIds",
			Handler:    _VectorDB_ListVectorIds_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}
